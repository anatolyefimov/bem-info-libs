<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.
Блок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации
являются ядром библиотеки блоков в соответствующих технологиях.</p>
<h2 id="js-реализация-блока-i-bem-2"><a href="#js-реализация-блока-i-bem-2" class="anchor"></a>js-реализация блока i-bem</h2>
<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления
блока в виде <code>JS</code> объекта с определёнными методами и свойствами. Это нужно, чтобы
писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем
абс<code>акции, чем</code>DOM` представлени
е.</p>
<p>Для того, чтобы js-представление блока использовало ядро <code>i-bem</code>, оно должно
быть написано с соблюдением специальных правил.</p>
<h4 id="Что-описано-на-этой-странице-2"><a href="#Что-описано-на-этой-странице-2" class="anchor"></a>Что описано на этой странице?</h4>
<ul>
<li>Какие бывают блоки<ul>
<li><a href="#dom.blocks">Блоки с DOM-представлением</a></li>
<li><a href="#abstract.blocks">Блоки без DOM-представления</a></li>
</ul>
</li>
<li>Принципы и особенности подхода<ul>
<li><a href="#decl">Декларативный принцип</a></li>
<li><a href="#block.getting">Доступ к другим блокам</a></li>
<li><a href="#mods">Работа с модификаторами</a></li>
<li><a href="#customization">Кастомизация блоков</a></li>
</ul>
</li>
<li><a href="#creation">Создание собственного bem-js блока</a></li>
<li>Подробнее о понятиях<ul>
<li><a href="#init">Инициализация</a></li>
<li><a href="#liveinit">Инициализация по требованию (live-инициализация~)</a></li>
<li><a href="#finding">Методы доступа к блокам и элементам</a></li>
<li><a href="#events">Работа с событиями</a></li>
</ul>
</li>
</ul>
<p><a name="dom.blocks"></a></p>
<h4 id="Блоки-с-dom-представлением-2"><a href="#Блоки-с-dom-представлением-2" class="anchor"></a>Блоки с DOM-представлением</h4>
<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о
том, что блоки имеют <code>DOM</code> представление.</p>
<p>В <code>HTML</code> блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code> классом <code>i-bem</code>
и специальным форматом записи параметров блока в <code>onclick</code>:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return { &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;
...
&lt;/div&gt;
</code></pre>
<p>Ниже подробно рассказано о <a href="#onclick.params">формате параметров в onclick</a>.</p>
<p><a name="abstract.blocks"></a></p>
<h4 id="Блоки-без-dom-представления-2"><a href="#Блоки-без-dom-представления-2" class="anchor"></a>Блоки без DOM-представления</h4>
<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code> представления.
Такие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими
можно так же, как и блоками с <code>DOM</code> представлением.</p>
<p>О том, как создавать такие блоки, написано под заголовком
<a href="#dom.decl">Декларация блока</a>.</p>
<p>Блоки, реализованные на <code>bem-js</code>,  после инициализации представлены в <code>js</code> объектами,
имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний
вид или поведение блока.</p>
<p>Технология <code>bem-js</code> использует предметную область <a href="http://wiki.yandex-team.ru/lento4ka/bem">концепции <code>BEM</code></a>.
Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>
<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой.</p>
<p>Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>
<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>
<p><a name="decl"></a></p>
<h2 id="Декларативный-принцип-2"><a href="#Декларативный-принцип-2" class="anchor"></a>Декларативный принцип</h2>
<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно
работе декларативных языков программирования, <code>js</code>-код содержит не последовательный
алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>
<h3 id="Декларация-блока-4"><a href="#Декларация-блока-4" class="anchor"></a>Декларация блока</h3>
<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям
применим код компонента:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-link&#39;, {
...
</code></pre>
<pre><code class="lang-js">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {
...
</code></pre>
<p><a href="#dom.decl">Подробнее о декларации блока</a></p>
<p><a name="mods.reaction"></a></p>
<h3 id="Реакция-на-изменение-модификаторов-4"><a href="#Реакция-на-изменение-модификаторов-4" class="anchor"></a>Реакция на изменение модификаторов</h3>
<p>Согласно концепции, состояния блока или его элементов определяются модификаторами.
Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть
специальные методы для установки и снятия модификаторов.</p>
<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора.
Эта запись тоже декларативна.</p>
<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-dropdowna&#39;, {

    onSetMod : {

        &#39;disabled&#39; : function(modName, modVal) {

            this._getSwitcher().setMod(modName, modVal);
            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();

        }

    },
...
</code></pre>
<p>Подробно <a href="#mods.callbacks">о декларации обработки модификаторов</a> рассказано в пункте про создание собственного блока.</p>
<p><a name="block.getting"></a></p>
<h2 id="Доступ-к-другим-блокам-2"><a href="#Доступ-к-другим-блокам-2" class="anchor"></a>Доступ к другим блокам</h2>
<p>Может возникнуть необходимость управлять другим блоком.
Для любых манипуляций с блоком необходимо получить доступ к <code>js</code>-объекту этого блока и вызывать его методы.</p>
<p><a name="blocks.finding"></a></p>
<h3 id="Доступ-к-bem-js-блоку-из-другого-bem-js-блока-2"><a href="#Доступ-к-bem-js-блоку-из-другого-bem-js-блока-2" class="anchor"></a>Доступ к bem-js-блоку из другого bem-js-блока.</h3>
<p>В случае <a href="#creation">реализации собственного кастомного блока на технологии <code>bem-js</code></a>,
блоку соответствует <code>js</code>-объект. Он наследует общие для всех блоков методы, позволяющие работать с <code>DOM</code> документа в терминах <code>BEM</code>. Среди этих методов есть методы поиска других блоков относительно текущего (<code>findBlock*</code>-методы).
Они возвращают <code>js</code>-объект искомого блока, что позволяет затем напрямую вызывать его методы.</p>
<p><strong>NB!</strong> Не используйте <code>jQuery</code>-селекторы для поиска блоков и элементов.</p>
<p>В этом примере вызывается метод <code>val()</code> у блока <code>b-form-checkbox</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-checkbox-example&#39;, {

    onSetMod: {
        &#39;js&#39;: function() {

            var checkbox = this.findBlockInside({
                        blockName : &#39;b-form-checkbox&#39;,
                        modName : &#39;type&#39;,
                        modVal : &#39;my-checkbox&#39;
                    });
            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());
        }
    }
}
);
</code></pre>
<h3 id="Доступ-к-bem-js-блоку-не-из-bem-js-блока-2"><a href="#Доступ-к-bem-js-блоку-не-из-bem-js-блока-2" class="anchor"></a>Доступ к bem-js-блоку не из bem-js-блока</h3>
<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock*</code> недоступны. <code>js</code>-объект блока можно
получить, используя метод <code>.bem()</code> <code>jQuery</code> коллекции:</p>
<pre><code class="lang-js">$(уникальный селектор).bem(&#39;b-link&#39;);
</code></pre>
<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>,
является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href="#creation">создании собственного bem-js-компонента</a> написано ниже.</p>
<p><a name="mods"></a></p>
<h2 id="Работа-с-модификаторами-блока-2"><a href="#Работа-с-модификаторами-блока-2" class="anchor"></a>Работа с модификаторами блока</h2>
<p>Модификатор задаёт блоку определённое состояние. Каждому блоку
можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще).
У модификатора есть имя и значение.</p>
<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора.
Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему
нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>
<p>На странице документации каждого блока есть список его элементов и модификаторов.
Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>
<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code> класс на соответствующей <code>DOM</code>-ноде. Для
корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи
метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod</code>/<code>getMods()</code>, <code>toggleMod()</code>
и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href="https://ru.bem.info/libs/bem-core/v2.5.0/desktop/i-bem/jsdoc/">референсе по i-bem__dom</a>.</p>
<p><a name="customization"></a></p>
<h2 id="Изменение-поведения-существующих-блоков-2"><a href="#Изменение-поведения-существующих-блоков-2" class="anchor"></a>Изменение поведения существующих блоков</h2>
<p>Используя <code>bem-js</code>, можно переопределять и доопределять
методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации
блоков на <code>CSS</code> или <code>BEMHTML</code>.</p>
<h3 id="Переопределение-поведения-2"><a href="#Переопределение-поведения-2" class="anchor"></a>Переопределение поведения</h3>
<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы
они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения
сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока
из библиотеки:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-dropdowna&#39;, {

    onSetMod : {

        &#39;js&#39; : function() {

            this._getSwitcher().on(&#39;click&#39;, this._on, this);

        }
    },
    _on : function() {
        this.getPopup().show(this.elem(&#39;switcher&#39;));
    }

})
</code></pre>
<h3 id="Расширение-поведения-2"><a href="#Расширение-поведения-2" class="anchor"></a>Расширение поведения</h3>
<p>В предыдущем примере код кастомизации полностью переопределяет поведение
блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение»
блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>,
передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен
использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>
<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> на проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>
<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>
<pre><code class="lang-js">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {
    _onClick : function() {
         this
            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link
            .setMod(&#39;status&#39;, &#39;clicked&#39;);
    }
});
</code></pre>
<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>
<pre><code class="lang-css">.b-link_status_clicked
{
    color: red;
}
</code></pre>
<h3 id="Кастомизация-с-использованием-модификаторов-2"><a href="#Кастомизация-с-использованием-модификаторов-2" class="anchor"></a>Кастомизация с использованием модификаторов</h3>
<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице.
Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>
<p>Возвращаясь к примеру про псевдоссылку, приобретающую красный цвет после первого
клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором
приобретает красный цвет после каждого
нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>
<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {
    _onClick : function() {
        this
            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link
            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);
    }
});
</code></pre>
<p><a name="creation"></a></p>
<h2 id="Создание-js-компонента-для-собственного-блока-или-собственной-модификации-2"><a href="#Создание-js-компонента-для-собственного-блока-или-собственной-модификации-2" class="anchor"></a>Создание js-компонента для собственного блока или собственной модификации</h2>
<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code>
(чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные
<code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.
<code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением
<code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно
разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>
<p><a name="dom.decl"></a></p>
<h3 id="Декларация-блока-5"><a href="#Декларация-блока-5" class="anchor"></a>Декларация блока</h3>
<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов.
Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление,
второй — для блоков, не имеющих <code>DOM</code> представления (например <code>i-request</code>, <code>i-update-session</code>).</p>
<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>
<p>Хелпер декларации блока принимает 3 параметра:</p>
<ol>
<li><p>Матчащий параметр</p>
<p>Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.</p>
</li>
<li><p>Методы и свойства экземляра блока</p>
<p>Методы и свойства, предметной областью которых является конкретный инстанс блока
на странице. Это как <a href="#mods.callbacks">функции обработки модификаторов</a>,
так и <a href="#methods">кастомные методы блока</a>.</p>
</li>
<li><p>Статические методы и свойства</p>
<p>Методы и свойства, не относящиеся к конкретному инстансу блока. <a href="#static.methods">Подробнее</a></p>
</li>
</ol>
<p>Например:</p>
<pre><code class="lang-js">BEM.DOM.decl(
    &#39;b-link&#39;, // имя блока
    {
        // методы и свойства экземпляра блока
    },
    {
        // статические методы и свойства блока
    });
</code></pre>
<p>и</p>
<pre><code class="lang-js">BEM.decl(&#39;i-request&#39;, {
    {
        // методы и свойства экземпляра блока
    },
    {
        // статические методы и свойства блока
});
</code></pre>
<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>
<pre><code class="lang-js">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {

    get : function() {
        this.__base(); // вызов одноименного метода из i-request
        doSomething();
    }

});
</code></pre>
<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>
<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку
применить компонент, но и уточнён модификатор и/или его значение:</p>
<pre><code class="lang-js">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {

    show : function() {
        doSomething();
    }

});
</code></pre>
<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>,
которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>
<p><a name="mods.callbacks"></a></p>
<h3 id="Реакция-на-изменение-модификаторов-5"><a href="#Реакция-на-изменение-модификаторов-5" class="anchor"></a>Реакция на изменение модификаторов</h3>
<p>Согласно концепции <code>BEM</code> состояния блоков и его элементов
определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор,
или получать это назначение из другого блока.</p>
<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть
необходимость отреагировать на установку (или снятие) модификатора.</p>
<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных
свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции,
вызываемые при установке модификаторов для блока или его элементов.</p>
<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>
<pre><code class="lang-js">{
    &#39;модификатор1&#39; : {

        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;

        ...

        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;

        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений

    },

    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений

    ...

    &#39;модификаторN&#39; : {

        &#39;значение1-модификатораN&#39; : function() { ... },

        ...

        &#39;значениеN-модификатораN&#39; : function() { ... }

    }

}
</code></pre>
<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>
<pre><code class="lang-js">{

    &#39;элемент1&#39; : {

        &#39;мо`фикатор1&#39; :
         {

            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;

            ...

            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;

            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;

        }

    },

    ...

    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;

}
</code></pre>
<p>Параметры <code>callback</code>-функций:</p>
<ul>
<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>
<li><code>{String} modName</code> — имя модификатора</li>
<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>
<li><code>{String} curModVal</code> — текущее значение модификатора</li>
</ul>
<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>
<ul>
<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>
<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>
<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>
</ul>
<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>
<p>Например:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-menu&#39;, {

    onElemSetMod : {

        &#39;trigger&#39; : {

            &#39;state&#39; : function(elem, modName, modVal) {

                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение
                this
                    .toggleMod(
                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),
                        &#39;visibility&#39;,
                        &#39;visible&#39;,
                        modVal == &#39;opened&#39;)
                    .trigger(&#39;trigger&#39;, {
                        domElem : elem,
                        state : modVal
                    });

            }

        }

    },

    onTriggerClick : function(e) { // при клике на триггер

        e.preventDefault();
        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;

    }

}, {

    live : function() {

        this
            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;
                this.onTriggerClick(e);
            });

    }

});
</code></pre>
<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствущая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>
<p><code>Callback</code> функции, реагирующие на изменение модификатора, выполняются до установки модификатора.
Если существует необходимость выполнить часть кода после установки модификатора,
нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>
<p>Пример ниже демонстрирует, что квадратик становится больше только после установки
модификатора:</p>
<pre><code class="lang-js">BEM`OM.decl(&#39;b-square2&#39;,
 {

    onSetMod : {

        &#39;js&#39; : function() {

            var square = this;

            this.bindTo(&#39;click&#39;, function(){
                square.setMod(&#39;size&#39;, &#39;big&#39;);
            });

        },
        &#39;size&#39; : function() {
            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200

            this.afterCurrentEvent(function(){
                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400
            });
        }
    }

});
</code></pre>
<h4 id="Начало-работы-с-блоком-модификатор-js-2"><a href="#Начало-работы-с-блоком-модификатор-js-2" class="anchor"></a>Начало работы с блоком (модификатор <code>js</code>)</h4>
<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-input&#39;, {

    onSetMod : {

        &#39;js&#39; : {

            &#39;inited&#39; : function() {

                this
                    .bindTo(this.elem(&#39;input&#39;), {
                        &#39;focus&#39; : this.onFocus,
                        &#39;blur&#39;  : this.onBlur
                    })

            }

        }

    }

});
</code></pre>
<p>Этот модификатор присваивается блоку в момент инициализации.
Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик
и является первой выполняющейся функцией блока.</p>
<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим
<code>DOM</code> представление, так и блокам без него. Так что, у блоков без <code>DOM</code> представления
первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>
<p>В коде блоков можно встретить <code>callback</code> функцию не на значение <code>inited</code> модификатора
<code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-input&#39;, {

    onSetMod : {

    &#39;js&#39; : function() { // конструктор b-form-input
        ...
        }

    }
});
</code></pre>
<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инциализации приобретает значение <code>inited</code>.
Другие значения модификатора сейчас не предусмотрены.</p>
<p><a name="methods"></a></p>
<h3 id="Методы-блока-2"><a href="#Методы-блока-2" class="anchor"></a>Методы блока</h3>
<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы.</p>
<p>Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>
<p>Например, так выглядит метод <code>.toggle()</code> блока b-form-checkbox:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {
    ...
    toggle : function() {
        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);
    }
    ...
});
</code></pre>
<h4 id="Переопределение-и-доопределение-методов-блока-2"><a href="#Переопределение-и-доопределение-методов-блока-2" class="anchor"></a>Переопределение и доопределение методов блока</h4>
<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён.
Об этом написано выше в пункте <a href="#customization">Изменение поведения существующих блоков</a>.</p>
<p><a name="static.methods"></a></p>
<h3 id="Статические-методы-блока-2"><a href="#Статические-методы-блока-2" class="anchor"></a>Статические методы блока</h3>
<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических
методов блока.</p>
<p>Примером блока, использующего статические методы, может служить <a href="https://ru.bem.info/libs/bem-core/current/touch-pad/ua/jsdoc/">блок ua</a>.</p>
<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать
<a href="#liveinit">инициализацию по требованию (liveinit~)</a>.</p>
<p><a name="init"></a></p>
<h2 id="Инициализация-2"><a href="#Инициализация-2" class="anchor"></a>Инициализация</h2>
<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации
блока.
Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code> дерева.
Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл
<code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию
domReady. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается
для инициализации блоков после динамического изменения страницы, если появились новые блоки с js-представлением.</p>
<h3 id="Инициализация-блоков-с-dom-представлением-2"><a href="#Инициализация-блоков-с-dom-представлением-2" class="anchor"></a>Инициализация блоков с DOM-представлением</h3>
<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,</p>
<p>по<code>ченные классом</code>i-bem<code>, у них считываются параметры из атрибута</code>onclick<code>, и
создаётся</code>js-объект` такого блока.</p>
<p><a name="onclick.params"></a></p>
<h4 id="Формат-параметров-блока-в-onclick-2"><a href="#Формат-параметров-блока-в-onclick-2" class="anchor"></a>Формат параметров блока в onclick</h4>
<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>onclick</code> хеша.
Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков,
к которым они относятся. Значением каждого элемента должен быть вложенный хеш c
параметрами.</p>
<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если
они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>
<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {
    &#39;b-my-block&#39; : {}
}&quot;&gt;
...
&lt;/div&gt;
</code></pre>
<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и
элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция.
Количество параметров также не ограничено.</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {
    &#39;b-my-block&#39; : {
        &#39;points&#39; : [
            [1.67, 2.5],
            [-30, 2.07],
            [290, -0.39]
        ],
        &#39;title&#39; : &#39;Какое-то название&#39;,
    }
}&quot;&gt;
..
&lt;/div&gt;
</code></pre>
<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; onclick=&quot;return {
    &#39;b-my-block&#39; : {
        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опцинальный параметр title
    },
    &#39;b-my-second-block&#39; : {
        // У этого блока нет никаких опциональных параметров
    }
}&quot;&gt;
...
&lt;/div&gt;
</code></pre>
<h4 id="dom-представление-инициализированного-блока-2"><a href="#dom-представление-инициализированного-блока-2" class="anchor"></a>DOM-представление инициализированного блока</h4>
<p>После инициализации <code>DOM</code> представление блока изменяется: у блока появляется дополнительный
модификатор <code>js_inited</code>.</p>
<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них
свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>
<p>DOM-представление блока после инициализации:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; onclick=&quot;return {
    &#39;b-my-block&#39; : {
        &#39;name&#39; : &#39;b-my-block&#39;
    }
}&quot;&gt;
...
&lt;/div&gt;
</code></pre>
<p><code>DOM</code> представление двух блоков после инициализации:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {
    &#39;b-my-block&#39; : {
        &#39;name&#39; : &#39;b-my-block&#39;,
    },
    &#39;b-my-second-block&#39; : {
        &#39;name&#39; : &#39;b-my-second-block&#39;
    }
}&quot;&gt;
</code></pre>
<p><code>DOM</code> представление двух блоков, но инициализован только один из них:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {
    &#39;b-my-block&#39; : {
        &#39;name&#39; : &#39;b-my-block&#39;,
    },
    &#39;b-my-second-block&#39; : {
        &#39;name&#39; : &#39;b-my-second-block&#39;
    }
}&quot;&gt;
</code></pre>
<h3 id="Инициализация-блоков-без-dom-представления-2"><a href="#Инициализация-блоков-без-dom-представления-2" class="anchor"></a>Инициализация блоков без DOM-представления</h3>
<p>В том случае, если у блока нет <code>DOM</code> представления, в процессе инициализации просто возникает
<code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>
<p><a name="liveinit"></a></p>
<h2 id="Инициализация-по-требованию-liveinit-2"><a href="#Инициализация-по-требованию-liveinit-2" class="anchor"></a>Инициализация по требованию (liveInit)</h2>
<p>Многим блокам (например, <a href="https://ru.bem.info/libs/bem-components/current/desktop/select/">select</a>) нет необходимости делать сразу же полную инициализацию.
Инициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.
Рассмотрим на примере блока <code>b-link</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-link&#39;, {

    _onClick : function(e) {

        e.preventDefault();
        this.trigger(&#39;click&#39;);

    }

}, {

    live : function() {

        this.liveBindTo(&#39;click&#39;, function(e) {
            this._onClick(e);
        });

    }

});
</code></pre>
<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code> элементах внутри такого блока.</p>
<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>
<p>Существует несколько хелперов для <code>live</code> событий:</p>
<pre><code>* `liveInitOnEvent` — хелпер для инициализации блока по событию на блоке или его внутреннем элементе
* `liveBindTo` — подписка на события на блоке или его внутреннем элементе
</code></pre><p>Оба этих хелпера инициализируют блок при возникновении первого такого события.
Различие же заключается в том, что <code>callback</code> функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии.
Контекстом такой <code>callback</code> функции является тот блок, в котором произошло событие.</p>
<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>
<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>,
то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>
<p><a name="finding"></a></p>
<h2 id="Методы-доступа-к-блокам-и-элементам-2"><a href="#Методы-доступа-к-блокам-и-элементам-2" class="anchor"></a>Методы доступа к блокам и элементам</h2>
<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать
встроенные методы для поиска блоков и их элементов. Эти методы доступны
в каждом блоке и умеют возвращать другой блок или <code>jQuery</code> коллекцию (в случае
поиска элементов).</p>
<h3 id="Методы-поиска-блоков-2"><a href="#Методы-поиска-блоков-2" class="anchor"></a>Методы поиска блоков</h3>
<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>
<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code>
внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-my-block&#39;, {
    onSetMod : {
        &#39;js&#39; : function() {
            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);
            checkbox.toggle();
        }
    }
});
</code></pre>
<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>
<ul>
<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code> элементов текущего блока или его элементов</li>
<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code> элементах текущего блока или его элементов</li>
<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code> элементов текущего блока или его элементов</li>
</ul>
<p>Список методов поиска блоков и их сигнатуры можно посмотреть в
<a href="https://ru.bem.info/libs/bem-core/v2.5.0/desktop/i-bem/jsdoc/">референсе по i-bem__dom</a>.</p>
<h3 id="Методы-доступа-к-элементам-2"><a href="#Методы-доступа-к-элементам-2" class="anchor"></a>Методы доступа к элементам</h3>
<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>
<p>Например:</p>
<pre><code class="lang-js">
BE`DOM.decl(&#39;b-form-input&#39;, {

    doSomething : function() {

        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint

    }

});
</code></pre>
<p>Можно искать элементы внутри блока с учетом модификатора:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-menu&#39;, {

    doSomething : function() {

        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current

    }

});
</code></pre>
<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>
<p>Полный список методов для поиска элементов и их сигнатуры можно найти в
<a href="https://ru.bem.info/libs/bem-core/v2.5.0/desktop/i-bem/jsdoc/">референсе по i-bem__dom</a>.</p>
<p><a name="events"></a></p>
<h2 id="Работа-с-событиями-2"><a href="#Работа-с-событиями-2" class="anchor"></a>Работа с событиями</h2>
<h3 id="События-на-блоках-2"><a href="#События-на-блоках-2" class="anchor"></a>События на блоках</h3>
<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>
<ul>
<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>
<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>
<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>
<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>
</ul>
<h3 id="live-события-на-блоках-2"><a href="#live-события-на-блоках-2" class="anchor"></a>live-события на блоках</h3>
<p>В <code>bem-js</code> есть события, реализованные по паттерну
делегированных событий, они называются <code>live</code> события.</p>
<p>Следующий пример демонстрирует работу с live-событием <code>click</code> для блоков <code>b-link</code>,
содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-link-example&#39;, {

    onSetMod: {
        &#39;js&#39;: function() {
            var link = this.findBlockInside(&#39;b-link&#39;);
            BEM.blocks[&#39;b-link&#39;]
                .liveCtxBind(link.domElem,
                            &#39;click&#39;,
                            function(){
                                link.domElem.text(&#39;Кликнутая ссылка&#39;);
                            },
                            this);
        }
    }
},
{
    live: function() {
        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);
    }
}
);
</code></pre>
<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков,
вложенных в какой-либо <code>DOM</code> элемент. <strong>Это не DOM-события</strong></p>
<p>Использование <code>live</code> событий позволяет избежать лишнего поиска блоков в <code>DOM</code> дереве.
Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет
происходить даже в том случае, если на момент привязки блока в контейнере не было, а он
появился позже в результате динамического изменения документа.</p>
<p>Кроме возможности привязки к <code>live</code> событию блока, здесь также продемонстрированы <a href="#blocks.finding">поиск блока относительно текущего</a> и <a href="#liveinit">live-инициалиация</a>.</p>

<p>Подключение данного модификатора позволяет работать с элементами почти так же, как и с обычными блоками, т.е. любой (но не обязательно каждый) элемент может иметь свой BEM-инстанс. API инстансов элементов аналогично API блоков с некоторыми различиями, описанными ниже.</p>
<h3 id="Декларация-2"><a href="#Декларация-2" class="anchor"></a>Декларация</h3>
<p>Декларация элемента</p>
<pre><code class="lang-javascript">BEMDOM.decl({ block: &#39;menu&#39;, elem: &#39;item&#39; }, { /* properties */ }, { /* static properties */ });
</code></pre>
<p>Декларация модификатора элемента:</p>
<pre><code class="lang-javascript">BEMDOM.decl({
    block: &#39;menu&#39;,
    elem: &#39;item&#39;,
    modName: &#39;state&#39;,
    modVal: &#39;current&#39;
}, {
    /* properties */
}, {
    /* static properties */
});
</code></pre>
<p>Модификаторы элементов работают так же, как модификаторы блоков.</p>
<h3 id="bem-инстансы-элементов-2"><a href="#bem-инстансы-элементов-2" class="anchor"></a>BEM-инстансы элементов</h3>
<p>Для доступа к BEM-инстансам элементов используется хелпер <code>findElemInstances</code>, API которого аналогично хелперу <code>findElem</code>:</p>
<pre><code class="lang-javascript">// поиск всех вложенных элементов &#39;item&#39;
this.findElemInstances(&#39;item&#39;);

// строгий поиск всех вложенных элементов &#39;item&#39;
this.findElemInstances(&#39;item&#39;, true);

// поиск всех вложенных модификаторов элементов &#39;item&#39;
this.findElemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;);

// строгий поиск всех вложенных модификаторов элементов &#39;item&#39;
this.findElemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;, true);

// поиск всех элементов &#39;item&#39; внутри указанного контекста
this.findElemInstances(ctx, &#39;item&#39;);

// строгий поиск всех элементов &#39;item&#39; внутри указанного контекста
this.findElemInstances(ctx, &#39;item&#39;, true);

// поиск всех модификаторов элементов &#39;item&#39; внутри указанного контекста
this.findElemInstances(ctx, &#39;item&#39;, &#39;state&#39;, &#39;current&#39;);

// строгий поиск всех модификаторов элементов &#39;item&#39; внутри указанного контекста
this.findElemInstances(ctx, &#39;item&#39;, &#39;state&#39;, &#39;current&#39;, true);
</code></pre>
<p>При необходимости, инстансы найденных элементов инициализируются.</p>
<p>Строгий поиск подразумевает фильтрацию элементов вложенных блоков с таким же именем, как у текущего блока:</p>
<pre><code class="lang-javascript">{
    block: &#39;menu&#39;,
    content: [
        {
            elem: &#39;item&#39; // (1)
        },
        {
            block: &#39;menu&#39;,
            content: {
                elem: &#39;item&#39; // (2)
            }
        }
    ]
}
</code></pre>
<pre><code class="lang-javascript">// this =&gt; block &#39;menu&#39;
this.findElemInstances(&#39;item&#39;);         // найдет инстансы (1) и (2)
this.findElemInstances(&#39;item&#39;, true);   // найдет только инстанс (1)
</code></pre>
<p>По аналогии с хелпером <code>elem</code>, кэширующим результаты своей работы, для минимизации количества операций с DOM рекомендуется использовать кэширующий поиск BEM-инстансов элементов:</p>
<pre><code class="lang-javascript">// кэширующий поиск всех вложенных элементов &#39;item&#39;
this.elemInstances(&#39;item&#39;);

// кэширующий поиск всех вложенных модификаторов элемента &#39;item&#39;
this.elemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;);
</code></pre>
<p>Также с помощью этого хелпера можно вернуть инстансы элементов, расположенных на DOM-нодах указанной jQuery-коллекции:</p>
<pre><code class="lang-javascript">this.elemInstances(domElem);
</code></pre>
<p>Для поиска одного (первого) BEM-инстанса элемента есть дополнительные формы этих хелперов с аналогичным API:</p>
<pre><code class="lang-javascript">// поиск одного вложенного элемента &#39;item&#39;
this.findElemInstance(&#39;item&#39;);

// кэширующий поиск одного вложенного элемента &#39;item&#39;
this.elemInstance(&#39;item&#39;);

// вернуть инстанс элемента, расположенного на первой DOM-ноде указанной jQuery-коллекции
this.elemInstance(domElem);
</code></pre>
<p>Если необходимо вернуть BEM-инстанс элемента, на DOM-ноде которого подмешаны другие элементы того же блока:</p>
<pre><code class="lang-javascript">this.elemInstance(this.elemify(domElem, &#39;item&#39;));
</code></pre>
<h3 id="Поиск-снаружи-контекста-2"><a href="#Поиск-снаружи-контекста-2" class="anchor"></a>Поиск снаружи контекста</h3>
<p>Существует хелпер для поиска элемента снаружи указанного контекста:</p>
<pre><code class="lang-javascript">{
    block: &#39;menu&#39;,
    content: {
        elem: &#39;item&#39;,
        content: {
            elem: &#39;link&#39;
        }
    }
}
</code></pre>
<pre><code class="lang-javascript">// this =&gt; block &#39;menu&#39;
this.closestElem(this.elem(&#39;link&#39;), &#39;item&#39;);
</code></pre>
<p>При поиске от имени BEM-инстанса элемента можно не указывать контекст поиска, тогда поиск будет производиться относительно DOM-ноды этого элемента:</p>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__link&#39;
this.closestElem(&#39;item&#39;);
</code></pre>
<p>По аналогии с хелперами <code>elem</code> и <code>findElem</code>, хелпер <code>closestElem</code> возвращает jQuery-коллекцию. Для доступа к BEM-инстансам элементов снаружи контекста используются хелперы <code>closestElemInstance</code> и <code>closestElemInstances</code>:</p>
<pre><code class="lang-javascript">// this =&gt; block &#39;menu&#39;
this.closestElemInstance(this.elem(&#39;link&#39;), &#39;item&#39;);
this.closestElemInstances(this.elem(&#39;link&#39;), &#39;item&#39;);
</code></pre>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__link&#39;
this.closestElemInstance(&#39;item&#39;);
</code></pre>
<h3 id="Доступ-к-родительскому-блоку-2"><a href="#Доступ-к-родительскому-блоку-2" class="anchor"></a>Доступ к родительскому блоку</h3>
<p>По аналогии с методом <code>elem</code> для получения элемента блока существует метод <code>block</code> для получения блока элемента.</p>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__item&#39;
this.block() // эквивалентно this.findBlockOutside(&#39;menu&#39;) с кэшированием результата поиска
</code></pre>
<h3 id="Поиск-элементов-и-блоков-2"><a href="#Поиск-элементов-и-блоков-2" class="anchor"></a>Поиск элементов и блоков</h3>
<p>Элемент ищет только вложенные в него элементы:</p>
<pre><code class="lang-javascript">{
    block: &#39;menu&#39;,
    content: [
        {
            elem: &#39;item&#39;,
            content: {
                elem: &#39;link&#39; // (1)
            }
        },
        {
            elem: &#39;link&#39; // (2)
        }
    ]
}
</code></pre>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__item&#39;
this.findElem(&#39;link&#39;);  // будет найден только элемент (1).
</code></pre>
<p>Если нужно найти все элементы <code>&#39;link&#39;</code>, поиск нужно производить от имени блока-родителя:</p>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__item&#39;
this.block().findElem(&#39;link&#39;);    // будут найдены элементы (1) и (2).
</code></pre>
<p>Все это справедливо также для хелпера <code>elem</code>, хелперов поиска блоков (<code>findBlockInside</code> и др.) и описанных выше хелперов для поиска BEM-инстансов элементов.</p>
<h3 id="Реакция-на-установку-модификаторов-2"><a href="#Реакция-на-установку-модификаторов-2" class="anchor"></a>Реакция на установку модификаторов</h3>
<p>Блок делегирует установку модификаторов тем элементам, у которых есть свои BEM-декларации.
Поэтому обработчики <code>onSetMod</code> элемента выполнятся, если родительский блок установит этому элементу соответствующие модификаторы:</p>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__item&#39;
onSetMod: {
    &#39;state&#39;: {
        &#39;current&#39;: function() {
            // код обработчика
        }
    }
}
</code></pre>
<pre><code class="lang-javascript">// this =&gt; block &#39;menu&#39;
this.setMod(this.elem(&#39;item&#39;), &#39;state&#39;, &#39;current&#39;); // выполнится задекларированный выше обработчик
</code></pre>
<p>Обработчики <code>onElemSetMod</code> блока выполнятся, если инстанс элемента сам установит себе соответствующие модификаторы:</p>
<pre><code class="lang-javascript">// this =&gt; block &#39;menu&#39;
onElemSetMod: {
    &#39;item&#39;: {
        &#39;state&#39;: {
            &#39;current&#39;: function() {
                // код обработчика
            }
        }
    }
}
</code></pre>
<pre><code class="lang-javascript">// this =&gt; element &#39;menu__item&#39;
this.setMod(&#39;state&#39;, &#39;current&#39;); // выполнится задекларированный выше обработчик
</code></pre>
<p>Обработчики <code>onElemSetMod</code> в контексте инстанса элемента не используются.</p>
<h3 id="Отложенная-инициализация-и-live-события-2"><a href="#Отложенная-инициализация-и-live-события-2" class="anchor"></a>Отложенная инициализация и live-события</h3>
<p>Рекомендуется по возможности всегда использовать отложенную инициализацию BEM-инстансов элементов. Они, как и обычные блоки, поддерживают все хелперы для работы с live-событиями. Кроме того, хелпер <code>liveInitOnBlockEvent</code> имеет дополнительную форму для инициализации по событию родительского блока - для этого просто опускается второй параметр (имя блока):</p>
<pre><code class="lang-javascript">this.liveInitOnBlockEvent(&#39;switch&#39;, function() { /* обработчик */ });
</code></pre>
