{"ru":{"name":"inherit","examples":[],"description":"<h1 id=\"inherit\"><a href=\"#inherit\" class=\"anchor\"></a>inherit</h1>\n<p>Блок предоставляет функцию, реализующую механизмы псевдоклассового наследования, и позволяет:</p>\n<ul>\n<li>создавать псевдокласс по декларации;</li>\n<li>задавать метод-конструктор;</li>\n<li>использовать миксины;</li>\n<li>вызывать методы базового блока (super call);</li>\n<li>использовать статические члены функции;</li>\n<li>получать доступ к статическим методам «класса» из его прототипа.</li>\n</ul>\n<p>Функция позволяет определить базовый «класс». А затем наследовать его логику, доопределяя ее новыми методами. </p>\n<p>Блок <code>inherit</code> реализован в технологии <code>vanila.js</code> и подходит для использования как на клиенте, так и на сервере.</p>\n<p>Блок является основой механизма наследования блоков в <code>bem-core</code>. Базовый блок <code>BEM</code> наследуется с помощью <code>inherit</code> от «класса» <code>Emitter</code> блока <code>events</code>:</p>\n<pre><code class=\"lang-js\">var BEM = inherit(events.Emitter, /** @lends BEM.prototype */ { ... }, { ... });\n</code></pre>\n<p>Все остальные блоки наследуются от блока <code>BEM</code> (или <code>BEMDOM</code> для блоков с DOM-представлением). Иначе говоря, доопределяют декларацию блока <code>BEM</code>.</p>\n<h2 id=\"Объявление-базового-класса\"><a href=\"#Объявление-базового-класса\" class=\"anchor\"></a>Объявление базового «класса»</h2>\n<p>Чтобы объявить базовый «класс» нужно воспользоваться функцией, реализованной блоком. Например, в декларации блока с автоинициализацией: </p>\n<pre><code class=\"lang-js\">modules.define(&#39;test1&#39;, [&#39;inherit&#39;], function(provide, inherit) {\n\nprovide(this.name, /** @lends test1.prototype */{\n            &#39;myInherit&#39; : function(props) {\n                // base &#39;class&#39;\n                return inherit(props);\n            }\n});\n});\n</code></pre>\n<p>Функция принимает на вход объект и возвращает полностью сформированную функцию-конструктор:</p>\n<pre><code class=\"lang-js\">Function inherit(Object props);\n</code></pre>\n<h3 id=\"Базовый-класс-со-статическими-свойствами\"><a href=\"#Базовый-класс-со-статическими-свойствами\" class=\"anchor\"></a>Базовый «класс» со статическими свойствами</h3>\n<p>При объявлении базового «класса» методу <code>inherit</code> можно передать вторым аргументом объект статических свойств:</p>\n<pre><code class=\"lang-js\">Function inherit(\n    Object props,\n    Object staticProps\n);\n</code></pre>\n<p>Свойства из объекта <code>staticProps</code> будут добавлены как статические к создаваемой функции-конструктору:</p>\n<pre><code class=\"lang-js\">var A = inherit(props, {\n    callMe : function() {\n        console.log(&#39;mr.Static&#39;);\n    }\n});\n\nA.callMe(); // mr.Static\n</code></pre>\n<p><strong>NB</strong> Статические методы функции-конструктора выполняются в контексте самой функции. Например, ссылка <code>this</code> внутри метода <code>callMe</code> будет указывать на функцию <code>A</code>.</p>\n<h3 id=\"Метод-__constructor\"><a href=\"#Метод-__constructor\" class=\"anchor\"></a>Метод <code>__constructor</code></h3>\n<p>Объект, на основе которого конструируется базовый «класс», может иметь зарезервированное свойство <code>__constructor</code>. Значением этого свойства должна быть функция, которая будет автоматически вызвана при создании экземпляра «класса».</p>\n<p>Использование <code>__constructor</code> позволяет задавать динамические свойства экземпляра «класса»:</p>\n<pre><code class=\"lang-js\">var A = inherit(/** @lends A.prototype */{\n    __constructor : function(property) { // constructor\n        this.property = property;\n    },\n\n    getProperty : function() {\n        return this.property + &#39; of instanceA&#39;;\n    }\n}),\n    aInst = new A(&#39;Property&#39;);\n\naInst.getProperty(); // Property of instanceA\n</code></pre>\n<h2 id=\"Создание-производного-класса\"><a href=\"#Создание-производного-класса\" class=\"anchor\"></a>Создание производного «класса»</h2>\n<p>Для создания производного «класса» методу <code>inherit</code> первым аргументом передается функция – базовый «класс»:</p>\n<pre><code class=\"lang-js\">Function inherit(\n    Function BaseClass,\n    Object props,\n    Object staticProps);\n</code></pre>\n<p>Второй и третий аргументы – объекты со свойствами производного «класса»:</p>\n<ul>\n<li><code>props</code> – собственные свойства (добавляются к прототипу).</li>\n<li><code>staticProps</code> – статические свойства.</li>\n</ul>\n<p>Если один из объектов содержит свойства, которые уже есть в базовом «классе» – свойства базового «класса» переопределятся. Иначе говоря, производный «класс» будет содержать значения из объекта.</p>\n<h3 id=\"Создание-производного-класса-с-миксинами\"><a href=\"#Создание-производного-класса-с-миксинами\" class=\"anchor\"></a>Создание производного «класса» с миксинами</h3>\n<p>При объявлении производного «класса» можно указать дополнительный набор функций. Их свойства будут примешаны к создаваемому «классу». Для этого первым аргументом (базовый «класс») нужно указать массив. Его первым элементом должен быть базовый «класс», последующими – примешиваемые функции:</p>\n<pre><code class=\"lang-js\">Function inherit(\n    [\n        Function BaseClass,\n        Function Mixin,\n        Function AnotherMixin,\n        ...\n    ],\n    Object props,\n    Object staticProps);\n</code></pre>\n<h2 id=\"Специальные-поля\"><a href=\"#Специальные-поля\" class=\"anchor\"></a>Специальные поля</h2>\n<h3 id=\"__self\"><a href=\"#__self\" class=\"anchor\"></a><code>__self</code></h3>\n<p>Поле позволяет получить доступ к статическим свойствам функции-конструктора непосредственно из ее прототипа:</p>\n<pre><code class=\"lang-js\">var A = inherit(/** @lends A.prototype */{\n    getStaticProperty : function() {\n        return this.__self.staticMethod; // access to static\n    }\n}, /** @lends A */ {    \n    staticProperty : &#39;staticA&#39;,\n\n    staticMethod : function() {\n        return this.staticProperty;\n    }\n}),\n    aInst = new A();\naInst.getStaticProperty(); //staticA\n</code></pre>\n<h3 id=\"__base\"><a href=\"#__base\" class=\"anchor\"></a><code>__base</code></h3>\n<p>Поле позволяет внутри производного «класса» использовать методы базового (supercall). Поле <code>__base</code> позволяет вызвать так же статические методы базового «класса»:</p>\n<pre><code class=\"lang-js\">var A = inherit(/** @lends A.prototype */{\n    getType : function() {\n        return &#39;A&#39;;\n    }\n}, /** @lends A */ {    \n    staticProperty : &#39;staticA&#39;,\n\n    staticMethod : function() {\n        return this.staticProperty;\n    }\n});\n\n// inherited &#39;class&#39; from A\nvar B = inherit(A, /** @lends B.prototype */{\n    getType : function() { // overriding + &#39;super&#39; call\n        return this.__base() + &#39;B&#39;;\n    }\n}, /** @lends B */ {\n    staticMethod : function() { // static overriding + &#39;super&#39; call\n        return this.__base() + &#39; of staticB&#39;;\n    }\n});\n\nvar instanceOfB = new B();\n\ninstanceOfB.getType(); // returns &#39;AB&#39;\nB.staticMethod(); // returns &#39;staticA of staticB&#39;\n</code></pre>\n<h2 id=\"Расширенный-пример\"><a href=\"#Расширенный-пример\" class=\"anchor\"></a>Расширенный пример</h2>\n<p>Ниже приведен пример модуля, использующего все основные способы наследования блока <code>inherit</code>:</p>\n<pre><code class=\"lang-js\">// base &#39;class&#39;\nvar A = inherit(/** @lends A.prototype */{\n    __constructor : function(property) { // constructor\n        this.property = property;\n    },\n\n    getProperty : function() {\n        return this.property + &#39; of instanceA&#39;;\n    },\n\n    getType : function() {\n        return &#39;A&#39;;\n    },\n\n    getStaticProperty : function() {\n        return this.__self.staticMethod; // access to static\n    }\n}, /** @lends A */ {    \n    staticProperty : &#39;staticA&#39;,\n\n    staticMethod : function() {\n        return this.staticProperty;\n    }\n});\n\n// inherited &#39;class&#39; from A\nvar B = inherit(A, /** @lends B.prototype */{\n    getProperty : function() { // overriding\n        return this.property + &#39; of instanceB&#39;;\n    },\n\n    getType : function() { // overriding + &#39;super&#39; call\n        return this.__base() + &#39;B&#39;;\n    }\n}, /** @lends B */ {\n    staticMethod : function() { // static overriding + &#39;super&#39; call\n        return this.__base() + &#39; of staticB&#39;;\n    }\n});\n\n// mixin M\nvar M = inherit({\n    getMixedProperty : function() {\n        return &#39;mixed property&#39;;\n    }\n});\n\n// inherited &#39;class&#39; from A with mixin M\nvar C = inherit([A, M], {\n    getMixedProperty : function() {\n        return this.__base() + &#39; from C&#39;;\n    }\n});\n\nvar instanceOfB = new B(&#39;property&#39;);\n\ninstanceOfB.getProperty(); // returns &#39;property of instanceB&#39;\ninstanceOfB.getType(); // returns &#39;AB&#39;\nB.staticMethod(); // returns &#39;staticA of staticB&#39;\n\nvar instanceOfC = new C();\ninstanceOfC.getMixedProperty(); // returns &#39;mixed property from C&#39;\n</code></pre>\n"},"en":{"name":"inherit","examples":[],"description":""}}