{"ru":{"name":"tick","examples":[],"description":"<h1 id=\"tick\"><a href=\"#tick\" class=\"anchor\"></a>tick</h1>\n<p>Блок <code>tick</code> служит для генерации регулярного события <code>tick</code>. Подписавшись на событие блока, можно использовать его для поллинга и синхронизации выполняемых операций.</p>\n<p>Блок реализован в технологии <code>vanilla.js</code> и подходит для использования как на клиенте, так и на сервере.</p>\n<h2 id=\"Интервал-между-событиями\"><a href=\"#Интервал-между-событиями\" class=\"anchor\"></a>Интервал между событиями</h2>\n<p>Частота, с которой блок генерирует событие <code>tick</code>, определяется значением приватной переменной <code>TICK_INTERVAL</code>. Значение переменной – целое число – интервал между событиями в миллисекундах. </p>\n<p>По умолчанию <code>TICK_INTERVAL = 50</code>. Не рекомендуется изменять значение переменной.</p>\n<h2 id=\"Публичные-методы-блока-4\"><a href=\"#Публичные-методы-блока-4\" class=\"anchor\"></a>Публичные методы блока</h2>\n<p>Блок предоставляет следующие публичные методы:</p>\n<ul>\n<li><code>start</code> – запускает генерацию события <code>tick</code> и счетчик, если они еще не запущены. Событие <code>tick</code> генерируется через интервал, равный значению <code>TICK_INTERVAL</code> после вызова метода;</li>\n<li><code>stop</code> – останавливает генерацию события.</li>\n</ul>\n<p>Методы не принимают никаких аргументов.</p>\n<pre><code class=\"lang-js\">modules.define(&#39;tick-emmiter&#39;,\n    [&#39;i-bem__dom&#39;, &#39;tick&#39;],\n    function(provide, BEMDOM, tick) {\n\nprovide(BEMDOM.decl(this.name, {\n    onSetMod : {\n        &#39;js&#39; : {\n            &#39;inited&#39; : function() { \n                this.setMod(&#39;ticking&#39;);\n            },\n\n            &#39;&#39; : function() {\n                this.delMod(&#39;ticking&#39;);\n            }\n        },\n\n        &#39;ticking&#39; : {\n            &#39;true&#39; : function() {\n                tick.start();\n            },\n\n            &#39;&#39; : function() {\n                tick.stop();\n            }\n        }\n    }\n}));\n});\n</code></pre>\n<p>Блок наследуется от «клсаса» <code>Emitter</code> блока <code>events</code>, что позволяет вызывать методы класса.\nНапример, в блоке <code>input</code> для поллинга производится подписка на событие <code>tick</code> помощью унаследованного <code>tick.on</code>:</p>\n<pre><code class=\"lang-js\">modules.define(&#39;input&#39;, [&#39;tick&#39;, &#39;idle&#39;], function(provide, tick, idle, Input) {\n\nvar instances = [],\n    boundToTick,\n    bindToTick = function() {\n        boundToTick = true;\n        tick\n            .on(&#39;tick&#39;, update) // подписываемся на событие tick \n            .start(); // запускаем генерацию события tick\n        idle\n            .on({\n                idle : function() {\n                    tick.un(&#39;tick&#39;, update); // по событию idle отписываемся от tick\n                },\n                wakeup : function() {\n                    tick.on(&#39;tick&#39;, update); // по событию wakeup подписываемся обратно\n                }\n            })\n            .start();\n    },\n    update = function() { /* ... */ };\n\n});\n</code></pre>\n<h2 id=\"Модификаторы-блока-1\"><a href=\"#Модификаторы-блока-1\" class=\"anchor\"></a>Модификаторы блока</h2>\n<h3 id=\"start_auto\"><a href=\"#start_auto\" class=\"anchor\"></a>start_auto</h3>\n<p>Блок с модификатором <code>start</code> в значении <code>auto</code> используется для автоматического запуска генерации события <code>tick</code>. Событие начинает генерироваться в момент инициализации блока.</p>\n"},"en":{"name":"tick","examples":[],"description":""}}