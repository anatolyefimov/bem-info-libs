{"ru":{"name":"i-bem","examples":[],"description":"<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации\nявляются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h2 id=\"js-реализация-блока-i-bem\"><a href=\"#js-реализация-блока-i-bem\" class=\"anchor\"></a>js-реализация блока i-bem</h2>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления\nблока в виде <code>JS</code> объекта с определёнными методами и свойствами. Это нужно, чтобы\nписать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем\nабс<code>акции, чем</code>DOM` представлени\nе.</p>\n<p>Для того, чтобы js-представление блока использовало ядро <code>i-bem</code>, оно должно\nбыть написано с соблюдением специальных правил.</p>\n<h4 id=\"Что-описано-на-этой-странице-\"><a href=\"#Что-описано-на-этой-странице-\" class=\"anchor\"></a>Что описано на этой странице?</h4>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного bem-js блока</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация~)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h4 id=\"Блоки-с-DOM-представлением\"><a href=\"#Блоки-с-DOM-представлением\" class=\"anchor\"></a>Блоки с DOM-представлением</h4>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о\nтом, что блоки имеют <code>DOM</code> представление.</p>\n<p>В <code>HTML</code> блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code> классом <code>i-bem</code>\nи специальным форматом записи параметров блока в <code>onclick</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return { &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#onclick.params\">формате параметров в onclick</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h4 id=\"Блоки-без-DOM-представления\"><a href=\"#Блоки-без-DOM-представления\" class=\"anchor\"></a>Блоки без DOM-представления</h4>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code> представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими\nможно так же, как и блоками с <code>DOM</code> представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком\n<a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>,  после инициализации представлены в <code>js</code> объектами,\nимеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний\nвид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://wiki.yandex-team.ru/lento4ka/bem\">концепции <code>BEM</code></a>.\nВсе сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой.</p>\n<p>Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h2 id=\"Декларативный-принцип\"><a href=\"#Декларативный-принцип\" class=\"anchor\"></a>Декларативный принцип</h2>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно\nработе декларативных языков программирования, <code>js</code>-код содержит не последовательный\nалгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h3 id=\"Декларация-блока\"><a href=\"#Декларация-блока\" class=\"anchor\"></a>Декларация блока</h3>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям\nприменим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h3 id=\"Реакция-на-изменение-модификаторов\"><a href=\"#Реакция-на-изменение-модификаторов\" class=\"anchor\"></a>Реакция на изменение модификаторов</h3>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами.\nПоэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть\nспециальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора.\nЭта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n\n        }\n\n    },\n...\n</code></pre>\n<p>Подробно <a href=\"#mods.callbacks\">о декларации обработки модификаторов</a> рассказано в пункте про создание собственного блока.</p>\n<p><a name=\"block.getting\"></a></p>\n<h2 id=\"Доступ-к-другим-блокам\"><a href=\"#Доступ-к-другим-блокам\" class=\"anchor\"></a>Доступ к другим блокам</h2>\n<p>Может возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к <code>js</code>-объекту этого блока и вызывать его методы.</p>\n<p><a name=\"blocks.finding\"></a></p>\n<h3 id=\"Доступ-к-bem-js-блоку-из-другого-bem-js-блока-\"><a href=\"#Доступ-к-bem-js-блоку-из-другого-bem-js-блока-\" class=\"anchor\"></a>Доступ к bem-js-блоку из другого bem-js-блока.</h3>\n<p>В случае <a href=\"#creation\">реализации собственного кастомного блока на технологии <code>bem-js</code></a>,\nблоку соответствует <code>js</code>-объект. Он наследует общие для всех блоков методы, позволяющие работать с <code>DOM</code> документа в терминах <code>BEM</code>. Среди этих методов есть методы поиска других блоков относительно текущего (<code>findBlock*</code>-методы).\nОни возвращают <code>js</code>-объект искомого блока, что позволяет затем напрямую вызывать его методы.</p>\n<p><strong>NB!</strong> Не используйте <code>jQuery</code>-селекторы для поиска блоков и элементов.</p>\n<p>В этом примере вызывается метод <code>val()</code> у блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n\n            var checkbox = this.findBlockInside({\n                        blockName : &#39;b-form-checkbox&#39;,\n                        modName : &#39;type&#39;,\n                        modVal : &#39;my-checkbox&#39;\n                    });\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h3 id=\"Доступ-к-bem-js-блоку-не-из-bem-js-блока\"><a href=\"#Доступ-к-bem-js-блоку-не-из-bem-js-блока\" class=\"anchor\"></a>Доступ к bem-js-блоку не из bem-js-блока</h3>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock*</code> недоступны. <code>js</code>-объект блока можно\nполучить, используя метод <code>.bem()</code> <code>jQuery</code> коллекции:</p>\n<pre><code class=\"lang-js\">$(уникальный селектор).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>,\nявляется создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h2 id=\"Работа-с-модификаторами-блока\"><a href=\"#Работа-с-модификаторами-блока\" class=\"anchor\"></a>Работа с модификаторами блока</h2>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку\nможно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще).\nУ модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора.\nНапример, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему\nнужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов.\nИз этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code> класс на соответствующей <code>DOM</code>-ноде. Для\nкорректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи\nметода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod</code>/<code>getMods()</code>, <code>toggleMod()</code>\nи <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"https://ru.bem.info/libs/bem-core/v2.5.0/desktop/i-bem/jsdoc/\">референсе по i-bem__dom</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h2 id=\"Изменение-поведения-существующих-блоков\"><a href=\"#Изменение-поведения-существующих-блоков\" class=\"anchor\"></a>Изменение поведения существующих блоков</h2>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять\nметоды блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации\nблоков на <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h3 id=\"Переопределение-поведения\"><a href=\"#Переопределение-поведения\" class=\"anchor\"></a>Переопределение поведения</h3>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы\nони не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения\nсервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока\nиз библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n\n})\n</code></pre>\n<h3 id=\"Расширение-поведения\"><a href=\"#Расширение-поведения\" class=\"anchor\"></a>Расширение поведения</h3>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение\nблока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение»\nблока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>,\nпередавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен\nиспользованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> на проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h3 id=\"Кастомизация-с-использованием-модификаторов\"><a href=\"#Кастомизация-с-использованием-модификаторов\" class=\"anchor\"></a>Кастомизация с использованием модификаторов</h3>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице.\nНо очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдоссылку, приобретающую красный цвет после первого\nклика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором\nприобретает красный цвет после каждого\nнечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n        this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h2 id=\"Создание-js-компонента-для-собственного-блока-или-собственной-модификации\"><a href=\"#Создание-js-компонента-для-собственного-блока-или-собственной-модификации\" class=\"anchor\"></a>Создание js-компонента для собственного блока или собственной модификации</h2>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code>\n(чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные\n<code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.\n<code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением\n<code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно\nразместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h3 id=\"Декларация-блока\"><a href=\"#Декларация-блока\" class=\"anchor\"></a>Декларация блока</h3>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов.\nСуществуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление,\nвторой — для блоков, не имеющих <code>DOM</code> представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li><p>Матчащий параметр</p>\n<p>Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.</p>\n</li>\n<li><p>Методы и свойства экземляра блока</p>\n<p>Методы и свойства, предметной областью которых является конкретный инстанс блока\nна странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>,\nтак и <a href=\"#methods\">кастомные методы блока</a>.</p>\n</li>\n<li><p>Статические методы и свойства</p>\n<p>Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></p>\n</li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку\nприменить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>,\nкоторые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h3 id=\"Реакция-на-изменение-модификаторов\"><a href=\"#Реакция-на-изменение-модификаторов\" class=\"anchor\"></a>Реакция на изменение модификаторов</h3>\n<p>Согласно концепции <code>BEM</code> состояния блоков и его элементов\nопределяются модификаторами. Блок может сам назначать себе или своему элементу модификатор,\nили получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть\nнеобходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных\nсвойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции,\nвызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;мо`фикатор1&#39; :\n         {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствущая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code> функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора,\nнужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки\nмодификатора:</p>\n<pre><code class=\"lang-js\">BEM`OM.decl(&#39;b-square2&#39;,\n {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h4 id=\"Начало-работы-с-блоком--модификатор-`js`-\"><a href=\"#Начало-работы-с-блоком--модификатор-`js`-\" class=\"anchor\"></a>Начало работы с блоком (модификатор <code>js</code>)</h4>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации.\nПоскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик\nи является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим\n<code>DOM</code> представление, так и блокам без него. Так что, у блоков без <code>DOM</code> представления\nпервый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code> функцию не на значение <code>inited</code> модификатора\n<code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инциализации приобретает значение <code>inited</code>.\nДругие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h3 id=\"Методы-блока\"><a href=\"#Методы-блока\" class=\"anchor\"></a>Методы блока</h3>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы.</p>\n<p>Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока b-form-checkbox:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h4 id=\"Переопределение-и-доопределение-методов-блока\"><a href=\"#Переопределение-и-доопределение-методов-блока\" class=\"anchor\"></a>Переопределение и доопределение методов блока</h4>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён.\nОб этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h3 id=\"Статические-методы-блока\"><a href=\"#Статические-методы-блока\" class=\"anchor\"></a>Статические методы блока</h3>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических\nметодов блока.</p>\n<p>Примером блока, использующего статические методы, может служить <a href=\"https://ru.bem.info/libs/bem-core/current/touch-pad/ua/jsdoc/\">блок ua</a>.</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать\n<a href=\"#liveinit\">инициализацию по требованию (liveinit~)</a>.</p>\n<p><a name=\"init\"></a></p>\n<h2 id=\"Инициализация\"><a href=\"#Инициализация\" class=\"anchor\"></a>Инициализация</h2>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации\nблока.\nИнициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code> дерева.\nЕсли элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл\n<code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию\ndomReady. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается\nдля инициализации блоков после динамического изменения страницы, если появились новые блоки с js-представлением.</p>\n<h3 id=\"Инициализация-блоков-с-DOM-представлением\"><a href=\"#Инициализация-блоков-с-DOM-представлением\" class=\"anchor\"></a>Инициализация блоков с DOM-представлением</h3>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,</p>\n<p>по<code>ченные классом</code>i-bem<code>, у них считываются параметры из атрибута</code>onclick<code>, и\nсоздаётся</code>js-объект` такого блока.</p>\n<p><a name=\"onclick.params\"></a></p>\n<h4 id=\"Формат-параметров-блока-в-onclick\"><a href=\"#Формат-параметров-блока-в-onclick\" class=\"anchor\"></a>Формат параметров блока в onclick</h4>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>onclick</code> хеша.\nЭтот хеш должен содержать элементы с названиями, соответствующими названиям блоков,\nк которым они относятся. Значением каждого элемента должен быть вложенный хеш c\nпараметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если\nони представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и\nэлемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция.\nКоличество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опцинальный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<h4 id=\"DOM-представление-инициализированного-блока\"><a href=\"#DOM-представление-инициализированного-блока\" class=\"anchor\"></a>DOM-представление инициализированного блока</h4>\n<p>После инициализации <code>DOM</code> представление блока изменяется: у блока появляется дополнительный\nмодификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них\nсвидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p>DOM-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code> представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code> представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h3 id=\"Инициализация-блоков-без-DOM-представления\"><a href=\"#Инициализация-блоков-без-DOM-представления\" class=\"anchor\"></a>Инициализация блоков без DOM-представления</h3>\n<p>В том случае, если у блока нет <code>DOM</code> представления, в процессе инициализации просто возникает\n<code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h2 id=\"Инициализация-по-требованию--liveInit-\"><a href=\"#Инициализация-по-требованию--liveInit-\" class=\"anchor\"></a>Инициализация по требованию (liveInit)</h2>\n<p>Многим блокам (например, <a href=\"https://ru.bem.info/libs/bem-components/current/desktop/select/\">select</a>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code> элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code> событий:</p>\n<pre><code>* `liveInitOnEvent` — хелпер для инициализации блока по событию на блоке или его внутреннем элементе\n* `liveBindTo` — подписка на события на блоке или его внутреннем элементе\n</code></pre><p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code> функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии.\nКонтекстом такой <code>callback</code> функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>,\nто такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h2 id=\"Методы-доступа-к-блокам-и-элементам\"><a href=\"#Методы-доступа-к-блокам-и-элементам\" class=\"anchor\"></a>Методы доступа к блокам и элементам</h2>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать\nвстроенные методы для поиска блоков и их элементов. Эти методы доступны\nв каждом блоке и умеют возвращать другой блок или <code>jQuery</code> коллекцию (в случае\nпоиска элементов).</p>\n<h3 id=\"Методы-поиска-блоков\"><a href=\"#Методы-поиска-блоков\" class=\"anchor\"></a>Методы поиска блоков</h3>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code>\nвнутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code> элементов текущего блока или его элементов</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code> элементах текущего блока или его элементов</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code> элементов текущего блока или его элементов</li>\n</ul>\n<p>Список методов поиска блоков и их сигнатуры можно посмотреть в\n<a href=\"https://ru.bem.info/libs/bem-core/v2.5.0/desktop/i-bem/jsdoc/\">референсе по i-bem__dom</a>.</p>\n<h3 id=\"Методы-доступа-к-элементам\"><a href=\"#Методы-доступа-к-элементам\" class=\"anchor\"></a>Методы доступа к элементам</h3>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">\nBE`DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p>Полный список методов для поиска элементов и их сигнатуры можно найти в\n<a href=\"https://ru.bem.info/libs/bem-core/v2.5.0/desktop/i-bem/jsdoc/\">референсе по i-bem__dom</a>.</p>\n<p><a name=\"events\"></a></p>\n<h2 id=\"Работа-с-событиями\"><a href=\"#Работа-с-событиями\" class=\"anchor\"></a>Работа с событиями</h2>\n<h3 id=\"События-на-блоках\"><a href=\"#События-на-блоках\" class=\"anchor\"></a>События на блоках</h3>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h3 id=\"live-события-на-блоках\"><a href=\"#live-события-на-блоках\" class=\"anchor\"></a>live-события на блоках</h3>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну\nделегированных событий, они называются <code>live</code> события.</p>\n<p>Следующий пример демонстрирует работу с live-событием <code>click</code> для блоков <code>b-link</code>,\nсодержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков,\nвложенных в какой-либо <code>DOM</code> элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code> событий позволяет избежать лишнего поиска блоков в <code>DOM</code> дереве.\nКроме того, при такой привязке к событию реакция на событие блока из контейнера будет\nпроисходить даже в том случае, если на момент привязки блока в контейнере не было, а он\nпоявился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code> событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<p>Подключение данного модификатора позволяет работать с элементами почти так же, как и с обычными блоками, т.е. любой (но не обязательно каждый) элемент может иметь свой BEM-инстанс. API инстансов элементов аналогично API блоков с некоторыми различиями, описанными ниже.</p>\n<h3 id=\"Декларация\"><a href=\"#Декларация\" class=\"anchor\"></a>Декларация</h3>\n<p>Декларация элемента</p>\n<pre><code class=\"lang-javascript\">BEMDOM.decl({ block: &#39;menu&#39;, elem: &#39;item&#39; }, { /* properties */ }, { /* static properties */ });\n</code></pre>\n<p>Декларация модификатора элемента:</p>\n<pre><code class=\"lang-javascript\">BEMDOM.decl({\n    block: &#39;menu&#39;,\n    elem: &#39;item&#39;,\n    modName: &#39;state&#39;,\n    modVal: &#39;current&#39;\n}, {\n    /* properties */\n}, {\n    /* static properties */\n});\n</code></pre>\n<p>Модификаторы элементов работают так же, как модификаторы блоков.</p>\n<h3 id=\"BEM-инстансы-элементов\"><a href=\"#BEM-инстансы-элементов\" class=\"anchor\"></a>BEM-инстансы элементов</h3>\n<p>Для доступа к BEM-инстансам элементов используется хелпер <code>findElemInstances</code>, API которого аналогично хелперу <code>findElem</code>:</p>\n<pre><code class=\"lang-javascript\">// поиск всех вложенных элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;);\n\n// строгий поиск всех вложенных элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;, true);\n\n// поиск всех вложенных модификаторов элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;);\n\n// строгий поиск всех вложенных модификаторов элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;, true);\n\n// поиск всех элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;);\n\n// строгий поиск всех элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;, true);\n\n// поиск всех модификаторов элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;, &#39;state&#39;, &#39;current&#39;);\n\n// строгий поиск всех модификаторов элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;, &#39;state&#39;, &#39;current&#39;, true);\n</code></pre>\n<p>При необходимости, инстансы найденных элементов инициализируются.</p>\n<p>Строгий поиск подразумевает фильтрацию элементов вложенных блоков с таким же именем, как у текущего блока:</p>\n<pre><code class=\"lang-javascript\">{\n    block: &#39;menu&#39;,\n    content: [\n        {\n            elem: &#39;item&#39; // (1)\n        },\n        {\n            block: &#39;menu&#39;,\n            content: {\n                elem: &#39;item&#39; // (2)\n            }\n        }\n    ]\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.findElemInstances(&#39;item&#39;);         // найдет инстансы (1) и (2)\nthis.findElemInstances(&#39;item&#39;, true);   // найдет только инстанс (1)\n</code></pre>\n<p>По аналогии с хелпером <code>elem</code>, кэширующим результаты своей работы, для минимизации количества операций с DOM рекомендуется использовать кэширующий поиск BEM-инстансов элементов:</p>\n<pre><code class=\"lang-javascript\">// кэширующий поиск всех вложенных элементов &#39;item&#39;\nthis.elemInstances(&#39;item&#39;);\n\n// кэширующий поиск всех вложенных модификаторов элемента &#39;item&#39;\nthis.elemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;);\n</code></pre>\n<p>Также с помощью этого хелпера можно вернуть инстансы элементов, расположенных на DOM-нодах указанной jQuery-коллекции:</p>\n<pre><code class=\"lang-javascript\">this.elemInstances(domElem);\n</code></pre>\n<p>Для поиска одного (первого) BEM-инстанса элемента есть дополнительные формы этих хелперов с аналогичным API:</p>\n<pre><code class=\"lang-javascript\">// поиск одного вложенного элемента &#39;item&#39;\nthis.findElemInstance(&#39;item&#39;);\n\n// кэширующий поиск одного вложенного элемента &#39;item&#39;\nthis.elemInstance(&#39;item&#39;);\n\n// вернуть инстанс элемента, расположенного на первой DOM-ноде указанной jQuery-коллекции\nthis.elemInstance(domElem);\n</code></pre>\n<p>Если необходимо вернуть BEM-инстанс элемента, на DOM-ноде которого подмешаны другие элементы того же блока:</p>\n<pre><code class=\"lang-javascript\">this.elemInstance(this.elemify(domElem, &#39;item&#39;));\n</code></pre>\n<h3 id=\"Поиск-снаружи-контекста\"><a href=\"#Поиск-снаружи-контекста\" class=\"anchor\"></a>Поиск снаружи контекста</h3>\n<p>Существует хелпер для поиска элемента снаружи указанного контекста:</p>\n<pre><code class=\"lang-javascript\">{\n    block: &#39;menu&#39;,\n    content: {\n        elem: &#39;item&#39;,\n        content: {\n            elem: &#39;link&#39;\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.closestElem(this.elem(&#39;link&#39;), &#39;item&#39;);\n</code></pre>\n<p>При поиске от имени BEM-инстанса элемента можно не указывать контекст поиска, тогда поиск будет производиться относительно DOM-ноды этого элемента:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__link&#39;\nthis.closestElem(&#39;item&#39;);\n</code></pre>\n<p>По аналогии с хелперами <code>elem</code> и <code>findElem</code>, хелпер <code>closestElem</code> возвращает jQuery-коллекцию. Для доступа к BEM-инстансам элементов снаружи контекста используются хелперы <code>closestElemInstance</code> и <code>closestElemInstances</code>:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.closestElemInstance(this.elem(&#39;link&#39;), &#39;item&#39;);\nthis.closestElemInstances(this.elem(&#39;link&#39;), &#39;item&#39;);\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__link&#39;\nthis.closestElemInstance(&#39;item&#39;);\n</code></pre>\n<h3 id=\"Доступ-к-родительскому-блоку\"><a href=\"#Доступ-к-родительскому-блоку\" class=\"anchor\"></a>Доступ к родительскому блоку</h3>\n<p>По аналогии с методом <code>elem</code> для получения элемента блока существует метод <code>block</code> для получения блока элемента.</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.block() // эквивалентно this.findBlockOutside(&#39;menu&#39;) с кэшированием результата поиска\n</code></pre>\n<h3 id=\"Поиск-элементов-и-блоков\"><a href=\"#Поиск-элементов-и-блоков\" class=\"anchor\"></a>Поиск элементов и блоков</h3>\n<p>Элемент ищет только вложенные в него элементы:</p>\n<pre><code class=\"lang-javascript\">{\n    block: &#39;menu&#39;,\n    content: [\n        {\n            elem: &#39;item&#39;,\n            content: {\n                elem: &#39;link&#39; // (1)\n            }\n        },\n        {\n            elem: &#39;link&#39; // (2)\n        }\n    ]\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.findElem(&#39;link&#39;);  // будет найден только элемент (1).\n</code></pre>\n<p>Если нужно найти все элементы <code>&#39;link&#39;</code>, поиск нужно производить от имени блока-родителя:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.block().findElem(&#39;link&#39;);    // будут найдены элементы (1) и (2).\n</code></pre>\n<p>Все это справедливо также для хелпера <code>elem</code>, хелперов поиска блоков (<code>findBlockInside</code> и др.) и описанных выше хелперов для поиска BEM-инстансов элементов.</p>\n<h3 id=\"Реакция-на-установку-модификаторов\"><a href=\"#Реакция-на-установку-модификаторов\" class=\"anchor\"></a>Реакция на установку модификаторов</h3>\n<p>Блок делегирует установку модификаторов тем элементам, у которых есть свои BEM-декларации.\nПоэтому обработчики <code>onSetMod</code> элемента выполнятся, если родительский блок установит этому элементу соответствующие модификаторы:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nonSetMod: {\n    &#39;state&#39;: {\n        &#39;current&#39;: function() {\n            // код обработчика\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.setMod(this.elem(&#39;item&#39;), &#39;state&#39;, &#39;current&#39;); // выполнится задекларированный выше обработчик\n</code></pre>\n<p>Обработчики <code>onElemSetMod</code> блока выполнятся, если инстанс элемента сам установит себе соответствующие модификаторы:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nonElemSetMod: {\n    &#39;item&#39;: {\n        &#39;state&#39;: {\n            &#39;current&#39;: function() {\n                // код обработчика\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.setMod(&#39;state&#39;, &#39;current&#39;); // выполнится задекларированный выше обработчик\n</code></pre>\n<p>Обработчики <code>onElemSetMod</code> в контексте инстанса элемента не используются.</p>\n<h3 id=\"Отложенная-инициализация-и-live-события\"><a href=\"#Отложенная-инициализация-и-live-события\" class=\"anchor\"></a>Отложенная инициализация и live-события</h3>\n<p>Рекомендуется по возможности всегда использовать отложенную инициализацию BEM-инстансов элементов. Они, как и обычные блоки, поддерживают все хелперы для работы с live-событиями. Кроме того, хелпер <code>liveInitOnBlockEvent</code> имеет дополнительную форму для инициализации по событию родительского блока - для этого просто опускается второй параметр (имя блока):</p>\n<pre><code class=\"lang-javascript\">this.liveInitOnBlockEvent(&#39;switch&#39;, function() { /* обработчик */ });\n</code></pre>\n"},"en":{"name":"i-bem","examples":[],"description":""}}