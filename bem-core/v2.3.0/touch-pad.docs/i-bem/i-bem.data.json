{"ru":{"name":"i-bem","examples":[{"content":[]}],"description":[{"content":"<div class=\"shmakowiki\"><p>Блок <tt>i-bem</tt> — это блок-хелпер, позволяющий создавать другие блоки. Блок реализован в технологиях <tt>BEMHTML</tt> и <tt>JS</tt>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p><h2 id=\"jsrealizaciyablokaibem\">js-реализация блока i-bem</h2><p>Реализация блока <tt>i-bem</tt> в <tt>JS</tt> обеспечивает хелперы для представления блока в виде <tt>JS</tt> объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <tt>JS</tt> в терминах <tt>BEM</tt>. То есть <tt>JS</tt> оперирует более высоким уровнем абстракции, чем <tt>DOM</tt> представление.</p><p>Для того, чтобы js-представление блока использовало ядро <tt>i-bem</tt>, оно должно быть написано с соблюдением специальных правил.</p><h4 id=\"Chtoopisanonaetojstranice\">Что описано на этой странице?</h4><ul><li>Какие бывают блоки<ul><li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li><li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li></ul></li><li>Принципы и особенности подхода<ul><li><a href=\"#decl\">Декларативный принцип</a></li><li><a href=\"#block.getting\">Доступ к другим блокам</a></li><li><a href=\"#mods\">Работа с модификаторами</a></li><li><a href=\"#customization\">Кастомизация блоков</a></li></ul></li><li><a href=\"#creation\">Создание собственного bem-js блока</a></li><li>Подробнее о понятиях<ul><li><a href=\"#init\">Инициализация</a></li><li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация<span>)</span></a></li><li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li><li><a href=\"#events\">Работа с событиями</a></li></ul></li></ul><pre><code class=\"xml\">&lt;a name=&quot;dom.blocks&quot;&gt;&lt;/a&gt;</code></pre><h4 id=\"BlokisDOMpredstavleniem\">Блоки с DOM-представлением</h4><p>Блокам, реализованным на <tt>bem-js</tt>, могут соответствовать ноды в <tt>HTML</tt>. В этом случае говорится о том, что блоки имеют <tt>DOM</tt> представление.<br/> В <tt>HTML</tt> блоки на <tt>bem-js</tt> отличаются дополнительным <tt>CSS</tt> классом <tt>i-bem</tt> и специальным форматом записи параметров блока в <tt>onclick</tt>:</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return { &apos;b-my-block&apos; : { name : &apos;b-my-block&apos;}}&quot;&gt;\n...\n&lt;/div&gt;</code></pre><p>Ниже подробно рассказано о <a href=\"#onclick.params\">формате параметров в onclick</a>.</p><pre><code class=\"xml\">&lt;a name=&quot;abstract.blocks&quot;&gt;&lt;/a&gt;</code></pre><h4 id=\"BlokibezDOMpredstavleniya\">Блоки без DOM-представления</h4><p>Технология <tt>bem-js</tt> позволяет также создавать блоки, не имеющие <tt>DOM</tt> представления. Такие блоки тем не менее существуют в <tt>JS</tt> в виде объектов, манипулировать ими можно так же, как и блоками с <tt>DOM</tt> представлением.</p><p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p><p>Блоки, реализованные на <tt>bem-js</tt>,  после инициализации представлены в <tt>js</tt> объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.<br/> Технология <tt>bem-js</tt> использует предметную область <a href=\"http://wiki.yandex-team.ru/lento4ka/bem\">концепции <tt>BEM</tt></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.<br/> Представление блока в <tt>js</tt> не обязано иметь взаимное соответствие с одной <tt>DOM</tt>-нодой. Можно разместить несколько блоков на одной <tt>DOM</tt>-ноде (это называется <tt>mix</tt>), а также реализовать один блок на нескольких <tt>DOM</tt>-нодах.<br/> Далее блок, использующий технологию <tt>bem-js</tt>, будет называться <tt>блок, реализованный на bem-js</tt>, или <tt>bem-js-блок</tt>. Примером такого блока в библиотеке может служить <tt>b-link</tt>.</p><pre><code class=\"xml\">&lt;a name=&quot;decl&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Deklarativnyjprincip\">Декларативный принцип</h2><p>Важной особенностью технологии <tt>bem-js</tt> является декларативный принцип. Подобно работе декларативных языков программирования, <tt>js</tt>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p><h3 id=\"Deklaraciyabloka\">Декларация блока</h3><p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-link&apos;, {\n...</code></pre><pre><code class=\"js\">BEM.DOM.decl({ name : &apos;b-domik&apos;, modName : &apos;type&apos;, modVal : &apos;popup&apos; }, {\n...</code></pre><p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p><pre><code class=\"xml\">&lt;a name=&quot;mods.reaction&quot;&gt;&lt;/a&gt;</code></pre><h3 id=\"Reakciyanaizmeneniemodifikatorov\">Реакция на изменение модификаторов</h3><p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <tt>bem-js</tt> есть специальные методы для установки и снятия модификаторов.</p><p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.<br/> Например, блок <tt>b-dropdowna</tt> при установке модификатора <tt>disabled</tt> прячет показанный попап:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-dropdowna&apos;, {\n\n    onSetMod : {\n\n        &apos;disabled&apos; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &apos;yes&apos; &amp;&amp; this.getPopup().hide();\n\n        }\n\n    },\n...</code></pre><p>Подробно <a href=\"#mods.callbacks\">о декларации обработки модификаторов</a> рассказано в пункте про создание собственного блока.</p><pre><code class=\"xml\">&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Dostupkdrugimblokam\">Доступ к другим блокам</h2><p>Может возникнуть необходимость управлять другим блоком. Для любых манипуляций с блоком необходимо получить доступ к <tt>js</tt>-объекту этого блока и вызывать его методы.</p><pre><code class=\"xml\">&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;</code></pre><h3 id=\"Dostupkbemjsblokuizdrugogobemjsbloka\">Доступ к bem-js-блоку из другого bem-js-блока.</h3><p>В случае <a href=\"#creation\">реализации собственного кастомного блока на технологии <tt>bem-js</tt></a>, блоку соответствует <tt>js</tt>-объект. Он наследует общие для всех блоков методы, позволяющие работать с <tt>DOM</tt> документа в терминах <tt>BEM</tt>. Среди этих методов есть методы поиска других блоков относительно текущего (<tt>findBlock*</tt>-методы). Они возвращают <tt>js</tt>-объект искомого блока, что позволяет затем напрямую вызывать его методы.<br/> <b>Не используйте <tt>jQuery</tt>-селекторы для поиска блоков и элементов.</b></p><p>В этом примере вызывается метод <tt>val()</tt> у блока <tt>b-form-checkbox</tt>:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-checkbox-example&apos;, {\n\n    onSetMod: {\n        &apos;js&apos;: function() {\n            var checkbox = this.findBlockInside({ blockName : &apos;b-form-checkbox&apos;, modName : &apos;type&apos;, modVal : &apos;my-checkbox&apos;});\n            this.domElem.append(&apos;Значение checkbox: &apos; + checkbox.val());\n        }\n    }\n}\n);</code></pre><h3 id=\"Dostupkbemjsblokuneizbemjsbloka\">Доступ к bem-js-блоку не из bem-js-блока</h3><p>В случае работы не из <tt>bem-js-блока</tt>, методы <tt>findBlock*</tt> недоступны. <tt>js</tt>-объект блока можно получить, используя метод <tt>.bem()</tt> <tt>jQuery</tt> коллекции:</p><pre><code class=\"js\">$(уникальный селектор).bem(&apos;b-link&apos;);</code></pre><p>Этот способ <b>не рекомендован</b>. Лучшим вариантом работы с блоками, реализованными на <tt>i-bem</tt>, является создание собственного компонента на <tt>i-bem</tt>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p><pre><code class=\"xml\">&lt;a name=&quot;mods&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Rabotasmodifikatoramibloka\">Работа с модификаторами блока</h2><p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p><p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <tt>b-form-checkbox</tt>, ему нужно установить модификатор <tt>checked</tt> в значение <tt>yes</tt>.<br/> На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p><p>Модификаторы нельзя устанавливать, напрямую меняя <tt>CSS</tt> класс на соответствующей <tt>DOM</tt>-ноде. Для корректной работы <tt>js</tt> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <tt>setMod()</tt>. Также существуют методы <tt>hasMod()</tt>, <tt>getMod</tt>/<tt>getMods()</tt>, <tt>toggleMod()</tt> и <tt>delMod()</tt>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.wiki\">референсе по BEM</a>.</p><pre><code class=\"xml\">&lt;a name=&quot;customization&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Izmeneniepovedeniyasushhestvuyushhixblokov\">Изменение поведения существующих блоков</h2><p>Используя <tt>bem-js</tt>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков на <tt>CSS</tt> или <tt>BEMHTML</tt>.</p><h3 id=\"Pereopredeleniepovedeniya\">Переопределение поведения</h3><p>Например, на сервисе существует необходимость модифицировать все блоки <tt>b-dropdowna</tt> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <tt>blocks/b-dropdowna/b-dropdowna.js</tt>, кастомизирующий поведение блока из библиотеки:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-dropdowna&apos;, {\n\n    onSetMod : {\n\n        &apos;js&apos; : function() {\n\n            this._getSwitcher().on(&apos;click&apos;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&apos;switcher&apos;));\n    }\n});</code></pre><h3 id=\"Rasshireniepovedeniya\">Расширение поведения</h3><p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <tt>bem-js</tt> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <tt>this._<span>_</span>base.apply()</tt>, передавая в качестве аргументов <tt>this</tt> и <tt>arguments</tt>. Вызов такого метода аналогичен использованию <tt>&lt;xsl:apply-imports/&gt;</tt>.</p><p>Например, можно доопределить реакцию на клик всех блоков <tt>b-link</tt> на проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p><p>Содержание файла <tt>blocks/b-link/_pseudo/b-link_pseudo_yes.js</tt></p><pre><code class=\"js\">BEM.DOM.decl({&apos;name&apos;: &apos;b-link&apos;, &apos;modName&apos;: &apos;pseudo&apos;, &apos;modVal&apos;: &apos;yes&apos;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&apos;status&apos;, &apos;clicked&apos;);\n    }\n});</code></pre><p>Содержание файла <tt>blocks/b-link/_status/b-link_status_clicked.css</tt></p><pre><code class=\"xml\">.b-link_status_clicked\n{\n    color: red;\n}</code></pre><h3 id=\"Kastomizaciyasispolyzovaniemmodifikatorov\">Кастомизация с использованием модификаторов</h3><p>Предыдущие примеры кастомизации изменяют поведение <i>всех</i> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <tt>BEM</tt>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p><p>Возвращаясь к примеру про псевдоссылку, приобретающую красный цвет после первого клика, сделаем модификацию <tt>reaction_odd</tt>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету .</p><p>Содержание файла <tt>blocks/b-link/_reaction/b-link_reaction_odd.js</tt>:</p><pre><code class=\"js\">BEM.DOM.decl({name : &apos;b-link&apos;, modName : &apos;reaction&apos;, &apos;modVal&apos; : &apos;odd&apos;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&apos;status&apos;, &apos;clicked&apos;);\n    }\n});</code></pre><pre><code class=\"xml\">&lt;a name=&quot;creation&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Sozdaniejskomponentadlyasobstvennogoblokailisobstvennojmodifikacii\">Создание js-компонента для собственного блока или собственной модификации</h2><p>Рекомендованным способом работы с <tt>bem-js-блоками</tt> является создание собственных <tt>bem-js-блоков</tt> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <tt>bem-js-блоки</tt> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.<br/> <tt>js-код</tt> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <tt>.js</tt>. Если <tt>js-реализация</tt> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <tt>js-файле</tt>, соответствующем данному модификатору.</p><pre><code class=\"xml\">&lt;a name=&quot;dom.decl&quot;&gt;&lt;/a&gt;</code></pre><h3 id=\"Deklaraciyabloka\">Декларация блока</h3><p>Создание <tt>js-компонента</tt> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <tt>DOM</tt>-представление, второй — для блоков, не имеющих <tt>DOM</tt> представления (например <tt>i-request</tt>, <tt>i-update-session</tt>).</p><p>В первом случае блоки декларируются с помощью <tt>BEM.DOM.decl</tt>, во втором — с помощью <tt>BEM.decl</tt>.</p><p>Хелпер декларации блока принимает 3 параметра:</p><ol><li>Матчащий параметр<br/>\n    Первым параметром может быть либо строка с именем\nблока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому\nтипу блоков применять компонент.</li><li>Методы и свойства экземляра блока<br/>\n    Методы и свойства, предметной областью которых является конкретный инстанс блока\n    на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>,\n    так и <a href=\"#methods\">кастомные методы блока</a>.</li><li>Статические методы и свойства<br/>\n    Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li></ol><p>Например:</p><pre><code class=\"js\">BEM.DOM.decl(\n    &apos;b-link&apos;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });</code></pre><p>и</p><pre><code class=\"js\">BEM.decl(&apos;i-request&apos;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});</code></pre><p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p><pre><code class=\"js\">BEM.decl({ name : &apos;b-dataprovider&apos;, baseBlock : &apos;i-request&apos; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});</code></pre><p>Тут указано, что блок <tt>b-dataprovider</tt> наследуется от блока <tt>i-request</tt> и переопределяет его метод <tt>get</tt>.</p><p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p><pre><code class=\"js\">BEM.decl({ name : &apos;b-popup&apos;, modName : &apos;type&apos;, modVal : &apos;inplace&apos; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});</code></pre><p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <tt>b-popup</tt>, которые в данный момент имеют модификатор <tt>type</tt>, установленный в <tt>inplace</tt>.</p><pre><code class=\"xml\">&lt;a name=&quot;mods.callbacks&quot;&gt;&lt;/a&gt;</code></pre><h3 id=\"Reakciyanaizmeneniemodifikatorov\">Реакция на изменение модификаторов</h3><p>Согласно концепции <tt>BEM</tt> состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.<br/> Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p><p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <tt>onSetMod</tt> и <tt>onElemSetMod</tt>, где описываются <tt>callback</tt>-функции, вызываемые при установке модификаторов для блока или его элементов.</p><p>Описание <tt>callback</tt>-функций для <tt>onSetMod</tt> представляет собой хеш вида:</p><pre><code class=\"js\">{\n    &apos;модификатор1&apos; : {\n\n        &apos;значение1-модификатора1&apos; : function() { ... }, // функция, которая будет вызвана при установке модификатора &apos;модификатор1&apos; в значение &apos;значение1&apos;\n\n        ...\n\n        &apos;значениеN-модификатора1&apos; : function() { ... }, // функция, которая будет вызвана при установке модификатора &apos;модификатор1&apos; в значение &apos;значениеN&apos;\n\n        &apos;*&apos; : function() { ... } // функция, которая будет вызвана при установке модификатора &apos;модификатор1&apos; в любое из значений\n\n    },\n\n    &apos;модификатор2&apos; : function() {}, // функция, которая будет вызвана при установке модификатора &apos;модификатор2&apos; в любое из значений\n\n    ...\n\n    &apos;модификаторN&apos; : {\n\n        &apos;значение1-модификатораN&apos; : function() { ... },\n\n        ...\n\n        &apos;значениеN-модификатораN&apos; : function() { ... }\n\n    }\n\n}</code></pre><p>Описание <tt>callback</tt>-функций для <tt>onElemSetMod</tt> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p><pre><code class=\"js\">{\n\n    &apos;элемент1&apos; : {\n\n        &apos;модификатор1&apos; : {\n\n            &apos;значение1-модификатора1&apos; : function() { ... }, // функция, которая будет вызвана при установке модификатора &apos;модификатор1&apos; в значение &apos;значение1&apos; для элемента &apos;элемент1&apos;\n\n            ...\n\n            &apos;значениеN-модификатора1&apos; : function() { ... }, // функция, которая будет вызвана при установке модификатора &apos;модификатор1&apos; в значение &apos;значениеN&apos; для элемента &apos;элемент1&apos;\n\n            &apos;*&apos; : function() { ... } // функция, которая будет вызвана при установке модификатора &apos;модификатор1&apos; в любое из значений  для элемента &apos;элемент1&apos;\n\n        }\n\n    },\n\n    ...\n\n    &apos;элементN&apos; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &apos;элементN&apos;\n\n}</code></pre><p>Параметры <tt>callback</tt>-функций:</p><ul><li><tt>{jQuery} [elem]</tt> — элемент блока (если установка модификатора была для элемента)</li><li><tt>{String} modName</tt> — имя модификатора</li><li><tt>{String} modVal</tt> — устанавливаемое значение модификатора</li><li><tt>{String} curModVal</tt> — текущее значение модификатора</li></ul><p>Порядок вызовов <tt>callback</tt>-функций при установке модификатора <tt>modVal</tt> в значение <tt>modName</tt>:</p><ul><li>вызывается <tt>callback</tt>-функция на установку любого модификатора в любое значение (если она существует)</li><li>вызывается <tt>callback</tt>-функция на установку модификатора <tt>modVal</tt> в любое значение (если она существует)</li><li>вызывается <tt>callback</tt>-функция на установку модификатора <tt>modVal</tt> в значение <tt>modName</tt> (если она существует)</li></ul><p>Если хоть один из вызовов этих функций вернет <tt>false</tt>, то установки модификатора не произойдет.</p><p>Например:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-menu&apos;, {\n\n    onElemSetMod : {\n\n        &apos;trigger&apos; : {\n\n            &apos;state&apos; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &apos;trigger&apos; модификатора с именем &apos;state&apos; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&apos;layout-cell&apos;)), &apos;item-content&apos;).eq(0),\n                        &apos;visibility&apos;,\n                        &apos;visible&apos;,\n                        modVal == &apos;opened&apos;)\n                    .trigger(&apos;trigger&apos;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &apos;state&apos;, &apos;opened&apos;); // устанавливаем или снимаем значение &apos;opened&apos; у модификатор &apos;state&apos; для элемента &apos;trigger&apos;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&apos;trigger&apos;, &apos;click&apos;, function(e) { // слушаем live-клик на элементах &apos;trigger&apos;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});</code></pre><p><tt>В данном примере при вызове </tt>toggleMod<tt> внутри </tt>onTriggerClick<tt> будет вызвана соответствущая ей </tt>callback<tt>-функция из </tt>onElemSetMod<tt>.</tt></p><p><tt>Callback</tt> функции, реагирующие на изменение модификатора, выполняются до установки модификатора. Если существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <tt>.afterCurrentEvent()</tt>.</p><p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-square2&apos;, {\n\n    onSetMod : {\n\n        &apos;js&apos; : function() {\n\n            var square = this;\n\n            this.bindTo(&apos;click&apos;, function(){\n                square.setMod(&apos;size&apos;, &apos;big&apos;);\n            });\n\n        },\n        &apos;size&apos; : function() {\n            this.domElem.append(&apos;размер1: &apos;, this.domElem.width() + &apos;&lt;br/&gt;&apos;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&apos;размер2: &apos;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});</code></pre><h4 id=\"Nachalorabotysblokommodifikatorjs\">Начало работы с блоком (модификатор <tt>js</tt>)</h4><p>Блок начинает свою работу с действий, описанных в <tt>callback</tt>-функции на установку его модификатора <tt>js</tt> в значение <tt>inited</tt>:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-form-input&apos;, {\n\n    onSetMod : {\n\n        &apos;js&apos; : {\n\n            &apos;inited&apos; : function() {\n\n                this\n                    .bindTo(this.elem(&apos;input&apos;), {\n                        &apos;focus&apos; : this.onFocus,\n                        &apos;blur&apos;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});</code></pre><p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p><p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <tt>DOM</tt> представление, так и блокам без него. Так что, у блоков без <tt>DOM</tt> представления первый исполняемый метод также задаётся как <tt>callback</tt> модификатора <tt>js_inited</tt>.</p><p>В коде блоков можно встретить <tt>callback</tt> функцию не на значение <tt>inited</tt> модификатора <tt>js</tt>, а на установку модификатора <tt>js</tt> в любое значение:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-form-input&apos;, {\n\n    onSetMod : {\n\n    &apos;js&apos; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});</code></pre><p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <tt>js</tt>, а в момент инциализации приобретает значение <tt>inited</tt>. Другие значения модификатора сейчас не предусмотрены.</p><pre><code class=\"xml\">&lt;a name=&quot;methods&quot;&gt;&lt;/a&gt;</code></pre><h3 id=\"Metodybloka\">Методы блока</h3><p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p><p>Например, так выглядит метод <tt>.toggle()</tt> блока <a href=\"/blocks/b-form-checkbox/b-form/checkbox.wiki\">b-form-checkbox</a>:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-form-checkbox&apos;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&apos;checked&apos;, &apos;yes&apos;, &apos;&apos;);\n    }\n    ...\n});</code></pre><h4 id=\"Pereopredelenieidoopredeleniemetodovbloka\">Переопределение и доопределение методов блока</h4><p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p><pre><code class=\"xml\">&lt;a name=&quot;static.methods&quot;&gt;&lt;/a&gt;</code></pre><h3 id=\"Staticheskiemetodybloka\">Статические методы блока</h3><p>Третий параметр, передаваемый в функцию декларации блока, – это хеш статических методов блока.</p><p>Примером блока, использующего статические методы, может служить <a href=\"/blocks/b-flash/b-flash.wiki\">/blocks/b-flash/b-flash.wiki</a>.</p><p>Для каждого блока может быть определен статический метод <tt>live</tt>, позвляющий реализовать <a href=\"#liveinit\">инициализацию по требованию (liveinit<span>)</span></a>.</p><pre><code class=\"xml\">&lt;a name=&quot;init&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Inicializaciya\">Инициализация</h2><p>Для того, чтобы у блока появился <tt>js-объект</tt>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <tt>BEM.DOM.init()</tt> на фрагменте <tt>DOM</tt> дерева. Если элемент <tt>i-bem_<span>_</span>dom</tt> задекларирован с модификатором <tt>init_auto</tt> (подключается файл <tt>i-bem_<span>_</span>dom_init_auto.js</tt>), то инициализация блоков происходит на всём документе по событию domReady. Также функцию <tt>BEM.DOM.init</tt> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с js-представлением.</p><h3 id=\"InicializaciyablokovsDOMpredstavleniem\">Инициализация блоков с DOM-представлением</h3><p>Для инициализации блоков, представленных в <tt>DOM</tt>, на фрагменте дерева ищутся все блоки, помеченные классом <tt>i-bem</tt>, у них считываются параметры из атрибута <tt>onclick</tt>, и создаётся <tt>js-объект</tt> такого блока.</p><pre><code class=\"xml\">&lt;a name=&quot;onclick.params&quot;&gt;&lt;/a&gt;</code></pre><h4 id=\"Formatparametrovblokavonclick\">Формат параметров блока в onclick</h4><p>Параметры для блока записываются в виде возвращаемого атрибутом <tt>onclick</tt> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.<br/> Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <tt>HTML</tt> одной и той же <tt>DOM-нодой</tt>.</p><p>Вот как выглядит <tt>DOM-нода</tt> произвольного блока, реализованного на <tt>bem-js</tt>:</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {\n    &apos;b-my-block&apos; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;</code></pre><p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <tt>name</tt>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {\n    &apos;b-my-block&apos; : {\n        &apos;points&apos; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &apos;title&apos; : &apos;Какое-то название&apos;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;</code></pre><p>Для нескольких блоков на одной <tt>DOM-ноде</tt> <tt>HTML</tt> представление будет аналогично следующему:</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; onclick=&quot;return {\n    &apos;b-my-block&apos; : {\n        &apos;title&apos; : &apos;Какое-то название&apos;, // Этот блок имеет опцинальный параметр title\n    },\n    &apos;b-my-second-block&apos; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;</code></pre><h4 id=\"DOMpredstavlenieinicializirovannogobloka\">DOM-представление инициализированного блока</h4><p>После инициализации <tt>DOM</tt> представление блока изменяется: у блока появляется дополнительный модификатор <tt>js_inited</tt>.<br/> Если <tt>DOM-ноде</tt> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p><p>DOM-представление блока после инициализации:</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; onclick=&quot;return {\n    &apos;b-my-block&apos; : {\n        &apos;name&apos; : &apos;b-my-block&apos;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;</code></pre><p><tt>DOM</tt> представление двух блоков после инициализации:</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {\n    &apos;b-my-block&apos; : {\n        &apos;name&apos; : &apos;b-my-block&apos;,\n    },\n    &apos;b-my-second-block&apos; : {\n        &apos;name&apos; : &apos;b-my-second-block&apos;\n    }\n}&quot;&gt;</code></pre><p><tt>DOM</tt> представление двух блоков, но инициализован только один из них:</p><pre><code class=\"xml\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {\n    &apos;b-my-block&apos; : {\n        &apos;name&apos; : &apos;b-my-block&apos;,\n    },\n    &apos;b-my-second-block&apos; : {\n        &apos;name&apos; : &apos;b-my-second-block&apos;\n    }\n}&quot;&gt;</code></pre><h3 id=\"InicializaciyablokovbezDOMpredstavleniya\">Инициализация блоков без DOM-представления</h3><p>В том случае, если у блока нет <tt>DOM</tt> представления, в процессе инициализации просто возникает <tt>js-объект</tt>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p><pre><code class=\"xml\">&lt;a name=&quot;liveinit&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"InicializaciyapotrebovaniyuliveInit\">Инициализация по требованию (liveInit)</h2><p>Многим блокам (например, <tt>b-link</tt>, <tt>b-dropdown</tt>, <tt>b-smart-help</tt>) нет необходимости делать сразу же полную инициализацию. Инициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока. Рассмотрим на примере блока <tt>b-link</tt>:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-link&apos;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&apos;click&apos;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&apos;click&apos;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});</code></pre><p>В статических свойствах блока предусмотрено специальное свойство <tt>live</tt> (<tt>Function</tt>|<tt>Boolean</tt>), отвечающее за инициализацию по требованию и за подписку на <tt>live</tt> события на <tt>DOM</tt> элементах внутри такого блока.</p><p>Если <tt>live</tt> определено как <tt>Function</tt>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p><p>Существует несколько хелперов для <tt>live</tt> событий:</p><ul><li><tt>liveInitOnEvent</tt> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li><li><tt>liveBindTo</tt> — подписка на события на блоке или его внутреннем элементе</li></ul><p>Оба этих хелпера инициализируют блок при возникновении первого такого события. Различие же заключается в том, что <tt>callback</tt> функция в <tt>liveInitOnEvent</tt> вызывается только один раз после инициализации блока, а в <tt>liveBindTo</tt> она будет вызываться при каждом событии. Контекстом такой <tt>callback</tt> функции является тот блок, в котором произошло событие.</p><p>В вышеприведенном примере блок <tt>b-link</tt> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p><p>Если же <tt>live</tt> определено как <tt>Boolean</tt> и установлено в <tt>true</tt>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <tt>findBlockInside</tt>/<tt>findBlockOutside</tt>.</p><p>&lt;a name=&quot;finding&quot;&gt;&lt;/a&gt;</p><h2 id=\"Metodydostupakblokamielementam\">Методы доступа к блокам и элементам</h2><p>Работая с блоками, реализованными на <tt>bem-js</tt>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <tt>jQuery</tt> коллекцию (в случае поиска элементов).</p><h3 id=\"Metodypoiskablokov\">Методы поиска блоков</h3><p>Поиск блоков осуществляется относительно текущего блока при помощи методов <tt>findBlock*</tt>.</p><p>Реализуем блок <tt>b-my-block</tt>, который находит первый из блоков <tt>b-form-checkbox</tt> внутри себя и вызывает у него метод <tt>toggle()</tt> для переключения чекбокса.</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-my-block&apos;, {\n    onSetMod : {\n        &apos;js&apos; : function() {\n            var checkbox = this.findBlockInside(&apos;b-form-checkbox&apos;);\n            checkbox.toggle();\n        }\n    }\n});</code></pre><p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p><ul><li><tt>findBlockInside/findBlocksInside</tt> — поиск блока/блоков внутри <tt>DOM</tt> элементов текущего блока или его элементов</li><li><tt>findBlockOn/findBlocksOn</tt> — поиск блока/блоков на <tt>DOM</tt> элементах текущего блока или его элементов</li><li><tt>findBlockOutside/findBlocksOutside</tt> — поиск блока/блоков снаружи <tt>DOM</tt> элементов текущего блока или его элементов</li></ul><p>Список методов поиска блоков и их сигнатуры можно посмотреть в <a href=\"/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki\">референсе по BEM.DOM</a>.</p><p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.wiki\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.wiki\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.wiki\">b-dropdowna</a>.</p><h3 id=\"Metodydostupakelementam\">Методы доступа к элементам</h3><p>Для поиска элементов внутри блока используется метод <tt>elem</tt>. Результат этого метода кэшируется.</p><p>Например:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-form-input&apos;, {\n\n    doSomething : function() {\n\n        this.elem(&apos;hint&apos;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});</code></pre><p>Можно искать элементы внутри блока с учетом модификатора:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-menu&apos;, {\n\n    doSomething : function() {\n\n        this.elem(&apos;item&apos;, &apos;state&apos;, &apos;current&apos;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});</code></pre><p>Некэширующий метод поиска элементов называется <tt>findElem()</tt>.</p><p>Полный список методов для поиска элементов и их сигнатуры можно найти в <a href=\"/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki\">референсе по BEM.DOM</a>.</p><pre><code class=\"xml\">&lt;a name=&quot;events&quot;&gt;&lt;/a&gt;</code></pre><h2 id=\"Rabotassobytiyami\">Работа с событиями</h2><h3 id=\"Sobytiyanablokax\">События на блоках</h3><p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <tt>DOM</tt>) событий:</p><ul><li><tt>on(e, [data], fn, [ctx])</tt> — подписка на событие <tt>e</tt></li><li><tt>onFirst(e, [data], fn, [ctx])</tt> — подписка только на первое событие <tt>e</tt></li><li><tt>un([e], [fn], [ctx])</tt> — отписка от конкретного события <tt>e</tt> или всех событий</li><li><tt>trigger(e, [data])</tt> — нотификация о событии  <tt>e</tt></li></ul><h3 id=\"livesobytiyanablokax\">live-события на блоках</h3><p>В <tt>bem-js</tt> есть события, реализованные по паттерну делегированных событий, они называются <tt>live</tt> события.</p><p>Следующий пример демонстрирует работу с live-событием <tt>click</tt> для блоков <tt>b-link</tt>, содержащихся в определённой <tt>DOM-ноде</tt>. В данном случае контейнер и блок совпадают:</p><pre><code class=\"js\">BEM.DOM.decl(&apos;b-link-example&apos;, {\n\n    onSetMod: {\n        &apos;js&apos;: function() {\n            var link = this.findBlockInside(&apos;b-link&apos;);\n            BEM.blocks[&apos;b-link&apos;]\n                .liveCtxBind(link.domElem,\n                            &apos;click&apos;,\n                            function(){\n                                link.domElem.text(&apos;Кликнутая ссылка&apos;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&apos;b-link&apos;);\n    }\n}\n);</code></pre><p>Метод <tt>.liveCtxBind()</tt> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <tt>DOM</tt> элемент. <b>Это не DOM-события</b><br/> Использование <tt>live</tt> событий позволяет избежать лишнего поиска блоков в <tt>DOM</tt> дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p><p>Кроме возможности привязки к <tt>live</tt> событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.<br/></p></div>\n<div class=\"shmakowiki\"><p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <tt>i-jquery</tt>.</p></div>\n<p>Подключение данного модификатора позволяет работать с элементами почти так же, как и с обычными блоками, т.е. любой (но не обязательно каждый) элемент может иметь свой BEM-инстанс. API инстансов элементов аналогично API блоков с некоторыми различиями, описанными ниже.</p>\n<h3 id=\"-\">Декларация</h3>\n<p>Декларация элемента</p>\n<pre><code class=\"lang-javascript\">BEMDOM.decl({ block: &#39;menu&#39;, elem: &#39;item&#39; }, { /* properties */ }, { /* static properties */ });\n</code></pre>\n<p>Декларация модификатора элемента:</p>\n<pre><code class=\"lang-javascript\">BEMDOM.decl({\n    block: &#39;menu&#39;,\n    elem: &#39;item&#39;,\n    modName: &#39;state&#39;,\n    modVal: &#39;current&#39;\n}, {\n    /* properties */\n}, {\n    /* static properties */\n});\n</code></pre>\n<p>Модификаторы элементов работают так же, как модификаторы блоков.</p>\n<h3 id=\"bem-\">BEM-инстансы элементов</h3>\n<p>Для доступа к BEM-инстансам элементов используется хелпер <code>findElemInstances</code>, API которого аналогично хелперу <code>findElem</code>:</p>\n<pre><code class=\"lang-javascript\">// поиск всех вложенных элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;);\n\n// строгий поиск всех вложенных элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;, true);\n\n// поиск всех вложенных модификаторов элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;);\n\n// строгий поиск всех вложенных модификаторов элементов &#39;item&#39;\nthis.findElemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;, true);\n\n// поиск всех элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;);\n\n// строгий поиск всех элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;, true);\n\n// поиск всех модификаторов элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;, &#39;state&#39;, &#39;current&#39;);\n\n// строгий поиск всех модификаторов элементов &#39;item&#39; внутри указанного контекста\nthis.findElemInstances(ctx, &#39;item&#39;, &#39;state&#39;, &#39;current&#39;, true);\n</code></pre>\n<p>При необходимости, инстансы найденных элементов инициализируются.</p>\n<p>Строгий поиск подразумевает фильтрацию элементов вложенных блоков с таким же именем, как у текущего блока:</p>\n<pre><code class=\"lang-javascript\">{\n    block: &#39;menu&#39;,\n    content: [\n        {\n            elem: &#39;item&#39; // (1)\n        },\n        {\n            block: &#39;menu&#39;,\n            content: {\n                elem: &#39;item&#39; // (2)\n            }\n        }\n    ]\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.findElemInstances(&#39;item&#39;);         // найдет инстансы (1) и (2)\nthis.findElemInstances(&#39;item&#39;, true);   // найдет только инстанс (1)\n</code></pre>\n<p>По аналогии с хелпером <code>elem</code>, кэширующим результаты своей работы, для минимизации количества операций с DOM рекомендуется использовать кэширующий поиск BEM-инстансов элементов:</p>\n<pre><code class=\"lang-javascript\">// кэширующий поиск всех вложенных элементов &#39;item&#39;\nthis.elemInstances(&#39;item&#39;);\n\n// кэширующий поиск всех вложенных модификаторов элемента &#39;item&#39;\nthis.elemInstances(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;);\n</code></pre>\n<p>Также с помощью этого хелпера можно вернуть инстансы элементов, расположенных на DOM-нодах указанной jQuery-коллекции:</p>\n<pre><code class=\"lang-javascript\">this.elemInstances(domElem);\n</code></pre>\n<p>Для поиска одного (первого) BEM-инстанса элемента есть дополнительные формы этих хелперов с аналогичным API:</p>\n<pre><code class=\"lang-javascript\">// поиск одного вложенного элемента &#39;item&#39;\nthis.findElemInstance(&#39;item&#39;);\n\n// кэширующий поиск одного вложенного элемента &#39;item&#39;\nthis.elemInstance(&#39;item&#39;);\n\n// вернуть инстанс элемента, расположенного на первой DOM-ноде указанной jQuery-коллекции\nthis.elemInstance(domElem);\n</code></pre>\n<p>Если необходимо вернуть BEM-инстанс элемента, на DOM-ноде которого подмешаны другие элементы того же блока:</p>\n<pre><code class=\"lang-javascript\">this.elemInstance(this.elemify(domElem, &#39;item&#39;));\n</code></pre>\n<h3 id=\"-\">Поиск снаружи контекста</h3>\n<p>Существует хелпер для поиска элемента снаружи указанного контекста:</p>\n<pre><code class=\"lang-javascript\">{\n    block: &#39;menu&#39;,\n    content: {\n        elem: &#39;item&#39;,\n        content: {\n            elem: &#39;link&#39;\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.closestElem(this.elem(&#39;link&#39;), &#39;item&#39;);\n</code></pre>\n<p>При поиске от имени BEM-инстанса элемента можно не указывать контекст поиска, тогда поиск будет производиться относительно DOM-ноды этого элемента:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__link&#39;\nthis.closestElem(&#39;item&#39;);\n</code></pre>\n<p>По аналогии с хелперами <code>elem</code> и <code>findElem</code>, хелпер <code>closestElem</code> возвращает jQuery-коллекцию. Для доступа к BEM-инстансам элементов снаружи контекста используются хелперы <code>closestElemInstance</code> и <code>closestElemInstances</code>:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.closestElemInstance(this.elem(&#39;link&#39;), &#39;item&#39;);\nthis.closestElemInstances(this.elem(&#39;link&#39;), &#39;item&#39;);\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__link&#39;\nthis.closestElemInstance(&#39;item&#39;);\n</code></pre>\n<h3 id=\"-\">Доступ к родительскому блоку</h3>\n<p>По аналогии с методом <code>elem</code> для получения элемента блока существует метод <code>block</code> для получения блока элемента.</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.block() // эквивалентно this.findBlockOutside(&#39;menu&#39;) с кэшированием результата поиска\n</code></pre>\n<h3 id=\"-\">Поиск элементов и блоков</h3>\n<p>Элемент ищет только вложенные в него элементы:</p>\n<pre><code class=\"lang-javascript\">{\n    block: &#39;menu&#39;,\n    content: [\n        {\n            elem: &#39;item&#39;,\n            content: {\n                elem: &#39;link&#39; // (1)\n            }\n        },\n        {\n            elem: &#39;link&#39; // (2)\n        }\n    ]\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.findElem(&#39;link&#39;);  // будет найден только элемент (1).\n</code></pre>\n<p>Если нужно найти все элементы <code>&#39;link&#39;</code>, поиск нужно производить от имени блока-родителя:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.block().findElem(&#39;link&#39;);    // будут найдены элементы (1) и (2).\n</code></pre>\n<p>Все это справедливо также для хелпера <code>elem</code>, хелперов поиска блоков (<code>findBlockInside</code> и др.) и описанных выше хелперов для поиска BEM-инстансов элементов.</p>\n<h3 id=\"-\">Реакция на установку модификаторов</h3>\n<p>Блок делегирует установку модификаторов тем элементам, у которых есть свои BEM-декларации.\nПоэтому обработчики <code>onSetMod</code> элемента выполнятся, если родительский блок установит этому элементу соответствующие модификаторы:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nonSetMod: {\n    &#39;state&#39;: {\n        &#39;current&#39;: function() {\n            // код обработчика\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nthis.setMod(this.elem(&#39;item&#39;), &#39;state&#39;, &#39;current&#39;); // выполнится задекларированный выше обработчик\n</code></pre>\n<p>Обработчики <code>onElemSetMod</code> блока выполнятся, если инстанс элемента сам установит себе соответствующие модификаторы:</p>\n<pre><code class=\"lang-javascript\">// this =&gt; block &#39;menu&#39;\nonElemSetMod: {\n    &#39;item&#39;: {\n        &#39;state&#39;: {\n            &#39;current&#39;: function() {\n                // код обработчика\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-javascript\">// this =&gt; element &#39;menu__item&#39;\nthis.setMod(&#39;state&#39;, &#39;current&#39;); // выполнится задекларированный выше обработчик\n</code></pre>\n<p>Обработчики <code>onElemSetMod</code> в контексте инстанса элемента не используются.</p>\n<h3 id=\"-live-\">Отложенная инициализация и live-события</h3>\n<p>Рекомендуется по возможности всегда использовать отложенную инициализацию BEM-инстансов элементов. Они, как и обычные блоки, поддерживают все хелперы для работы с live-событиями. Кроме того, хелпер <code>liveInitOnBlockEvent</code> имеет дополнительную форму для инициализации по событию родительского блока - для этого просто опускается второй параметр (имя блока):</p>\n<pre><code class=\"lang-javascript\">this.liveInitOnBlockEvent(&#39;switch&#39;, function() { /* обработчик */ });\n</code></pre>\n"}]},"en":{"name":"i-bem","examples":[{"content":[]}],"description":[{"content":""}]}}