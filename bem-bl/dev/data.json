{
    "repo": "bem-bl",
    "ref": "dev",
    "enb": true,
    "url": "http://github.com/bem/bem-bl",
    "custom": [],
    "docs": {
        "readme": {
            "title": {
                "en": "Readme",
                "ru": "Readme"
            },
            "content": {
                "ru": "<h1 id=\"Библиотека-блоков-bem-bl\">Библиотека блоков bem-bl</h1>\n<p>bem-bl — расширенная библиотека блоков, которая помимо базовых вариантов блоков включает\nреализации некоторых универсальных решений для меню, текста, логотипа, поисковой строки, таблиц и т.д.</p>\n<p>На данный момент развитие библиотеки новыми блоками приостановлено, проект в статусе поддержки.\nНовые проекты рекомендуется разрабатывать на базе библиотеки <a href=\"http://ru.bem.info/libs/bem-core/\">bem-core</a>.</p>\n",
                "en": "<h1 id=\"bem-bl-blocks-library\">bem-bl blocks library</h1>\n<p>bem-bl is an extended library of blocks, that consists not only of basic blocks but also has a number of universal solutions to display a menu, text, logo, search tab, table, etc.</p>\n<p>Current state of development: bem-bl is suspended and will not be filled with new blocks, however we provide user support and bug fixing. We recommend you to start new projects with <a href=\"http://bem.info/libs/bem-core/\">bem-core</a> instead of bem-bl.</p>\n<!-- Yandex.Metrika counter -->\n<img src=\"https://mc.yandex.ru/watch/12831025\" style=\"position:absolute; left:-9999px;\" alt=\"\" />\n<!-- /Yandex.Metrika counter -->\n"
            }
        }
    },
    "deps": null,
    "levels": [
        {
            "name": "desktop.docs",
            "blocks": [
                {
                    "name": "b-icon",
                    "data": {
                        "ru": {
                            "name": "b-icon",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-icon/10-b-icon-src/10-b-icon-src.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-icon/20-b-icon-css/20-b-icon-css.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-icon/30-b-icon-sprite/30-b-icon-sprite.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок <code>b-icon</code> создает контейнер для изображения. Предоставляет возможность добавлять и редактировать изображение без необходимости правки родительского блока. </p>\n<h2 id=\"-\">Атрибуты блока</h2>\n<p>Имеет опциональные атрибуты блока:</p>\n<ul>\n<li><code>alt</code> – устанавливает альтернативный текст для изображений. Такой текст позволяет получить текстовую информацию о рисунке при отключенной в браузере загрузке изображений.  </li>\n<li><code>url</code> – задавая url, можно подставлять b-icon новую картинку, со свомим alt, шириной и высотой.  </li>\n<li><code>width</code>  устанавливает ширину изображения. Допускается использовать значения в пикселах или процентах. Если установлена процентная запись, то размеры изображения вычисляются относительно родительского элемента — контейнера, где находится тег <code>&lt;img&gt;</code>.  </li>\n<li><code>height</code> – устанавливает высоту изображения. Допускается использовать значения в пикселах или процентах. Если установлена процентная запись, то размеры изображения вычисляются относительно родительского элемента — контейнера, где находится тег <code>&lt;img&gt;</code>.</li>\n</ul>\n<h3 id=\"-\">Объявление блока на странице</h3>\n<pre><code>{\n    block: &#39;b-icon&#39;\n}\n</code></pre><p>Представление блока в HTML, после BEMHTML-преобразования:</p>\n<pre><code>&lt;body class=&quot;b-page b-page__body&quot;&gt;\n      &lt;div class=&quot;b-page__body-i&quot;&gt;&lt;img class=&quot;b-icon&quot; src=&quot;//yandex.st/lego/_/La6qi18Z8LwgnZdsAr1qy1GwCwo.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;\n   &lt;/body&gt;\n</code></pre><p>По умолчанию тег <code>&lt;img&gt;</code> выводит картинку с однопиксельным прозрачным .gif и пустым атрибутом <code>alt</code>.</p>\n<p>Использовать блок можно двумя способами:</p>\n<ul>\n<li>через url  </li>\n<li>через модификатор</li>\n</ul>\n<h3 id=\"-url\">Использование блока через url</h3>\n<p>Задаем в атрибуте url свой путь к изображению, BEMJSON:</p>\n<pre><code>{\n    block: &#39;b-icon&#39;,\n    url: &#39;my-icon.png&#39;,\n    alt: &#39;My icon&#39;\n}\n</code></pre><p>Этот способ рекомендуется для добавления одиночных картинок.</p>\n<h3 id=\"-\">Использование блока через добавление модификатора</h3>\n<p>Добавляем блоку модификатор, BEMJSON:</p>\n<pre><code>{\n    block: &#39;b-icon&#39;,\n    mods: { type: &#39;simple&#39; },\n    alt: &#39;My icon&#39;\n}\n</code></pre><p>В CSS задаем размеры изображения и путь к нему:</p>\n<pre><code>.b-icon_type_simple\n{\n    width: 16px;\n    height: 16px;\n    background: url(icons-sprite.png) no-repeat -50px 0;\n}\n</code></pre><p>Этот способ рекомендуется при использовании спрайтов.</p>\n<p>!<em>При помощи css-свойства background: url(...); в блоке можно использовать как спрайты, так и одиночную иконку.</em></p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_size-\">_size-*</h3>\n<p>Позволяют отображать специконки различных размеров.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-icon",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-icon/10-b-icon-src/10-b-icon-src.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-icon/20-b-icon-css/20-b-icon-css.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-icon/30-b-icon-sprite/30-b-icon-sprite.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p>This is an abstract container for an icon.</p>\n<p>By default the block produces a tag <code>img</code> which has an one-pixel transparent image (.gif) and an empty attribute <code>alt</code>.</p>\n<p>The block has optional attributes: <code>alt</code>, <code>url</code>, <code>width</code>, <code>height</code>.</p>\n<p>Set property <code>url#</code> to make <strong>b-icon</strong> with another image. The same for attributes <code>alt</code>, <code>width</code> and <code>height</code>.</p>\n<p>It is possible to use css sprites and single images for the block by using css-property <code>background: url(...);</code></p>\n"
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "b-layout-table",
                    "data": {
                        "ru": {
                            "name": "b-layout-table",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-layout-table/10-b-layout-table/10-b-layout-table.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-layout-table/20-b-layout-table-rows/20-b-layout-table-rows.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок <code>b-layout-table</code> — таблица со 100% шириной, для создания раскладки.</p>\n<p>Bemhtml шаблон блока выводит таблицу, строки и ячейки со всеми необходимыми атрибутами.</p>\n<h2 id=\"-\">Элементы блока</h2>\n<p>Имеет опциональные элементы блока: <code>gap</code>, <code>cell</code>, <code>row</code>, <code>inner</code>.</p>\n<p>Ячейки блока могут быть представлены либо елементом <code>cell</code>, либо элементом <code>gap</code>. </p>\n<h3 id=\"__cell\">__cell</h3>\n<p>Предназначен для вложения контента.<br>Преобразуется BEMHTML-шаблоном в тэг <code>&lt;td&gt;</code>.  </p>\n<h3 id=\"__gap\">__gap</h3>\n<p>Пустая ячейка, служит распоркой.<br>Преобразуется BEMHTML-шаблоном в тэг <code>&lt;td&gt;</code>. </p>\n<h3 id=\"__row\">__row</h3>\n<p>Служит для обозначения строк в раскладке таблицы.<br>Преобразуется BEMHTML-шаблоном в тэг <code>&lt;tr&gt;</code>.  </p>\n<h3 id=\"__inner\">__inner</h3>\n<p>Оборачивает контент ячеек, что позволяет задать отступы.<br>В HTML преобразуется тегом <code>&lt;div&gt;</code> с классом <code>b-layout-table</code>.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>BEMJSON для использования блока:</p>\n<pre><code>{\n    block: &#39;b-layout-table&#39;,  // имя блока   \n    mods: { layout: &#39;58-40&#39;}, // модификаторы блока. Модификатор необязательный\n    content: [                // структура страницы\n        {\n            elem: &#39;row&#39;,   \n            content: [\n                {\n                    elem: &#39;gap&#39;,\n                    rowspan: &#39;2&#39;\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    content: {\n                        elem: &#39;inner&#39;,\n                        content: &#39;Left cell&#39;\n                    }\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    elemMods: { position: &#39;r&#39;},\n                    content: &#39;Right cell&#39;\n                }\n            ]\n        },\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;cell&#39;,\n                    colspan: &#39;2&#39;,\n                    content: &#39;Second row and one cell&#39;\n                }\n            ]\n        }\n    ]\n}\n</code></pre><p>Представление блока в HTML, после BEMHTML-преобразования:</p>\n<pre><code>    &lt;table class=&quot;b-layout-table b-layout-table_layout_58-40&quot;&gt;\n        &lt;tr class=&quot;b-layout-table__row&quot;&gt;\n            &lt;td class=&quot;b-layout-table__gap&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;\n            &lt;td class=&quot;b-layout-table__cell&quot;&gt;\n                &lt;div class=&quot;b-layout-table__inner&quot;&gt;Left cell&lt;/div&gt;\n            &lt;/td&gt;\n            &lt;td class=&quot;b-layout-table__cell b-layout-table__cell_position_r&quot;&gt;Right cell&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;b-layout-table__row&quot;&gt;\n            &lt;td class=&quot;b-layout-table__cell&quot; colspan=&quot;2&quot;&gt;Second row and one cell&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n</code></pre><p>По умолчанию значения ширины ячеек в блоке не задаются. Доопределить блок стилями можно следующим образом:  </p>\n<ul>\n<li>добавляем модификатор блоку — <code>mods: { layout: &#39;58-40&#39; }</code>;  </li>\n<li>добавляем модификатор ячейке — <code>elemMods: { position: &#39;r&#39; }</code>;   </li>\n<li>оборачиваем контент ячеек, используя элемент <code>inner</code>, что позволяет задать нужные отступы. Далее каскадом задаем нужные  CSS-свойства.</li>\n</ul>\n<p>Вот такой CSS получится к BEMJSON-файлу, приведенному выше: </p>\n<pre><code>.b-layout-table_layout_58-40 .b-layout-table__cell_position_r \n{\n    width: 40%;\n}\n.b-layout-table_layout_58-40 .b-layout-table__gap \n{\n    width: 2%;\n    padding-left: 20px;\n}\n.b-layout-table_layout_58-40 .b-layout-table__inner \n{\n    margin-right: 0.8em;\n}\n</code></pre><p><strong>Важно</strong>\nОбратите внимание, что нельзя задавать самому блоку никаких дополнительных CCS-свойств, это может привести к конфликтам в верстке, так как блок может быть использован в реализации других блоков.<br>Использовать блок нужно, задавая ему модификатор или миксируя его с другим блоком/элементом.</p>\n<h2 id=\"-\">Модификаторы блока</h2>\n<h4 id=\"_layout\">_layout</h4>\n<p>Позволяет задавать размеры таблицы</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-layout-table",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-layout-table/10-b-layout-table/10-b-layout-table.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-layout-table/20-b-layout-table-rows/20-b-layout-table-rows.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p><code>b-layout-table</code> block — is a 100%-width table for making a layout.</p>\n<p>This block has a <code>bemhtml</code> template that gives a table, its rows and cells with all the attribute nodes needed.</p>\n<p>Cells of the block can be either <code>cell</code> or <code>gap</code> elements.\nA <code>cell</code> element is to contain a content and <code>gap</code> element is to set some space betwen cells.</p>\n<p>Let&#39;s look at <strong>bemjson</strong> input data of the block:</p>\n<pre><code class=\"lang-js\">{\n    block: &#39;b-layout-table&#39;,\n    mods: { layout: &#39;58-40&#39;},\n    content: [\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;gap&#39;,\n                    rowspan: &#39;2&#39;\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    content: {\n                        elem: &#39;inner&#39;,\n                        content: &#39;Left cell&#39;\n                    }\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    elemMods: { position: &#39;r&#39;},\n                    content: &#39;Right cell&#39;\n                }\n            ]\n        },\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;cell&#39;,\n                    colspan: &#39;2&#39;,\n                    content: &#39;Second row and one cell&#39;\n                }\n            ]\n        }\n    ]\n}\n</code></pre>\n<p>There is no width for cells by default.</p>\n<p>You can extend a block by your own CSS rules. For example, set a layout modifier to your block <code>mods: { layout: &#39;58-40&#39;}</code>, set a position modifier to right cell <code>elemMods: { position: &#39;r&#39;}</code>.\nWrap cells&#39; content by <strong>inner</strong> element to be able to set some paddings. Then, set CSS rules you\nneed (via cascade):</p>\n<p>This are CSS rules for the example above:</p>\n<pre><code class=\"lang-css\">.b-layout-table_layout_58-40 .b-layout-table__cell_position_r\n{\n    width: 40%;\n}\n\n.b-layout-table_layout_58-40 .b-layout-table__gap\n{\n    width: 2%;\n    padding-left: 20px;\n}\n\n.b-layout-table_layout_58-40 .b-layout-table__inner\n{\n    margin-right: 0.8em;\n}\n</code></pre>\n<p>Draw your attention that you shouldn&#39;t set any CSS to the block itself.\nThis is important to avoid CSS conflicts, because this block may be used as a part of many others.\nSo, use modifiers or mix with other blocks when using <code>b-layout-table</code>.</p>\n"
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "b-link",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "b-link",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-link/10-b-link-link/10-b-link-link.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-link/20-b-link-pseudo/20-b-link-pseudo.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-link/30-b-link-inner/30-b-link-inner.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-link/40-b-link-dynamic-pseudo/40-b-link-dynamic-pseudo.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-jquery</code> помогает подключить <strong>jQuery</strong> на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне <code>blocks-common</code> блок <code>i-jquery</code> состоит из нескольких элементов, которые содержат плагины к <strong>jQuery</strong>.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный <strong>JS</strong>.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_version\">_version</h3>\n<p><code>_version</code> \nПодключение библиотеки <strong>jQuery</strong> к странице \n<code>{ mods: { &#39;version&#39;: &#39;&lt;/url&gt;&#39; } }</code><br><code>{ mods: { &#39;version&#39;: &#39;&lt;jquery_version_number&gt;&#39; } }</code> \nНа уровне <code>blocks-common</code> модификатор <code>_version</code> дает возможность подключать необходимую версию библиотеки, указывая либо ее адрес, либо номер версии.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Чтобы поддерживаемая версия <strong>jQuery</strong> оказалась на страницах, нужно использовать такой <strong>BEMJSON</strong>:</p>\n<pre><code class=\"lang-js\">({\n    block: &#39;b-page&#39;,\n    title: &#39;Title of the page&#39;,\n    head: [\n        { elem: &#39;css&#39;, url: &#39;_index.css&#39; },\n        { elem: &#39;meta&#39;, attrs: { name: &#39;description&#39;, content: &#39;&#39; }}\n    ],\n    content:[\n        {\n            block: &#39;some-block&#39;,\n            content: { \n                ... \n            }\n        },\n        { block: &#39;i-jquery&#39;, mods: &#39;version&#39; }\n    ]\n})\n</code></pre>\n<p>Этот шаблон не продуцирует <strong>DOM</strong>-представление элемента. Он декларирует использование на странице элемента <code>js</code> блока <code>b-page</code>, подключающего <strong>js</strong> с <strong>jQuery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-link</strong> — является ссылкой. Используется в других блоках.</p>\n<p>По умолчанию цвет ссылки – #1A3DC1.</p>\n<p>Виды ссылок:</p>\n<ul>\n<li>простые ссылки</li>\n<li>ссылки со счетчиками. </li>\n<li>псевдо-ссылки. Ссылка, подразумевающая действие без перехода на другую страницу.</li>\n</ul>\n<h2 id=\"-\">Атрибуты блока</h2>\n<ul>\n<li><code>show-counter</code> - определяет вероятность показа счетчика для конкретной ссылки. По умолчанию вероятность показа счётчика — 10%. При значении <code>show-counter = 100</code> — показ счётчика гарантирован всегда.</li>\n</ul>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>BEMJSON для использования блока:</p>\n<pre><code>{\n   block: &#39;b-link&#39;,\n   url: &#39;http://company.yandex.ru&#39;,\n   title: &#39;Click here to learn more&#39;,\n   target: &#39;_blank&#39;,\n   content: &#39;The best company all over the world&#39;\n}\n</code></pre><p>В результате BEMHTML-преобразований cвойство <code>url</code> трансформируется в атрибут <code>href</code>. Свойства <code>title</code> и <code>target</code> — в соотвествующие атрибуты.</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n    &lt;body class=&quot;b-page b-page__body&quot;&gt;\n      &lt;div class=&quot;b-page__body-i&quot;&gt;&lt;a class=&quot;b-link&quot; href=&quot;http://company.yandex.ru&quot; target=&quot;_blank&quot; title=&quot;Click here to learn more&quot;&gt;The best company all over the world&lt;/a&gt;&lt;/div&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"-\">Элементы блока</h2>\n<h3 id=\"__inner\">__inner</h3>\n<p>Внутренний элемент<br><code>{ elem: &#39;inner&#39; }</code><br>Опциональный элемент, в который помещается текстовое содержимое ссылки. Необходим, когда ссылка содержит графический контент, например, иконку.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_disabled\">_disabled</h3>\n<p>_disabled_yes<br>Неактивная ссылка<br><code>{ mods: { &#39;disabled&#39;: &#39;yes&#39; } }</code><br>Делает ссылку или псевдоссылку неактивной.</p>\n<h3 id=\"_inner\">_inner</h3>\n<p>_inner_yes<br>Ссылка с вложенным элементом<br><code>{ mods: { &#39;inner&#39;: &#39;yes&#39; } }</code><br>Для удобного использования с иконками. Позволяет добавлять в ссылку элемент <code>__inner</code>. Содержит только CSS, которые переносит подчеркивание с самой ссылки на ее внутренний элемент.</p>\n<h3 id=\"_pseudo\">_pseudo</h3>\n<p>_pseudo_yes<br>Псевдоссылка<br><code>{ mods: { &#39;pseudo&#39;: &#39;yes&#39; } }</code><br>Модификация ссылки, подразумевающая действие без перехода на другую страницу. Визуально имеет пунктирное нижнее подчеркивание.</p>\n\n<p>﻿Опциональный элемент, в который помещается текстовое содержимое ссылки.\nНеобходим, когда ссылка содержит графический контент, например, иконку.</p>\n\n<p>﻿Делает ссылку или псевдоссылку неактивной.</p>\n\n<p>Для удобного использования с иконками. Позволяет добавлять в ссылку элемент <strong>inner</strong>. Содержит только <strong>CSS</strong>-правила,\nкоторые переносят подчеркивание с самой ссылки на ее внутренний элемент.</p>\n\n<p>Модификация ссылки, подразумевающая действие без перехода на другую страницу.\nВизуально имеет пунктирное нижнее подчеркивание.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-link",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-link/10-b-link-link/10-b-link-link.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-link/20-b-link-pseudo/20-b-link-pseudo.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-link/30-b-link-inner/30-b-link-inner.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-link/40-b-link-dynamic-pseudo/40-b-link-dynamic-pseudo.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p><strong>b-link</strong> block is used inside the other blocks.</p>\n<p>For a simple like set the following bemjson:</p>\n<pre><code class=\"lang-js\">{\n   block: &#39;b-link&#39;,\n   url: &#39;http://company.yandex.ru&#39;,\n   title: &#39;Click here to learn more&#39;,\n   target: &#39;_blank&#39;,\n   content: &#39;The best company all over the world&#39;\n}\n</code></pre>\n<p>An <code>url</code> property transforms info a <code>href</code> attribute. The <code>title</code> and <code>target</code> properties turn into the relevant attributes.</p>\n\n<p>This element is optional to contain a text of a link.\nIt is needed if a link includes grafic content, e.g. an icon.</p>\n\n<p>﻿Makes a link or a pseudolink disabled.</p>\n\n<p>For a convinient usage of an icon inside a link. \nAllows you to add a link to an <code>{ elem: inner }</code>. Contains css rules, that shift underlining from the link to its <code>inner</code> element.</p>\n\n<p>﻿A <strong>pseudo</strong> modifier is to mark a link that does not open on another page.\nIt has a dashed underline.</p>\n"
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "b-logo",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "b-logo",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-logo/10-b-logo/10-b-logo.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-logo/20-b-logo-link/20-b-logo-link.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-logo/30-b-logo-slogan/30-b-logo-slogan.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-jquery</code> помогает подключить <strong>jQuery</strong> на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне <code>blocks-common</code> блок <code>i-jquery</code> состоит из нескольких элементов, которые содержат плагины к <strong>jQuery</strong>.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный <strong>JS</strong>.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_version\">_version</h3>\n<p><code>_version</code> \nПодключение библиотеки <strong>jQuery</strong> к странице \n<code>{ mods: { &#39;version&#39;: &#39;&lt;/url&gt;&#39; } }</code><br><code>{ mods: { &#39;version&#39;: &#39;&lt;jquery_version_number&gt;&#39; } }</code> \nНа уровне <code>blocks-common</code> модификатор <code>_version</code> дает возможность подключать необходимую версию библиотеки, указывая либо ее адрес, либо номер версии.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Чтобы поддерживаемая версия <strong>jQuery</strong> оказалась на страницах, нужно использовать такой <strong>BEMJSON</strong>:</p>\n<pre><code class=\"lang-js\">({\n    block: &#39;b-page&#39;,\n    title: &#39;Title of the page&#39;,\n    head: [\n        { elem: &#39;css&#39;, url: &#39;_index.css&#39; },\n        { elem: &#39;meta&#39;, attrs: { name: &#39;description&#39;, content: &#39;&#39; }}\n    ],\n    content:[\n        {\n            block: &#39;some-block&#39;,\n            content: { \n                ... \n            }\n        },\n        { block: &#39;i-jquery&#39;, mods: &#39;version&#39; }\n    ]\n})\n</code></pre>\n<p>Этот шаблон не продуцирует <strong>DOM</strong>-представление элемента. Он декларирует использование на странице элемента <code>js</code> блока <code>b-page</code>, подключающего <strong>js</strong> с <strong>jQuery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-link</strong> — является ссылкой. Используется в других блоках.</p>\n<p>По умолчанию цвет ссылки – #1A3DC1.</p>\n<p>Виды ссылок:</p>\n<ul>\n<li>простые ссылки</li>\n<li>ссылки со счетчиками. </li>\n<li>псевдо-ссылки. Ссылка, подразумевающая действие без перехода на другую страницу.</li>\n</ul>\n<h2 id=\"-\">Атрибуты блока</h2>\n<ul>\n<li><code>show-counter</code> - определяет вероятность показа счетчика для конкретной ссылки. По умолчанию вероятность показа счётчика — 10%. При значении <code>show-counter = 100</code> — показ счётчика гарантирован всегда.</li>\n</ul>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>BEMJSON для использования блока:</p>\n<pre><code>{\n   block: &#39;b-link&#39;,\n   url: &#39;http://company.yandex.ru&#39;,\n   title: &#39;Click here to learn more&#39;,\n   target: &#39;_blank&#39;,\n   content: &#39;The best company all over the world&#39;\n}\n</code></pre><p>В результате BEMHTML-преобразований cвойство <code>url</code> трансформируется в атрибут <code>href</code>. Свойства <code>title</code> и <code>target</code> — в соотвествующие атрибуты.</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n    &lt;body class=&quot;b-page b-page__body&quot;&gt;\n      &lt;div class=&quot;b-page__body-i&quot;&gt;&lt;a class=&quot;b-link&quot; href=&quot;http://company.yandex.ru&quot; target=&quot;_blank&quot; title=&quot;Click here to learn more&quot;&gt;The best company all over the world&lt;/a&gt;&lt;/div&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"-\">Элементы блока</h2>\n<h3 id=\"__inner\">__inner</h3>\n<p>Внутренний элемент<br><code>{ elem: &#39;inner&#39; }</code><br>Опциональный элемент, в который помещается текстовое содержимое ссылки. Необходим, когда ссылка содержит графический контент, например, иконку.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_disabled\">_disabled</h3>\n<p>_disabled_yes<br>Неактивная ссылка<br><code>{ mods: { &#39;disabled&#39;: &#39;yes&#39; } }</code><br>Делает ссылку или псевдоссылку неактивной.</p>\n<h3 id=\"_inner\">_inner</h3>\n<p>_inner_yes<br>Ссылка с вложенным элементом<br><code>{ mods: { &#39;inner&#39;: &#39;yes&#39; } }</code><br>Для удобного использования с иконками. Позволяет добавлять в ссылку элемент <code>__inner</code>. Содержит только CSS, которые переносит подчеркивание с самой ссылки на ее внутренний элемент.</p>\n<h3 id=\"_pseudo\">_pseudo</h3>\n<p>_pseudo_yes<br>Псевдоссылка<br><code>{ mods: { &#39;pseudo&#39;: &#39;yes&#39; } }</code><br>Модификация ссылки, подразумевающая действие без перехода на другую страницу. Визуально имеет пунктирное нижнее подчеркивание.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>b-icon</code> создает контейнер для изображения. Предоставляет возможность добавлять и редактировать изображение без необходимости правки родительского блока. </p>\n<h2 id=\"-\">Атрибуты блока</h2>\n<p>Имеет опциональные атрибуты блока:</p>\n<ul>\n<li><code>alt</code> – устанавливает альтернативный текст для изображений. Такой текст позволяет получить текстовую информацию о рисунке при отключенной в браузере загрузке изображений.  </li>\n<li><code>url</code> – задавая url, можно подставлять b-icon новую картинку, со свомим alt, шириной и высотой.  </li>\n<li><code>width</code>  устанавливает ширину изображения. Допускается использовать значения в пикселах или процентах. Если установлена процентная запись, то размеры изображения вычисляются относительно родительского элемента — контейнера, где находится тег <code>&lt;img&gt;</code>.  </li>\n<li><code>height</code> – устанавливает высоту изображения. Допускается использовать значения в пикселах или процентах. Если установлена процентная запись, то размеры изображения вычисляются относительно родительского элемента — контейнера, где находится тег <code>&lt;img&gt;</code>.</li>\n</ul>\n<h3 id=\"-\">Объявление блока на странице</h3>\n<pre><code>{\n    block: &#39;b-icon&#39;\n}\n</code></pre><p>Представление блока в HTML, после BEMHTML-преобразования:</p>\n<pre><code>&lt;body class=&quot;b-page b-page__body&quot;&gt;\n      &lt;div class=&quot;b-page__body-i&quot;&gt;&lt;img class=&quot;b-icon&quot; src=&quot;//yandex.st/lego/_/La6qi18Z8LwgnZdsAr1qy1GwCwo.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;\n   &lt;/body&gt;\n</code></pre><p>По умолчанию тег <code>&lt;img&gt;</code> выводит картинку с однопиксельным прозрачным .gif и пустым атрибутом <code>alt</code>.</p>\n<p>Использовать блок можно двумя способами:</p>\n<ul>\n<li>через url  </li>\n<li>через модификатор</li>\n</ul>\n<h3 id=\"-url\">Использование блока через url</h3>\n<p>Задаем в атрибуте url свой путь к изображению, BEMJSON:</p>\n<pre><code>{\n    block: &#39;b-icon&#39;,\n    url: &#39;my-icon.png&#39;,\n    alt: &#39;My icon&#39;\n}\n</code></pre><p>Этот способ рекомендуется для добавления одиночных картинок.</p>\n<h3 id=\"-\">Использование блока через добавление модификатора</h3>\n<p>Добавляем блоку модификатор, BEMJSON:</p>\n<pre><code>{\n    block: &#39;b-icon&#39;,\n    mods: { type: &#39;simple&#39; },\n    alt: &#39;My icon&#39;\n}\n</code></pre><p>В CSS задаем размеры изображения и путь к нему:</p>\n<pre><code>.b-icon_type_simple\n{\n    width: 16px;\n    height: 16px;\n    background: url(icons-sprite.png) no-repeat -50px 0;\n}\n</code></pre><p>Этот способ рекомендуется при использовании спрайтов.</p>\n<p>!<em>При помощи css-свойства background: url(...); в блоке можно использовать как спрайты, так и одиночную иконку.</em></p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_size-\">_size-*</h3>\n<p>Позволяют отображать специконки различных размеров.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-logo</strong> использует внутри себя абстрактную иконку <strong>b-icon</strong> и ссылку <strong>b-link</strong>.\nЭти блоки миксируются в <strong>BEMHTML</strong>-шаблоне с соответствующими элементами блока <strong>b-logo</strong>.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Обычно логотип представляет собой ссылку с изображением. <strong>BEMJSON</strong> для этого варианта:</p>\n<pre><code class=\"lang-js\">{\n    block: &#39;b-logo&#39;,\n    content: {\n        elem: &#39;link&#39;,\n        url: &#39;/&#39;,\n        title: &#39;logo&#39;,\n        icon: {\n            elem: &#39;icon&#39;,\n            url: &#39;http://...&#39;,\n            alt: &#39;logo&#39;\n        }\n    }\n}\n</code></pre>\n<p>Представление блока в HTML, после BEMHTML-преобразования:   </p>\n<pre><code>    &lt;div class=&quot;b-logo&quot;&gt;\n        &lt;a class=&quot;b-link b-logo__link&quot; href=&quot;/&quot; title=&quot;logo&quot;&gt;\n            &lt;img class=&quot;b-icon b-logo__icon&quot; src=&quot;http://...&quot; alt=&quot;logo&quot;/&gt;\n        &lt;/a&gt;\n    &lt;/div&gt;\n</code></pre>"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-logo",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-logo/10-b-logo/10-b-logo.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-logo/20-b-logo-link/20-b-logo-link.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-logo/30-b-logo-slogan/30-b-logo-slogan.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p><strong>b-link</strong> block is used inside the other blocks.</p>\n<p>For a simple like set the following bemjson:</p>\n<pre><code class=\"lang-js\">{\n   block: &#39;b-link&#39;,\n   url: &#39;http://company.yandex.ru&#39;,\n   title: &#39;Click here to learn more&#39;,\n   target: &#39;_blank&#39;,\n   content: &#39;The best company all over the world&#39;\n}\n</code></pre>\n<p>An <code>url</code> property transforms info a <code>href</code> attribute. The <code>title</code> and <code>target</code> properties turn into the relevant attributes.</p>\n\n<p>This is an abstract container for an icon.</p>\n<p>By default the block produces a tag <code>img</code> which has an one-pixel transparent image (.gif) and an empty attribute <code>alt</code>.</p>\n<p>The block has optional attributes: <code>alt</code>, <code>url</code>, <code>width</code>, <code>height</code>.</p>\n<p>Set property <code>url#</code> to make <strong>b-icon</strong> with another image. The same for attributes <code>alt</code>, <code>width</code> and <code>height</code>.</p>\n<p>It is possible to use css sprites and single images for the block by using css-property <code>background: url(...);</code></p>\n"
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "b-menu-horiz",
                    "data": {
                        "ru": {
                            "name": "b-menu-horiz",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-menu-horiz/05-b-menu-horiz-simple/05-b-menu-horiz-simple.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-horiz/10-b-menu-horiz-normal/10-b-menu-horiz-normal.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-horiz/20-b-menu-horiz-complex/20-b-menu-horiz-complex.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-horiz/30-b-menu-horiz-normal-js/30-b-menu-horiz-normal-js.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок-помощник для построения абстрактного меню.</p>\n<p>Содержит js-функциональность, которая используется в блоках <code>b-menu-vert</code> и <code>b-menu-horiz</code>.</p>\n<p>Слушает событие <code>leftclick</code> на элементе <code>item-selector</code> и переводит в <code>{ state: &#39;current&#39; }</code> тот элемент <code>item</code>,\nна котором произошло событие.</p>\n<p>Тригерит событие которое можно использовать из других блоков, использующее любое меню.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-menu-horiz</strong> создаёт <strong>HTML</strong>-разметку для горизонтального меню. Кроме того, у блока есть <strong>JavaScript</strong>-функциональность, позволяющая создавать скрипты с реакцией на выбор пункта меню.</p>\n<p>Сложность <strong>HTML</strong>-разметки меню зависит от модификатора, с которым используется блок.</p>\n<p><strong>Важно:</strong> Блок не может использоваться без модификатора <code>layout</code>.</p>\n<p>Модификатор блока <code>layout</code> реализован с тремя возможными значениями:</p>\n<ul>\n<li><code>horiz</code></li>\n<li><code>complex</code></li>\n<li><code>normal</code></li>\n</ul>\n<h3 id=\"-\">Варианты использования</h3>\n<ul>\n<li>Простое горизонтальное меню списком</li>\n<li>Горизонтальное меню с клиентской функциональностью</li>\n<li>Меню без подмешивания блока i-bem </li>\n<li>Горизонтальное меню простыми ссылками</li>\n</ul>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Описанные ниже варианты деклараций блока в BEMJSON-файле представлены в разделе &quot;Примеры&quot;.</p>\n<h2 id=\"-\">Элементы блока</h2>\n<h3 id=\"__item\">__item</h3>\n<p>Элемент меню<br><code>{ elem: &#39;item&#39; }</code>\nСодержанием элементов меню может быть что угодно: ссылки на страницы, псевдоссылки, иконки и вообще любые блоки.</p>\n<h3 id=\"__title\">__title</h3>\n<p>Элемент служит для отображения заголовка меню. \n<code>{ elem: &#39;title&#39; }</code>\nВ <strong>BEMJSON</strong> необходимо указать свойство <code>title</code>.</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-vert&#39;,\n  title: {\n    elem: &#39;title&#39;,\n    content: &#39;Menu title&#39;\n  },\n  content: { ... }\n}\n</code></pre>\n<h3 id=\"__separator\">__separator</h3>\n<p>Специальный символ, который разделяет пункты меню\n<code>{ elem: &#39;separator&#39; }</code></p>\n<h3 id=\"__item-selector\">__item-selector</h3>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_layout\">_layout</h3>\n<p><code>_layout_complex</code><br>Горизонтальное меню с табличной разметкой<br><code>{ mods: { &#39;layout&#39;: &#39;complex&#39; } }</code><br>Использование блока с модификатором <code>{ layout: &#39;complex&#39; }</code> принципиально ничем не отличается. Для блока в такой модификации создаётся разметка на основе таблицы. Такое решение может потребоваться при некоторых дизайнах.</p>\n<h3 id=\"_layout_normal\">_layout_normal</h3>\n<p><strong>Простое горизонтальное меню списком</strong><br><code>{ mods: { &#39;layout&#39;: &#39;normal&#39; } }</code><br>Входные данные для блока с любым из этих модификаторов похожи: нужно описать блок, модификатор <code>layout</code>, в качестве свойства <code>content</code> блока перечислить пункты меню, которые выражаются элементами <code>item</code>.</p>\n<pre><code>{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Home&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Office&#39;\n    },\n    ...\n  ]\n}\n</code></pre><p>Не всегда меню на сайте подразумевает ссылки, уводящие пользователя на другую страницу. Меню может использоваться и для клиентского JavaScript-приложения. В этом случае содержанием пунктов меню обычно бывают псевдоссылки:</p>\n<pre><code>{\n    elem: &#39;item&#39;,\n    elemMods: { &#39;state&#39; : &#39;current&#39; },\n        content: {\n        block: &#39;b-link&#39;,\n        mods : { &#39;pseudo&#39; : &#39;yes&#39; },\n        url: &#39;/&#39;,\n        content: &#39;First point&#39;\n    }\n}\n</code></pre><p><strong>Горизонтальное меню с клиентской функциональностью</strong></p>\n<p>Не всегда меню на сайте подразумевает ссылки, уводящие пользователя на другую страницу. Меню может использоваться и для клиентского JavaScript-приложения. В этом случае содержанием пунктов меню обычно бывают псевдоссылки:</p>\n<pre><code>{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        url: &#39;/&#39;,\n        content: &#39;Home&#39;\n      }\n    },\n    { ... }\n  ]\n}\n</code></pre><p>Приведённый выше BEMJSON блока обеспечит нужный внешний вид.\nКроме этого нужно, чтобы у меню были области, реагирующие на клик. В данном случае они совпадают с псевдоссылками, поэтому можно применить смешивание блоков (<code>mix</code>). BEMJSON-декларация доступна в разделе &quot;Примеры&quot;.</p>\n<p>При явном использовании этот элемент представлен в DOM в виде <code>span</code>, в который можно положить блоки, составляющие пункт меню. Если же содержание пункта меню состоит всего из одного блока (как в примере с псевдоссылками), для экономии разметки разумно применять <code>mix</code>.</p>\n<p>Кроме того, что соответствующий элемент <code>item</code> в результате клика приобретает модификатор <code>{ state: &#39;current&#39; }</code>, на BEM-объекте блока возникает событие <code>current</code>, сопровождающееся данными о текущем и предыдущем активных пунктах. В своём JavaScript-приложении можно реагировать на это событие.</p>\n<p>В HTML по умолчанию блок представлен как имеющий JavaScript-реализацию (он смешан с блоком <code>i-bem</code> и имеет соответствующие параметры в атрибуте <code>data-bem</code>). Но если в блоке отсутствуют элементы <code>item-selector</code>, BEM-объект блока не создаётся.</p>\n<p><strong>Меню без подмешивания блока i-bem</strong></p>\n<p>Примешивание блока <code>i-bem</code> можно устранить, указав в свойстве js-блока значение <code>false</code>.</p>\n<pre><code>{\n  block: &#39;b-menu-horiz&#39;,\n  js: false,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    { ... }\n  ]\n}\n</code></pre><h3 id=\"_layout_simple\">_layout_simple</h3>\n<p><strong>Горизонтальное меню простыми ссылками</strong><br><code>{ mods: { &#39;layout&#39;: &#39;simple&#39; } }</code><br>В некоторых случаях для вывода меню не нужны даже DOM-узлы списка, а достаточно просто перечислить ссылки, разделив их пробелом, запятой или каким-либо специальным символом.</p>\n<p>Для вывода такого меню подходит реализация блока с модификатором <code>{ layout: &#39;simple&#39; }</code>.</p>\n<p>BEMJSON меню отличается наличием свойства <code>separator</code> — того самого специального символа, который разделяет пункты меню.\nАктивный пункт меню в данном примере представлен в виде простого текста в теге <code>span</code>.</p>\n<h3 id=\"__item_state_current\">__item_state_current</h3>\n<p><code>{ elemMods: { state: &#39;current&#39; } }</code>\nЭтот модификатор помечает текущий пункт меню.</p>\n<p>На своём уровне переопределения можно реализовать для такого модификатора CSS-правила, по которым текущий пункт меню будет визуально отличаться от остальных.</p>\n<pre><code>{\n    elem: &#39;item&#39;,\n    elemMods: { state: &#39;current&#39; },\n    content: &#39;Home&#39;\n}\n</code></pre><p>JavaScript-код блока реализован так, что активный пункт меню переключается при клике левой кнопкой мыши на соответствующем элементе <code>item-selector</code>.</p>\n\n<p>Использование блока с модификатором <code>{ layout: &#39;complex&#39; }</code> принципиально ничем не отличается.<br>Для блока в такой модификации создаётся разметка на основе таблицы. Такое решение может потребоваться при некоторых дизайнах.</p>\n\n<p>Входные данные для блока с любым из этих модификаторов похожи: нужно описать блок, модификатор <code>layout</code>, в качестве свойства <code>content</code> блока перечислить пункты меню, которые выражаются элементами <code>item</code>:</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Home&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Office&#39;\n    },\n    ...\n  ]\n}\n</code></pre>\n<p>Содержанием элементов меню может быть что угодно: ссылки на страницы, псевдоссылки, иконки и вообще любые блоки. В примере выше каждый пункт меню — это просто строка текста.</p>\n<p>Такое же меню со ссылками будет выглядеть следующим образом:</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/office&#39;, content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n</code></pre>\n<p>Кроме того, у одного из пунктов меню может быть указан модификатор <code>{ state: &#39;current&#39; }</code>, этот модификатор помечает текущий пункт меню.</p>\n<p>На своём уровне переопределения можно реализовать для такого модификатора <strong>CSS</strong> правила, по которым текущий пункт меню будет визуально отличаться от остальных.</p>\n<p>У меню также может быть необязательное свойство <code>title</code>, содержащее описание элемента <code>title</code> — заголовка меню.</p>\n<p>Для меню с заголовком <strong>BEMJSON</strong> будет такой:</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/office&#39;, content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n</code></pre>\n<h4 id=\"-\">Горизонтальное меню с клиентской функциональностью</h4>\n<p>Не всегда меню на сайте подразумевает ссылки, уводящие пользователя на другую страницу. Меню может использоваться и для клиентского <strong>JavaScript</strong>-приложения.\nВ этом случае содержанием пунктов меню обычно бывают псевдоссылки:</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        url: &#39;/&#39;,\n        content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        url: &#39;/office&#39;,\n        content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n</code></pre>\n<p>Приведённый выше <strong>BEMJSON</strong> блока обеспечит нужный внешний вид.</p>\n<p>Кроме этого нужно, чтобы у меню были области, реагирующие на клик. В данном случае они совпадают с псевдоссылками, поэтому можно применить смешивание блоков (<code>mix</code>):</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-horiz&#39;, elem : &#39;item-selector&#39; }],\n        url: &#39;/&#39;,\n        content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-horiz&#39;, elem : &#39;item-selector&#39; }],\n        url: &#39;/office&#39;,\n        content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n</code></pre>\n<p><strong>JavaScript</strong>-код блока реализован так, что активный пункт меню переключается при клике левой кнопкой мыши на соответствующем элементе <code>item-selector</code>.</p>\n<p>При явном использовании этот элемент представлен в <strong>DOM</strong> в виде <code>span</code>, в который можно положить блоки, составляющие пункт меню. Если же содержание пункта меню состоит всего из\nодного блока (как в примере с псевдоссылками), для экономии разметки разумно применять <code>mix</code>.</p>\n<p>Кроме того, что соответствующий элемент <code>item</code> в результате клика приобретает модификатор <code>{ state: &#39;current&#39; }</code>, на <strong>BEM</strong>-объекте блока возникает событие <code>current</code>, сопровождающееся данными о текущем и предыдущем активных пунктах.\nВ своём <strong>JavaScript</strong>-приложении можно реагировать на это событие.</p>\n<p>В <strong>HTML</strong> по умолчанию блок представлен как имеющий <strong>JavaScript</strong>-реализацию (он смешан с блоком <code>i-bem</code> и\nимеет соответствующие параметры в атрибуте <code>data-bem</code>). Но если в блоке отсутствуют элементы <code>item-selector</code>, <strong>BEM</strong>-объект блока не создаётся.</p>\n<h4 id=\"-i-bem\">Меню без подмешивания блока i-bem</h4>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  js: false,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/office&#39;, content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n</code></pre>\n<p>Примешивание блока <code>i-bem</code> можно устранить, указав в свойстве <code>js</code> блока значение <code>false</code>.</p>\n\n<p>В некоторых случаях для вывода меню не нужны даже <strong>DOM</strong>-узлы списка, а достаточно просто перечислить ссылки, разделив их пробелом, запятой или каким-либо специальным символом.</p>\n<p>Для вывода такого меню подходит реализация с модификатором <code>{ layout: &#39;normal&#39; }</code>:</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;simple&#39; },\n  separator: &#39; | &#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: &#39;Home&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n      block: &#39;b-link&#39;,\n      url: &#39;/&#39;,\n      content: &#39;Products&#39;\n    },\n    ...\n  ]\n}\n</code></pre>\n<p><strong>BEMJSON</strong>-меню отличается наличием свойства <code>separator</code> — того самого специального символа, который разделяет пункты меню.</p>\n<p>Активный пункт меню в данном примере представлен в виде простого текста в теге <code>span</code>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-menu-horiz",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-menu-horiz/05-b-menu-horiz-simple/05-b-menu-horiz-simple.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-horiz/10-b-menu-horiz-normal/10-b-menu-horiz-normal.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-horiz/20-b-menu-horiz-complex/20-b-menu-horiz-complex.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-horiz/30-b-menu-horiz-normal-js/30-b-menu-horiz-normal-js.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p>A <strong>b-menu-horiz</strong> block provides a horizontal menu. The block also has functionality (implemented on JavaScript) that helps to write scripts with reaction on a menu item when becoming selected.</p>\n<p>HTML markup complexity depends on a block modifier.</p>\n<p>The block has a <code>layout</code> modifier with three following values:</p>\n<ul>\n<li><code>horiz</code></li>\n<li><code>complex</code></li>\n<li><code>normal</code></li>\n</ul>\n<p><strong>Attention</strong>: This block cannot be used without a <code>layout</code> modifier.</p>\n"
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "b-menu-vert",
                    "data": {
                        "ru": {
                            "name": "b-menu-vert",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-menu-vert/10-b-menu-vert-simple/10-b-menu-vert-simple.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/20-b-menu-vert-js/20-b-menu-vert-js.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/30-b-menu-vert-js-complex/30-b-menu-vert-js-complex.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/40-b-menu-vert-trigger/40-b-menu-vert-trigger.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/50-b-menu-vert-trigger-deep/50-b-menu-vert-trigger-deep.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/60-b-menu-vert-submenu/60-b-menu-vert-submenu.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/70-b-menu-vert-submenu-trigger/70-b-menu-vert-submenu-trigger.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p>Опциональный элемент. В <strong>HTML</strong> представлен тегом <code>h3</code>, выводится перед списком (<code>ul</code>).</p>\n\n<p>﻿Не используется без элемента <code>item-selector</code>. По умолчанию невидим.</p>\n\n<p>﻿Добавление этого модификатора делает видимым элемент <strong>item-content</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок-помощник для построения абстрактного меню.</p>\n<p>Содержит js-функциональность, которая используется в блоках <code>b-menu-vert</code> и <code>b-menu-horiz</code>.</p>\n<p>Слушает событие <code>leftclick</code> на элементе <code>item-selector</code> и переводит в <code>{ state: &#39;current&#39; }</code> тот элемент <code>item</code>,\nна котором произошло событие.</p>\n<p>Тригерит событие которое можно использовать из других блоков, использующее любое меню.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок, создает разметку для вертикального меню. Построен на основе блока-хелпера <strong>i-menu</strong>.</p>\n<h2 id=\"-\">Варианты использования</h2>\n<ul>\n<li><strong>Простое вертикальное меню:</strong> в качестве контента элементов <code>item</code> в простых случаях используются ссылки.</li>\n<li><strong>Вертикальное js-меню с псевдоссылками:</strong> в качестве контента элементов <code>item</code> используются не ссылки, уводящие пользователя на другую страницу, а псевдоссылки для клиентского JavaScript-приложения. Для этого в BEMJSON-декларации доопределяем обычные ссылки до псевдо-ссылок, используя модификатор `{ pseudo: &#39;yes&#39; }.</li>\n<li><strong>Вертикальное js-меню со сложным контентом:</strong> Пункты меню могут содержать не один, а несколько блоков. </li>\n<li><strong>Раскрывающееся вертикальное js-меню:</strong> Если нужно сразу показать вложенное меню раскрытым, эти модификаторы следует явно задать в <strong>BEMJSON</strong>-описании блока.</li>\n<li><strong>Вложенные меню:</strong> <strong>BEMJSON</strong> позволяет вкладывать одни блоки в другие. Содержанием пункта меню может быть другое меню, и тогда естественным образом образуется вложенность.\nТакое использование меню создаст в <strong>DOM</strong>-дереве два блока (и два узла <code>ul</code>), которые будут вести себя соответственно.</li>\n</ul>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>В простейшем случае в <strong>BEMJSON</strong> достаточно объявить блок и перечислить его элементы <code>item</code> в свойстве <code>content</code>:</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Index&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Contacts&#39;\n    },\n    //...\n  ]\n}\n</code></pre>\n<p>HTML-представление:</p>\n<pre><code>    &lt;div class=&quot;b-menu-vert&quot;&gt;\n        &lt;ul class=&quot;b-menu-vert__layout&quot;&gt;\n            &lt;li class=&quot;b-menu-vert__layout-unit b-menu-vert__layout-unit_position_first&quot;&gt;\n                &lt;div class=&quot;b-menu-vert__item&quot;&gt;Index&lt;/div&gt;\n            &lt;/li&gt;\n            &lt;li class=&quot;b-menu-vert__layout-unit b-menu-vert__layout-unit_position_last&quot;&gt;\n                &lt;div class=&quot;b-menu-vert__item&quot;&gt;Contacts&lt;/div&gt;\n            &lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n</code></pre><p>В получившемся <strong>HTML</strong> появляются не только узлы для блока и явно заданных элементов <code>item</code>, но и разметка для элементов <code>layout</code> и <code>layout-unit</code>, которые отвечают за геометрическую отрисовку блока.</p>\n<p>Описанные ниже варианты деклараций блока в BEMJSON-файле представлены в разделе &quot;Примеры&quot;.</p>\n<h2 id=\"-\">Элементы блока</h2>\n<h3 id=\"__item\">__item</h3>\n<p>Элемент меню<br><code>{ elem: &#39;item&#39; }</code>\nСодержанием элементов меню может быть что угодно: ссылки на страницы, псевдоссылки, иконки и вообще любые блоки.</p>\n<h3 id=\"__title\">__title</h3>\n<p>Элемент служит для отображения заголовка меню. \n<code>{ elem: &#39;title&#39; }</code>\nВ <strong>BEMJSON</strong> необходимо указать свойство <code>title</code>.</p>\n<pre><code class=\"lang-js\">{\n  block: &#39;b-menu-vert&#39;,\n  title: {\n    elem: &#39;title&#39;,\n    content: &#39;Menu title&#39;\n  },\n  content: { ... }\n}\n</code></pre>\n<h3 id=\"__separator\">__separator</h3>\n<p>Специальный символ, который разделяет пункты меню\n<code>{ elem: &#39;separator&#39; }</code>\nПредусмотрена возможность создания пустого элемента списка для визуального разделения одних пунктов от других.<br>Для этого на уровне переопределения проекта нужно задать <strong>CSS</strong>-правила для него.\nЧаще всего <code>separator</code> представляют в виде горизонтальной черты.</p>\n<h3 id=\"__item-selector\">__item-selector</h3>\n<p><code>{ elem: &#39;item-selector&#39; }</code>\n<strong>Вертикальное js-меню с псевдоссылками</strong>\nКроме внешнего вида, <strong>js</strong>-меню отличается и клиентской функциональностью: оно способно по клику левой кнопкой мыши переключать соответствующий пункт меню в состояние <code>{ state: &#39;current&#39; }</code> и генерировать на <code>js</code>-объекте, соответствующем блоку, событие о факте переключения пункта меню.</p>\n<p>Для использования этой функциональности необходимо определить элемент <code>item-selector</code>. Эти элементы специально не совпадают с элементами <code>item</code>, потому что чаще всего сам пункт меню больше по размеру, чем его активная область.</p>\n<p>Элемент <code>item-selector</code> можно использовать как сам по себе, так и примешивая его к другим элементам или блокам. В данном случае можно сделать <code>mix</code> с псевдоссылками.</p>\n<p><strong>Вертикальное js-меню со сложным контентом</strong>\nПункты меню могут содержать не один, а несколько блоков.</p>\n<p>Поскольку реакция на клик необходима для всего содержания пункта меню, элемент <code>item-selector</code> используется в таком случае в явном виде, являясь контейнером для содержания пункта меню.\nВ этом случае он представлен в <strong>DOM</strong>-дереве узлом <code>span</code>.</p>\n<h3 id=\"__item-content\">__item-content</h3>\n<p><code>{ elem: &#39;item-conten&#39; }</code>\nЭлемент <code>item-content</code> с содержанием показывается или скрывается в зависимости от кликов по элементу <code>item-selector</code>. Описывается свойством <code>item-content</code>.</p>\n<p>Элемент <code>item-content</code> не видим, в случае, если элемент <code>trigger</code> не содержит модификатора <code>state</code>, а элемент <code>item-content</code> не содержит модификатора <code>visibility</code>.</p>\n<h3 id=\"__trigger\">__trigger</h3>\n<p><code>{ elem: &#39;trigger&#39; }</code>\nПри клике на элементе <code>trigger</code> левой кнопкой мыши он приобретает модификатор <code>{ state: &#39;opened&#39; }</code>. Элемент <code>item-content</code> в это же время приобретает модификатор <code>{ visibility: &#39;visible&#39; }</code> и становится виден на странице.</p>\n<p>По умолчанию не содержит модификатора <code>state</code>.</p>\n<h3 id=\"__submenu\">__submenu</h3>\n<p><code>{ elem: &#39;submenu&#39; }</code>\nЭлемент <code>submenu</code> дает возможность визуально представить меню как вложенное, но функционально — как один блок (например, со сквозным поведением активного пункта меню).</p>\n<p>Элемент <code>submenu</code> должен содержаться в элементе <code>item-content</code> и включать в себя описание элементов <code>item</code> для вложеннего меню.</p>\n<h2 id=\"-\">Модификаторы элементов</h2>\n<h3 id=\"_state_current\">_state_current</h3>\n<p><code>{ ElemMods: { state: &#39;current&#39; } }</code>\nУ одного из элементов <code>item</code> может быть модификатор <code>{ state: &#39;current&#39; }</code>, отмечающий выделенный пункт меню. \nМодификатор используется как для визуального выделения пункта при помощи <strong>CSS</strong>-правил для этого модификатора, так и для описания функционального поведения.</p>\n\n<div class=\"shmakowiki\"><p>﻿Блок, создает разметку для вертикального меню. Построен на основе блока-хелпера <tt>i-menu</tt>.</p><h3 id=\"Prostoevertikalynoemenyu\">Простое вертикальное меню</h3><p>В простейшем случае в <tt>BEMJSON</tt> достаточно объявить блок и перечислить его элементы <tt>item</tt> в свойстве <tt>content</tt>:</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      content: &apos;Index&apos;\n    },\n    {\n      elem: &apos;item&apos;,\n      content: &apos;Contacts&apos;\n    },\n    ...\n  ]\n}</code></pre><p>В получившемся <tt>HTML</tt> появляются не только узлы для блока и явно заданных элементов <tt>item</tt>, но и разметка для элементов <tt>layout</tt> и <tt>layout-unit</tt>, которые отвечают за геометрическую отрисовку блока.</p><p>В качестве контента элементов <tt>item</tt> в простых случаях используются ссылки:</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      content: {\n        block: &apos;b-link&apos;,\n        url: &apos;http://yandex.com&apos;,\n        content: &apos;Index&apos;\n      }\n    },\n    ...\n  ]\n}</code></pre><p>У одного из элементов <tt>item</tt> может быть модификатор <tt>{ state: &apos;current&apos; }</tt>, отмечающий выделенный пункт меню. Модификатор используется как для визуального выделения пункта при помощи <tt>CSS</tt>-правил для этого модификатора, так и для описания функционального поведения.</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      elemMods: { state: &apos;current&apos; },\n      content: {\n        block: &apos;b-link&apos;,\n        url: &apos;http://yandex.com&apos;,\n        content: &apos;Index&apos;\n      }\n    },\n    {\n      elem: &apos;item&apos;,\n      content: { ... }\n  ]\n}</code></pre><p>Для отображения заголовка меню (элемент <tt>title</tt>), в <tt>BEMJSON</tt> необходимо указать свойство <tt>title</tt>:</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  title: {\n    elem: &apos;title&apos;,\n    content: &apos;Menu title&apos;\n  },\n  content: [\n    {\n      elem: &apos;item&apos;,\n      elemMods: { state: &apos;current&apos; },\n      content: {\n        block: &apos;b-link&apos;,\n        url: &apos;http://yandex.com&apos;,\n        content: &apos;Index&apos;\n      }\n    },\n    {\n      elem: &apos;item&apos;,\n      content: { ... }\n  ]\n}</code></pre><p>Предусмотрена возможность создания пустого элемента списка для визуального разделения одних пунктов от других. За это отвечает элемент <tt>separator</tt>. Для этого на уровне переопределения проекта нужно задать <tt>CSS</tt>-правила для него. Чаще всего <tt>separator</tt> представляют в виде горизонтальной черты.</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      content: { ... }\n    },\n    {\n      elem: &apos;separator&apos;\n    },\n    {\n      elem: &apos;item&apos;,\n      content: { ... }\n    }\n  ]\n}</code></pre><h3 id=\"Vertikalynoejsmenyuspsevdossylkami\">Вертикальное js-меню с псевдоссылками</h3><p>В <tt>BEMJSON</tt> доопределяем обычные ссылки до псевдо-ссылок, используя модификатор <tt>{ pseudo: &apos;yes&apos; }</tt>:</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      elemMods: { &apos;state&apos;: &apos;current&apos; },\n      content: {\n        block: &apos;b-link&apos;,\n        mods: { &apos;pseudo&apos;: &apos;yes&apos; },\n        content: &apos;First point&apos;\n      }\n    },\n    ...\n  ]\n}</code></pre><p>Кроме внешнего вида, <tt>js</tt>-меню отличается и клиентской функциональностью: оно способно по клику левой кнопкой мыши переключать соответствующий пункт меню в состояние <tt>{ state: &apos;current&apos; }</tt> и генерировать на <tt>js</tt>-объекте, соответствующем блоку, событие о факте переключения пункта меню.</p><p>Для использования этой функциональности необходимо определить <a href=\"#__item-selector\">элементы <tt>item-selector</tt></a>. Эти элементы специально не совпадают с элементами <tt>item</tt>, потому что чаще всего сам пункт меню больше по размеру, чем его активная область.</p><p>Элемент <tt>item-selector</tt> можно использовать как сам по себе, так и примешивая его к другим элементам или блокам. В данном случае можно сделать <tt>mix</tt> с псевдоссылками:</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      elemMods: { &apos;state&apos;: &apos;current&apos; },\n      content: {\n        block: &apos;b-link&apos;,\n        mods: { &apos;pseudo&apos;: &apos;yes&apos; },\n        mix: [{ block: &apos;b-menu-vert&apos;, elem: &apos;item-selector&apos; }],\n        url: &apos;/&apos;,\n        content: &apos;First point&apos;\n      }\n    },\n    ...\n  ]\n}</code></pre><h3 id=\"Vertikalynoejsmenyusoslozhnymkontentom\">Вертикальное js-меню со сложным контентом</h3><p>Пункты меню могут содержать не один, а несколько блоков.</p><p>Поскольку реакция на клик необходима для всего содержания пункта меню, элемент <tt>item-selector</tt> используется в таком случае в явном виде, являясь контейнером для содержания пункта меню. В этом случае он представлен в <tt>DOM</tt>-дереве узлом <tt>span</tt>:</p><pre><code class=\"js\">{\n  elem: &apos;item&apos;,\n  content: {\n    elem: &apos;item-selector&apos;,\n    content: [\n      {\n        block: &apos;b-link&apos;,\n        mods: { &apos;pseudo&apos;: &apos;yes&apos;, &apos;inner&apos;: &apos;yes&apos; },\n        mix: [{ block: &apos;b-menu-vert&apos;, elem: &apos;item-selector&apos; }],\n        url: &apos;/&apos;,\n        content: [\n          {\n            block: &apos;b-icon&apos;,\n            url: &apos;/&apos;,\n            alt: &apos;Yandex favicon&apos;\n          },\n          {\n            elem: &apos;inner&apos;,\n            content: &apos;Second point&apos;\n          }\n        ]\n      },\n      &apos; One more element here&apos;\n    ]\n  }\n}</code></pre><h3 id=\"Raskryvayushheesyavertikalynoejsmenyu\">Раскрывающееся вертикальное js-меню</h3><p>Переключение активного пункта меню — не единственная реализованная динамическая функциональность. Пункты меню также могут содержать элементы <tt>trigger</tt>, клик по которым открывает или скрывает дочерний контент. С помощью таких элементов можно реализовать скрывающиеся вложенные меню.</p><p>Так же, как и элемент <tt>item-selector</tt>, элемент <tt>trigger</tt> может использоваться не явно, а через <tt>mix</tt>.</p><pre><code class=\"js\">{\n  block: &apos;b-menu-vert&apos;,\n  content: [\n    {\n      elem: &apos;item&apos;,\n      elemMods: { state: &apos;current&apos; },\n      content: &apos;Videos&apos;\n    },\n    {\n      elem: &apos;item&apos;,\n      content: {\n        block: &apos;b-link&apos;,\n        mods: { pseudo: &apos;yes&apos;, inner: &apos;yes&apos; },\n        mix: [{ block: &apos;b-menu-vert&apos;, elem: &apos;trigger&apos; }],\n        content: [\n          {\n            block: &apos;b-icon&apos;,\n            mix: [{ block: &apos;b-menu-vert&apos;, elem: &apos;trigger-icon&apos; }],\n            alt: &apos;trigger&apos;\n          },\n          {\n            elem: &apos;inner&apos;,\n            content: &apos;Images&apos;\n          }\n        ]\n      },\n      &apos;item-content&apos;: {\n        elem: &apos;item-content&apos;,\n        content: {\n          block: &apos;b-menu-vert&apos;,\n          mods: { &apos;type&apos;: &apos;submenu&apos; },\n          content: [\n            {\n              elem: &apos;item&apos;,\n              content: &apos;Any size&apos;\n            },\n            {\n              elem: &apos;item&apos;,\n              content: &apos;Large&apos;\n            },\n            {\n              elem: &apos;item&apos;,\n              content: &apos;Medium&apos;\n            }\n          ]\n        }\n      }\n    },\n    ...\n  ]\n}</code></pre><p>Кроме элемента <tt>item-selector</tt> здесь используется свойство <tt>item-content</tt>, описывающее элемент <tt>item-content</tt> с содержанием, которое показывается или скрывается в зависимости от кликов по элементу <tt>item-selector</tt>.</p><p>Элемент <tt>trigger-icon</tt> используется только для обозначения иконки. Не является обязательным элементом.</p><p>По умолчанию элемент <tt>trigger</tt> не содержит модификатора <tt>state</tt>, а элемент <tt>item-content</tt> не содержит модификатора <tt>visibility</tt>. В этом состоянии содержание элемента <tt>item-content</tt> не видно.<br/> При клике на элементе <tt>trigger</tt> левой кнопкой мыши он приобретает модификатор <tt>{ state: &apos;opened&apos; }</tt>. Элемент <tt>item-content</tt> в это же время приобретает модификатор <tt>{ visibility: &apos;visible&apos; }</tt> и становится виден на странице.</p><p>Если нужно сразу показать вложенное меню раскрытым, эти модификаторы следует явно задать в <tt>BEMJSON</tt>-описании блока:</p><pre><code class=\"js\">{\n  block: &apos;b-link&apos;,\n  mods: { pseudo: &apos;yes&apos;, inner: &apos;yes&apos; },\n  mix: [{ block: &apos;b-menu-vert&apos;, elem: &apos;trigger&apos;, elemMods: { state: &apos;opened&apos; } }],\n  content: { ... }\n}</code></pre><pre><code class=\"js\">&apos;item-content&apos;: {\n  elem: &apos;item-content&apos;,\n  elemMods: { visibility: &apos;visible&apos; },\n  content: [ ... ]</code></pre><h3 id=\"Vlozhennyemenyu\">Вложенные меню</h3><p><tt>BEMJSON</tt> позволяет вкладывать одни блоки в другие. Содержанием пункта меню может быть другое меню, и тогда естественным образом образуется вложенность.<br/> Такое использование меню создаст в <tt>DOM</tt>-дереве два блока (и два узла <tt>ul</tt>), которые будут вести себя соответственно.</p><p>Если есть необходимость визуально представить меню как вложенное, но функционально — как один блок (например, со сквозным поведением активного пункта меню), нужно воспользоваться элементом <tt>submenu</tt>.</p><p>Элемент <tt>submenu</tt> должен содержаться в элементе <tt>item-content</tt> и включать в себя описание элементов <tt>item</tt> для вложеннего меню.</p></div>\n<p>Этот элемент появляется в меню, когда требуется реакция на клик по пункту меню.</p>\n<p>Реакция на клик может понадобиться, если при выборе пункта меню нужно что-то сделать на клиенте. Например, загрузить контент по <strong>AJAX</strong>.</p>\n<p>Реакция есть только на клик левой кнопкой мыши. В результате клика соответствующий пункт меню (элемент <code>item</code>) приобретает модификатор <code>{ state: &#39;current&#39; }</code>, то есть пункт меню становится «выделенным» (текущим). Предыдущий выделенный пункт меню в то же время теряет модификатор <code>state</code>.</p>\n<p>В базовой <strong>CSS</strong>-реализации блока не предоставляется код для визуального выделения текущего пункта меню. Такой код можно реализовать на собственном уровне переопределения.</p>\n<p>Элемент может быть представлен в <strong>DOM</strong> отдельным узлом (<code>span</code>) или быть смиксованным с другим блоком, чаще всего с псевдо-ссылкой.</p>\n\n<p>Элемент вертикального меню, может содержать любой контент, чаще всего это ссылки или псевдо-ссылки.</p>\n<p>Имеет состояния: <code>[ current, disabled ]</code></p>\n\n<p>Используется в случае, когда необходимо представить вложенное меню частью списка «меню-родителя».</p>\n\n<p>Может содержать внутри себя опциональный элемент <code>trigger-icon</code>, который используется для отображения иконок.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-menu-vert",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-menu-vert/10-b-menu-vert-simple/10-b-menu-vert-simple.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/20-b-menu-vert-js/20-b-menu-vert-js.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/30-b-menu-vert-js-complex/30-b-menu-vert-js-complex.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/40-b-menu-vert-trigger/40-b-menu-vert-trigger.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/50-b-menu-vert-trigger-deep/50-b-menu-vert-trigger-deep.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/60-b-menu-vert-submenu/60-b-menu-vert-submenu.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-menu-vert/70-b-menu-vert-submenu-trigger/70-b-menu-vert-submenu-trigger.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p>You can make <strong>item-content</strong> element visible using this modificator.</p>\n\n<p>This block makes HTML markup for a vertical menu. It is based on a helper block <code>i-menu</code>.</p>\n<p>There are two types of elements in this block:</p>\n<h5 id=\"layout-elements\">Layout Elements</h5>\n<ul>\n<li><code>layout</code></li>\n<li><code>layout-unit</code></li>\n</ul>\n<h5 id=\"functional-element\">Functional Element</h5>\n<ul>\n<li><code>title</code></li>\n<li><code>item</code></li>\n</ul>\n\n<div class=\"shmakowiki\"><p>﻿This block makes HTML markup for a vertical menu. It is based on helper block <tt>i-menu</tt>.</p><p>There are 2 type of elements in this block:</p><h4 id=\"Layoutelements\">Layout elements</h4><ul><li>layout</li><li>layout-unit</li></ul><h4 id=\"Functionalelement\">Functional element</h4><ul><li>title</li><li>item</li></ul></div>"
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "b-page",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "b-page",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-page/10-b-page-simple/10-b-page-simple.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/20-b-page-simple/20-b-page-simple.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/30-b-page-with-js/30-b-page-with-js.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/40-b-page-with-level/40-b-page-with-level.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/60-page-nodeps-bem/60-page-nodeps-bem.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-jquery</code> помогает подключить <strong>jQuery</strong> на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне <code>blocks-common</code> блок <code>i-jquery</code> состоит из нескольких элементов, которые содержат плагины к <strong>jQuery</strong>.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный <strong>JS</strong>.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_version\">_version</h3>\n<p><code>_version</code> \nПодключение библиотеки <strong>jQuery</strong> к странице \n<code>{ mods: { &#39;version&#39;: &#39;&lt;/url&gt;&#39; } }</code><br><code>{ mods: { &#39;version&#39;: &#39;&lt;jquery_version_number&gt;&#39; } }</code> \nНа уровне <code>blocks-common</code> модификатор <code>_version</code> дает возможность подключать необходимую версию библиотеки, указывая либо ее адрес, либо номер версии.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Чтобы поддерживаемая версия <strong>jQuery</strong> оказалась на страницах, нужно использовать такой <strong>BEMJSON</strong>:</p>\n<pre><code class=\"lang-js\">({\n    block: &#39;b-page&#39;,\n    title: &#39;Title of the page&#39;,\n    head: [\n        { elem: &#39;css&#39;, url: &#39;_index.css&#39; },\n        { elem: &#39;meta&#39;, attrs: { name: &#39;description&#39;, content: &#39;&#39; }}\n    ],\n    content:[\n        {\n            block: &#39;some-block&#39;,\n            content: { \n                ... \n            }\n        },\n        { block: &#39;i-jquery&#39;, mods: &#39;version&#39; }\n    ]\n})\n</code></pre>\n<p>Этот шаблон не продуцирует <strong>DOM</strong>-представление элемента. Он декларирует использование на странице элемента <code>js</code> блока <code>b-page</code>, подключающего <strong>js</strong> с <strong>jQuery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок i-ecma позволяет использовать некоторые методы (<code>forEach</code>, <code>map</code>, ...) из <strong>ECMAScript 5</strong> для браузеров, не имеющих их нативной поддержки.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-ua</code> — служебный, не имеет визуального представления на странице.</p>\n<p>Этот блок используется всегда, когда используется блок <code>b-page</code>, так как вызывается внутри него. Задавать его самостоятельно на странице не нужно.</p>\n<p>В <strong>HTML</strong> блок представлен в виде инлайнового скрипта, в результате работы которого, у тега <code>html</code> появляются <strong>CSS</strong>-классы, идентифицирующие, включен ли <strong>JS</strong> и в каком режиме рендеринга находится браузер.</p>\n<p>Эти классы можно использовать, чтобы при помощи <strong>CSS</strong> задавать блокам разный внешний вид в зависимости от ситуации.</p>\n<p>Если такие классы проекту не нужны, можно переопределить <strong>BEMHTML</strong>-шаблон блока <code>i-ua</code> на уровне переопределения проекта:</p>\n<pre><code class=\"lang-js\">block i-ua, tag: &#39;&#39;\n</code></pre>\n<p>Блок <code>i-ua</code> с модификатором <code>_interaction_yes</code> может определять способ взаимодействия пользователя с интерфейсом.\nЕсли пользователь взаимодействует со страницей с помощью мыши/указателя, то атрибуту <code>data-interaction</code> dom-элемента блока <code>i-ua_interaction_yes</code> выставляется значение <code>pointer</code>, а если с помощью клавиатуры, то <code>keyboard</code>.\nИспользование data-атрибута вместо установки модификатора было выбрано, чтобы избежать repaint страницы при изменении css-класса у блока.</p>\n<p>Для подключения этой функциональности на проект необходимо на уровне <code>common.blocks</code>:</p>\n<ul>\n<li>Доопределить bemhtml-шаблон блока <code>b-page</code>:</li>\n</ul>\n<pre><code>block b-page, mix: {\n    var mix = applyNext() || [];\n\n    mix.push({ block: &#39;i-ua&#39;, mods: { interaction: &#39;yes&#39; }, js: true });\n    return mix;\n}\n</code></pre><ul>\n<li>Добавить зависимость <code>i-ua_interaction_yes</code> в <code>mustDeps</code> секцию блока <code>b-page</code>:</li>\n</ul>\n<pre><code class=\"lang-js\">({\n    mustDeps: [\n        { block: &#39;i-ua&#39;, mods: { interaction: &#39;yes&#39; } }\n    ]\n})\n</code></pre>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-page</strong> создаёт теги верхнего уровня страницы:</p>\n<ul>\n<li><code>&lt;html&gt;</code></li>\n<li><code>&lt;head&gt;</code></li>\n<li><code>&lt;body&gt;</code></li>\n</ul>\n<p>Именно он отвечает за то, какие подключить <strong>CSS</strong>- и <strong>JS</strong>-файлы к странице, выставление <code>meta</code> тегов, заголовка и так далее.</p>\n<h3 id=\"-\">Объявление блока на странице</h3>\n<p>Декларация блока в <strong>BEMJSON</strong> начинается объявлением блока и указанием свойства <code>title</code>, которое превращается в тег <code>&lt;title&gt;</code> в <strong>HTML</strong>.</p>\n<pre><code class=\"lang-js\">({\nblock: &#39;b-page&#39;,\ntitle: &#39;Page with link&#39;,\n...\n})\n</code></pre>\n<p>Указание свойства <code>head</code> дополняет элемент <code>head</code>, соответствующий <strong>HTML</strong> тегу <code>&lt;head&gt;</code>, элементами для подключения <strong>CSS</strong>- и <strong>JS</strong>-файлов:</p>\n<pre><code class=\"lang-js\">({\n...\nhead: [\n    { elem: &#39;css&#39;, url: &#39;example.css&#39;, ie: false },\n    { elem: &#39;css&#39;, url: &#39;example.ie.css&#39;, ie: &#39;lt IE 8&#39; },\n    { elem: &#39;js&#39;, url: &#39;example.js&#39; }\n],\n...\n})\n</code></pre>\n<p>Элемент <code>css</code> превращается в <strong>HTML</strong> в тег <code>&lt;link&gt;</code>, подключающий как <strong>CSS</strong>-стиль тот файл, что указан в свойстве <code>url</code> этого элемента. Также у такого элемента может быть свойство <code>ie</code>.\nЕсли это свойство <code>false</code>, то будут использоваться такие <code>condittional comments</code>, которые предотвратят использование этих стилей в <strong>IE</strong>. При строчном значении этого свойства тег <code>&lt;link&gt;</code>, будет обёрнут в соответствующий <code>conditional comment</code>, и этот стиль будет грузиться и использоваться указанных браузерах.</p>\n<p>Также есть возможность указывать свойство <code>content</code> для содержания тега <code>&lt;style&gt;</code>:</p>\n<pre><code class=\"lang-js\">({\n...\nhead: [\n    {\n        elem: &#39;css&#39;,\n        content: &#39;.b-blah { color: #f00&#39; }\n    },\n    ...\n],\n...\n})\n</code></pre>\n<p>Элемент <code>js</code> действует аналогично, подключая к странице <strong>JS</strong>-файлы при помощи тега <code>&lt;script&gt;</code>.</p>\n<p>Свойство <code>head</code> не описывает содержание <strong>HTML</strong>-тега <code>&lt;head&gt;</code> полностью, а лишь дополняет дефолтное, которое блок сам создаёт в своём <strong>BEMHTML</strong>-шаблоне.</p>\n<h4 id=\"-meta-\">Тег <code>&lt;meta&gt;</code> с указанием кодировки</h4>\n<p><strong>BEMHTML</strong>:</p>\n<pre><code class=\"lang-js\">content: [\n{\n    tag: &#39;meta&#39;,\n    attrs: { &#39;http-equiv&#39;: &#39;content-type&#39;, content: &#39;text/html; charset=utf-8&#39; }\n},\n...\n</code></pre>\n<h4 id=\"-meta-ie9-compatibility-\">Тег <code>&lt;meta&gt;</code> для использования <strong>IE9</strong> (и выше) в максимальном <strong>compatibility</strong> режиме</h4>\n<p><strong>BEMHTML</strong>:</p>\n<pre><code class=\"lang-js\">content: [\n...\n{\n    tag: &#39;meta&#39;,\n    attrs: { &#39;http-equiv&#39;: &#39;X-UA-Compatible&#39;, content: &#39;IE=EmulateIE7, IE=edge&#39; }\n},\n...\n</code></pre>\n<h4 id=\"-title-\">Выставление значения тега <code>&lt;title&gt;</code> страницы из свойства</h4>\n<pre><code class=\"lang-js\">content: [\n...\n{\n    tag: &#39;title&#39;,\n    content: this.ctx.title\n},\n...\n</code></pre>\n<h4 id=\"-\">Выставление фавиконки</h4>\n<pre><code class=\"lang-js\">content: [\n...\nthis.ctx.favicon ? {\n    elem: &#39;favicon&#39;,\n    url: this.ctx.favicon\n} : &#39;&#39;,\n...\n</code></pre>\n<h4 id=\"-i-ua-\">Декларация блока <code>i-ua</code></h4>\n<pre><code class=\"lang-js\">content: [\n...\n{\n    block: &#39;i-ua&#39;\n},\n...\n</code></pre>\n<p>Аналогично указанию свойства <code>head</code>, может быть задано свойство <code>meta</code>, содержащее один или несколько элементов <code>meta</code>:</p>\n<pre><code class=\"lang-js\">({\n...\nmeta: {\n    elem: &#39;meta&#39;,\n    attrs: {\n        name: &#39;keywords&#39;,\n        content: &#39;js, css, html&#39;\n    }\n},\n...\n})\n</code></pre>\n<pre><code class=\"lang-js\">({\n...\nmeta: [\n    {\n        elem: &#39;meta&#39;,\n        attrs: {\n            name: &#39;keywords&#39;,\n            content: &#39;js, css, html&#39;\n        }\n    },\n    {\n        elem: &#39;meta&#39;,\n        attrs: {\n            name : &#39;description&#39;,\n            content : &#39;Yet another webdev blog&#39;\n        }\n    }\n]\n...\n})\n</code></pre>\n<p>Значением свойства <code>content</code> блока <code>b-page</code> может быть хеш-описание содержимого (если речь идёт лишь об одном блоке) или массив блоков, описанных хешами:</p>\n<pre><code class=\"lang-js\">({\n...\ncontent: {\n    block: &#39;b-link&#39;,\n    mods: { pseudo: &#39;yes&#39;, togcolor: &#39;yes&#39;, color: &#39;green&#39; },\n    url: &#39;#&#39;,\n    target: &#39;_blank&#39;,\n    title: &#39;Кликни меня&#39;,\n    content: &#39;Псевдоссылка, меняющая цвет по клику&#39;\n}\n})\n</code></pre>\n<p>На блоки, содержащиеся в <code>content</code>, действуют их <strong>BEMHTML</strong>-шаблоны.</p>\n<h4 id=\"-\">Отмена автоматической инициализации блоков</h4>\n<pre><code class=\"lang-js\">noDeps: [\n    { block: &#39;i-bem&#39;, elem: &#39;dom&#39;, mods: { init: &#39;auto&#39; } }\n]\n</code></pre>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-page",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-page/10-b-page-simple/10-b-page-simple.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/20-b-page-simple/20-b-page-simple.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/30-b-page-with-js/30-b-page-with-js.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/40-b-page-with-level/40-b-page-with-level.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-page/60-page-nodeps-bem/60-page-nodeps-bem.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "b-search",
                    "data": {
                        "ru": {
                            "name": "b-search",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-search/10-b-search/10-b-search.ru"
                                        },
                                        {
                                            "url": "desktop.examples/b-search/20-b-search-under/20-b-search-under.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Поисковая форма, содержащая поле ввода (элемент <code>input</code>) и кнопку (элемент <code>button</code>). Элементы <code>input</code> и <code>button</code> являются обязательными.</p>\n<p>Блок <code>b-search</code>, преобразуется в тег <code>&lt;form&gt;</code>, внутри которого лежит <code>[элемент layout](#__layout)</code>,\nотвечающий за раскладку блока.</p>\n<p>Если есть необходимость добавить атрибуты элементам блока или самому блоку, достаточно в <strong>BEMJSON</strong> описать свойство <code>attrs</code>, и перечислить в нем все необходимые атрибуты.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<pre><code class=\"lang-js\">{\n    block: &#39;b-search&#39;,\n    attrs: { action: &#39;/search.xml&#39; },\n    input: {\n        elem: &#39;input&#39;\n    },\n    button: {\n        elem: &#39;button&#39;\n    },\n    under: {\n        block: &#39;b-link&#39;,\n        url: &#39;/&#39;,\n        content: &#39;Advanced search&#39;\n    }\n}\n</code></pre>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>b-layout-table</code> — таблица со 100% шириной, для создания раскладки.</p>\n<p>Bemhtml шаблон блока выводит таблицу, строки и ячейки со всеми необходимыми атрибутами.</p>\n<h2 id=\"-\">Элементы блока</h2>\n<p>Имеет опциональные элементы блока: <code>gap</code>, <code>cell</code>, <code>row</code>, <code>inner</code>.</p>\n<p>Ячейки блока могут быть представлены либо елементом <code>cell</code>, либо элементом <code>gap</code>. </p>\n<h3 id=\"__cell\">__cell</h3>\n<p>Предназначен для вложения контента.<br>Преобразуется BEMHTML-шаблоном в тэг <code>&lt;td&gt;</code>.  </p>\n<h3 id=\"__gap\">__gap</h3>\n<p>Пустая ячейка, служит распоркой.<br>Преобразуется BEMHTML-шаблоном в тэг <code>&lt;td&gt;</code>. </p>\n<h3 id=\"__row\">__row</h3>\n<p>Служит для обозначения строк в раскладке таблицы.<br>Преобразуется BEMHTML-шаблоном в тэг <code>&lt;tr&gt;</code>.  </p>\n<h3 id=\"__inner\">__inner</h3>\n<p>Оборачивает контент ячеек, что позволяет задать отступы.<br>В HTML преобразуется тегом <code>&lt;div&gt;</code> с классом <code>b-layout-table</code>.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>BEMJSON для использования блока:</p>\n<pre><code>{\n    block: &#39;b-layout-table&#39;,  // имя блока   \n    mods: { layout: &#39;58-40&#39;}, // модификаторы блока. Модификатор необязательный\n    content: [                // структура страницы\n        {\n            elem: &#39;row&#39;,   \n            content: [\n                {\n                    elem: &#39;gap&#39;,\n                    rowspan: &#39;2&#39;\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    content: {\n                        elem: &#39;inner&#39;,\n                        content: &#39;Left cell&#39;\n                    }\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    elemMods: { position: &#39;r&#39;},\n                    content: &#39;Right cell&#39;\n                }\n            ]\n        },\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;cell&#39;,\n                    colspan: &#39;2&#39;,\n                    content: &#39;Second row and one cell&#39;\n                }\n            ]\n        }\n    ]\n}\n</code></pre><p>Представление блока в HTML, после BEMHTML-преобразования:</p>\n<pre><code>    &lt;table class=&quot;b-layout-table b-layout-table_layout_58-40&quot;&gt;\n        &lt;tr class=&quot;b-layout-table__row&quot;&gt;\n            &lt;td class=&quot;b-layout-table__gap&quot; rowspan=&quot;2&quot;&gt;&lt;/td&gt;\n            &lt;td class=&quot;b-layout-table__cell&quot;&gt;\n                &lt;div class=&quot;b-layout-table__inner&quot;&gt;Left cell&lt;/div&gt;\n            &lt;/td&gt;\n            &lt;td class=&quot;b-layout-table__cell b-layout-table__cell_position_r&quot;&gt;Right cell&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;b-layout-table__row&quot;&gt;\n            &lt;td class=&quot;b-layout-table__cell&quot; colspan=&quot;2&quot;&gt;Second row and one cell&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n</code></pre><p>По умолчанию значения ширины ячеек в блоке не задаются. Доопределить блок стилями можно следующим образом:  </p>\n<ul>\n<li>добавляем модификатор блоку — <code>mods: { layout: &#39;58-40&#39; }</code>;  </li>\n<li>добавляем модификатор ячейке — <code>elemMods: { position: &#39;r&#39; }</code>;   </li>\n<li>оборачиваем контент ячеек, используя элемент <code>inner</code>, что позволяет задать нужные отступы. Далее каскадом задаем нужные  CSS-свойства.</li>\n</ul>\n<p>Вот такой CSS получится к BEMJSON-файлу, приведенному выше: </p>\n<pre><code>.b-layout-table_layout_58-40 .b-layout-table__cell_position_r \n{\n    width: 40%;\n}\n.b-layout-table_layout_58-40 .b-layout-table__gap \n{\n    width: 2%;\n    padding-left: 20px;\n}\n.b-layout-table_layout_58-40 .b-layout-table__inner \n{\n    margin-right: 0.8em;\n}\n</code></pre><p><strong>Важно</strong>\nОбратите внимание, что нельзя задавать самому блоку никаких дополнительных CCS-свойств, это может привести к конфликтам в верстке, так как блок может быть использован в реализации других блоков.<br>Использовать блок нужно, задавая ему модификатор или миксируя его с другим блоком/элементом.</p>\n<h2 id=\"-\">Модификаторы блока</h2>\n<h4 id=\"_layout\">_layout</h4>\n<p>Позволяет задавать размеры таблицы</p>\n\n<p>Элемент <code>layout</code> миксируется с блоком <code>b-layout-table</code> в <strong>BEMHTML</strong>-шаблоне блока <code>b-search</code>.</p>\n<p>Свойства <code>input</code>, <code>button</code>, <code>under</code>, представляют собой элементы для раскладки <code>[ layout-input, layout-button, layout-under ]</code>, которые миксируются с элементами <code>cell</code> блока <code>b-layout-table</code>, преобразуясь в <strong>HTML</strong> в ячейки таблицы.</p>\n<p>Свойство <code>under</code> добавляет еще одну строку с ячейкой, в нее можно помещать дополнительную информацию. Например, ссылка «Расширенный поиск» под поисковым полем.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-search",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-search/10-b-search/10-b-search.en"
                                        },
                                        {
                                            "url": "desktop.examples/b-search/20-b-search-under/20-b-search-under.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<p><code>b-layout-table</code> block — is a 100%-width table for making a layout.</p>\n<p>This block has a <code>bemhtml</code> template that gives a table, its rows and cells with all the attribute nodes needed.</p>\n<p>Cells of the block can be either <code>cell</code> or <code>gap</code> elements.\nA <code>cell</code> element is to contain a content and <code>gap</code> element is to set some space betwen cells.</p>\n<p>Let&#39;s look at <strong>bemjson</strong> input data of the block:</p>\n<pre><code class=\"lang-js\">{\n    block: &#39;b-layout-table&#39;,\n    mods: { layout: &#39;58-40&#39;},\n    content: [\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;gap&#39;,\n                    rowspan: &#39;2&#39;\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    content: {\n                        elem: &#39;inner&#39;,\n                        content: &#39;Left cell&#39;\n                    }\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    elemMods: { position: &#39;r&#39;},\n                    content: &#39;Right cell&#39;\n                }\n            ]\n        },\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;cell&#39;,\n                    colspan: &#39;2&#39;,\n                    content: &#39;Second row and one cell&#39;\n                }\n            ]\n        }\n    ]\n}\n</code></pre>\n<p>There is no width for cells by default.</p>\n<p>You can extend a block by your own CSS rules. For example, set a layout modifier to your block <code>mods: { layout: &#39;58-40&#39;}</code>, set a position modifier to right cell <code>elemMods: { position: &#39;r&#39;}</code>.\nWrap cells&#39; content by <strong>inner</strong> element to be able to set some paddings. Then, set CSS rules you\nneed (via cascade):</p>\n<p>This are CSS rules for the example above:</p>\n<pre><code class=\"lang-css\">.b-layout-table_layout_58-40 .b-layout-table__cell_position_r\n{\n    width: 40%;\n}\n\n.b-layout-table_layout_58-40 .b-layout-table__gap\n{\n    width: 2%;\n    padding-left: 20px;\n}\n\n.b-layout-table_layout_58-40 .b-layout-table__inner\n{\n    margin-right: 0.8em;\n}\n</code></pre>\n<p>Draw your attention that you shouldn&#39;t set any CSS to the block itself.\nThis is important to avoid CSS conflicts, because this block may be used as a part of many others.\nSo, use modifiers or mix with other blocks when using <code>b-layout-table</code>.</p>\n"
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "b-text",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "b-text",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-text/10-b-text-simple/10-b-text-simple.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок <code>b-text</code> обеспечивает единообразие оформления.</p>\n<p>Позволяет задавать произвольные элементы, которые продуцируются в одноименные <strong>HTML</strong>-теги.</p>\n<p>Для содержимого блока определены базовые стили заголовков, списков, начертания текста.</p>\n<p>Каждому элементу блока соотвествует в <strong>CSS</strong>-реализации свой класс. Это позволяет избежать каскада при использовании блока, что в свою очередь уменьшает время, затраченное на процесс вычисления размеров и положения элементов на странице.</p>\n\n<p>Позволяет стилизировать текст, редактируемый через всевозможные <strong>wysiwyg</strong>-редакторы.</p>\n<p>Не рекомендован к использованию, так как его реализация не соответвует <strong>BEM</strong>-подходу.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-text",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/b-text/10-b-text-simple/10-b-text-simple.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-bem",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "i-bem",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/i-bem/15-i-bem-click/15-i-bem-click.ru"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/17-i-bem-square/17-i-bem-square.ru"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/20-i-bem-liveinit-multiple/20-i-bem-liveinit-multiple.ru"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/40-i-bem-extend/40-i-bem-extend.ru"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/60-i-bem-pseudo-link/60-i-bem-pseudo-link.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-jquery</code> помогает подключить <strong>jQuery</strong> на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне <code>blocks-common</code> блок <code>i-jquery</code> состоит из нескольких элементов, которые содержат плагины к <strong>jQuery</strong>.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный <strong>JS</strong>.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_version\">_version</h3>\n<p><code>_version</code> \nПодключение библиотеки <strong>jQuery</strong> к странице \n<code>{ mods: { &#39;version&#39;: &#39;&lt;/url&gt;&#39; } }</code><br><code>{ mods: { &#39;version&#39;: &#39;&lt;jquery_version_number&gt;&#39; } }</code> \nНа уровне <code>blocks-common</code> модификатор <code>_version</code> дает возможность подключать необходимую версию библиотеки, указывая либо ее адрес, либо номер версии.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Чтобы поддерживаемая версия <strong>jQuery</strong> оказалась на страницах, нужно использовать такой <strong>BEMJSON</strong>:</p>\n<pre><code class=\"lang-js\">({\n    block: &#39;b-page&#39;,\n    title: &#39;Title of the page&#39;,\n    head: [\n        { elem: &#39;css&#39;, url: &#39;_index.css&#39; },\n        { elem: &#39;meta&#39;, attrs: { name: &#39;description&#39;, content: &#39;&#39; }}\n    ],\n    content:[\n        {\n            block: &#39;some-block&#39;,\n            content: { \n                ... \n            }\n        },\n        { block: &#39;i-jquery&#39;, mods: &#39;version&#39; }\n    ]\n})\n</code></pre>\n<p>Этот шаблон не продуцирует <strong>DOM</strong>-представление элемента. Он декларирует использование на странице элемента <code>js</code> блока <code>b-page</code>, подключающего <strong>js</strong> с <strong>jQuery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-bem",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/i-bem/15-i-bem-click/15-i-bem-click.en"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/17-i-bem-square/17-i-bem-square.en"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/20-i-bem-liveinit-multiple/20-i-bem-liveinit-multiple.en"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/40-i-bem-extend/40-i-bem-extend.en"
                                        },
                                        {
                                            "url": "desktop.examples/i-bem/60-i-bem-pseudo-link/60-i-bem-pseudo-link.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-ecma",
                    "data": {
                        "ru": {
                            "name": "i-ecma",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок i-ecma позволяет использовать некоторые методы (<code>forEach</code>, <code>map</code>, ...) из <strong>ECMAScript 5</strong> для браузеров, не имеющих их нативной поддержки.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-ecma",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "i-geolocation",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "i-geolocation",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Обёртка над <strong>Geolocation API</strong> для получения информации о текущем местоположении пользователя.</p>\n<p>Если всё хорошо, статический метод <code>get()</code> вернёт в колбэк объект со следующими данными:</p>\n<ul>\n<li><code>latitude</code> - широта, градусы;</li>\n<li><code>longitude</code> - долгота, градусы;</li>\n<li><code>altitude</code> -  высота над уровнем моря, м;</li>\n<li><code>altitudeAccuracy</code> - точность определения высоты, м;</li>\n<li><code>speed</code> - скорость движения, м/с;</li>\n<li><code>heading</code> - направление движения, в градусах относительно географического севера;</li>\n<li><code>accuracy</code> - точность, м;</li>\n<li><code>timestamp</code> - время, <strong>DOMTimeStamp</strong>;</li>\n</ul>\n<p>Если всё плохо, статический метод <code>get()</code> вернёт в колбэк объект с кодом ошибки:</p>\n<ul>\n<li>1 - браузер не поддерживает <strong>Geolocation API</strong>;</li>\n<li>2 - пользователь отклонил запрос на получение текущего местоположения;</li>\n<li>3 - невозможно получить данные / нет ответа от спутников;</li>\n<li>4 - таймаут;</li>\n<li>5 - что-то ещё пошло не так / неизвестная ошибка;</li>\n</ul>\n<p>Параметры:</p>\n<ul>\n<li><code>enableHighAccuracy</code> - если есть и активирован полноценный GPS, то полученные данные будут более точные (по умолчанию <code>true</code>);</li>\n<li><code>timeout</code> - таймаут геозапроса, в секундах (по умолчанию 15);</li>\n<li><code>cacheTime</code> - время кэширования геозапроса, в течение которого полученные данные считаются актуальными, в минутах (по умолчанию 15);</li>\n</ul>\n<p>Пример использования:</p>\n<pre><code class=\"lang-js\">    ...\n    BEM.blocks[&#39;i-geolocation&#39;].get(params, function(data) {\n        if (data.error) {\n            ...\n        } else {\n            ...\n        }\n    });\n    ...\n</code></pre>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-geolocation",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-jquery",
                    "data": {
                        "ru": {
                            "name": "i-jquery",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-jquery</code> помогает подключить <strong>jQuery</strong> на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне <code>blocks-common</code> блок <code>i-jquery</code> состоит из нескольких элементов, которые содержат плагины к <strong>jQuery</strong>.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный <strong>JS</strong>.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_version\">_version</h3>\n<p><code>_version</code> \nПодключение библиотеки <strong>jQuery</strong> к странице \n<code>{ mods: { &#39;version&#39;: &#39;&lt;/url&gt;&#39; } }</code><br><code>{ mods: { &#39;version&#39;: &#39;&lt;jquery_version_number&gt;&#39; } }</code> \nНа уровне <code>blocks-common</code> модификатор <code>_version</code> дает возможность подключать необходимую версию библиотеки, указывая либо ее адрес, либо номер версии.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Чтобы поддерживаемая версия <strong>jQuery</strong> оказалась на страницах, нужно использовать такой <strong>BEMJSON</strong>:</p>\n<pre><code class=\"lang-js\">({\n    block: &#39;b-page&#39;,\n    title: &#39;Title of the page&#39;,\n    head: [\n        { elem: &#39;css&#39;, url: &#39;_index.css&#39; },\n        { elem: &#39;meta&#39;, attrs: { name: &#39;description&#39;, content: &#39;&#39; }}\n    ],\n    content:[\n        {\n            block: &#39;some-block&#39;,\n            content: { \n                ... \n            }\n        },\n        { block: &#39;i-jquery&#39;, mods: &#39;version&#39; }\n    ]\n})\n</code></pre>\n<p>Этот шаблон не продуцирует <strong>DOM</strong>-представление элемента. Он декларирует использование на странице элемента <code>js</code> блока <code>b-page</code>, подключающего <strong>js</strong> с <strong>jQuery</strong>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-jquery",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "i-menu",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "i-menu",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок-помощник для построения абстрактного меню.</p>\n<p>Содержит js-функциональность, которая используется в блоках <code>b-menu-vert</code> и <code>b-menu-horiz</code>.</p>\n<p>Слушает событие <code>leftclick</code> на элементе <code>item-selector</code> и переводит в <code>{ state: &#39;current&#39; }</code> тот элемент <code>item</code>,\nна котором произошло событие.</p>\n<p>Тригерит событие которое можно использовать из других блоков, использующее любое меню.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-menu",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-ua",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "i-ua",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/i-ua/10-i-ua/10-i-ua.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-jquery</code> помогает подключить <strong>jQuery</strong> на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне <code>blocks-common</code> блок <code>i-jquery</code> состоит из нескольких элементов, которые содержат плагины к <strong>jQuery</strong>.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный <strong>JS</strong>.</p>\n<h2 id=\"-\">Модификаторы</h2>\n<h3 id=\"_version\">_version</h3>\n<p><code>_version</code> \nПодключение библиотеки <strong>jQuery</strong> к странице \n<code>{ mods: { &#39;version&#39;: &#39;&lt;/url&gt;&#39; } }</code><br><code>{ mods: { &#39;version&#39;: &#39;&lt;jquery_version_number&gt;&#39; } }</code> \nНа уровне <code>blocks-common</code> модификатор <code>_version</code> дает возможность подключать необходимую версию библиотеки, указывая либо ее адрес, либо номер версии.</p>\n<h2 id=\"-\">Объявление блока на странице</h2>\n<p>Чтобы поддерживаемая версия <strong>jQuery</strong> оказалась на страницах, нужно использовать такой <strong>BEMJSON</strong>:</p>\n<pre><code class=\"lang-js\">({\n    block: &#39;b-page&#39;,\n    title: &#39;Title of the page&#39;,\n    head: [\n        { elem: &#39;css&#39;, url: &#39;_index.css&#39; },\n        { elem: &#39;meta&#39;, attrs: { name: &#39;description&#39;, content: &#39;&#39; }}\n    ],\n    content:[\n        {\n            block: &#39;some-block&#39;,\n            content: { \n                ... \n            }\n        },\n        { block: &#39;i-jquery&#39;, mods: &#39;version&#39; }\n    ]\n})\n</code></pre>\n<p>Этот шаблон не продуцирует <strong>DOM</strong>-представление элемента. Он декларирует использование на странице элемента <code>js</code> блока <code>b-page</code>, подключающего <strong>js</strong> с <strong>jQuery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-ua</code> — служебный, не имеет визуального представления на странице.</p>\n<p>Этот блок используется всегда, когда используется блок <code>b-page</code>, так как вызывается внутри него. Задавать его самостоятельно на странице не нужно.</p>\n<p>В <strong>HTML</strong> блок представлен в виде инлайнового скрипта, в результате работы которого, у тега <code>html</code> появляются <strong>CSS</strong>-классы, идентифицирующие, включен ли <strong>JS</strong> и в каком режиме рендеринга находится браузер.</p>\n<p>Эти классы можно использовать, чтобы при помощи <strong>CSS</strong> задавать блокам разный внешний вид в зависимости от ситуации.</p>\n<p>Если такие классы проекту не нужны, можно переопределить <strong>BEMHTML</strong>-шаблон блока <code>i-ua</code> на уровне переопределения проекта:</p>\n<pre><code class=\"lang-js\">block i-ua, tag: &#39;&#39;\n</code></pre>\n<p>Блок <code>i-ua</code> с модификатором <code>_interaction_yes</code> может определять способ взаимодействия пользователя с интерфейсом.\nЕсли пользователь взаимодействует со страницей с помощью мыши/указателя, то атрибуту <code>data-interaction</code> dom-элемента блока <code>i-ua_interaction_yes</code> выставляется значение <code>pointer</code>, а если с помощью клавиатуры, то <code>keyboard</code>.\nИспользование data-атрибута вместо установки модификатора было выбрано, чтобы избежать repaint страницы при изменении css-класса у блока.</p>\n<p>Для подключения этой функциональности на проект необходимо на уровне <code>common.blocks</code>:</p>\n<ul>\n<li>Доопределить bemhtml-шаблон блока <code>b-page</code>:</li>\n</ul>\n<pre><code>block b-page, mix: {\n    var mix = applyNext() || [];\n\n    mix.push({ block: &#39;i-ua&#39;, mods: { interaction: &#39;yes&#39; }, js: true });\n    return mix;\n}\n</code></pre><ul>\n<li>Добавить зависимость <code>i-ua_interaction_yes</code> в <code>mustDeps</code> секцию блока <code>b-page</code>:</li>\n</ul>\n<pre><code class=\"lang-js\">({\n    mustDeps: [\n        { block: &#39;i-ua&#39;, mods: { interaction: &#39;yes&#39; } }\n    ]\n})\n</code></pre>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-ua",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "desktop.examples/i-ua/10-i-ua/10-i-ua.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                }
            ]
        },
        {
            "name": "touch-pad.docs",
            "blocks": [
                {
                    "name": "b-slider",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "b-slider",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "touch-pad.examples/b-slider/10-simple-bem/10-simple-bem.ru"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/20-simple-nonfirst-bem/20-simple-nonfirst-bem.ru"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/30-simple-images-bem/30-simple-images-bem.ru"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/40-perscreen-bem/40-perscreen-bem.ru"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/50-perscreen-nonfirst-bem/50-perscreen-nonfirst-bem.ru"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/60-simple-two-bem/60-simple-two-bem.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок i-ecma позволяет использовать некоторые методы (<code>forEach</code>, <code>map</code>, ...) из <strong>ECMAScript 5</strong> для браузеров, не имеющих их нативной поддержки.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-slider</strong> реализует функциональность слайдера.</p>\n<p><strong>Возможности:</strong></p>\n<ul>\n<li>реалтаймовый слайд &quot;за пальцем&quot; на iOS, Android 4+ и Bada</li>\n<li>слайд с помощью управляющих стрелочек на Android &lt;4 и WP7</li>\n<li>слайд более чем на один шаг при длинном жесте</li>\n<li>отпружинивающий предел, который нужно преодолеть для совершения шага</li>\n<li>понятия скорости и ускорения, с подогнанными значениями для <code>landscape</code>-режима</li>\n<li>&quot;тугость&quot; слайда за боковыми пределами</li>\n<li>определение слайд/скролл в начале жеста и дальнейшее разделение</li>\n<li>поэкранный слайд</li>\n<li>отложенная инициализация до момента загрузки картинок в <code>b-icon</code> внутри слайда, только если не:<ul>\n<li>картинка уже в кэше</li>\n<li>у блока <code>b-icon</code> есть атрибут <code>width</code></li>\n</ul>\n</li>\n<li>возможность полностью отложенной инициализации до момента появления модификатора <code>_init_yes</code></li>\n<li>автоматическая коррекция текущего смещения при любых поворотах с любого момента, предотвращение &quot;дырок&quot;</li>\n<li>задание непервого начального элемента в обычном и поэкранном слайдах</li>\n<li>события на основные действия с пробрасыванием текущих параметров (например, для <code>b-slider-arrows</code>)</li>\n</ul>\n<p>JS-параметры:</p>\n<ul>\n<li><code>step</code> - шаг, по умолчанию 100px</li>\n<li><code>threshold</code> - предел, который нужно преодолеть для совершения шага, по умолчанию 50px</li>\n</ul>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-slider",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "touch-pad.examples/b-slider/10-simple-bem/10-simple-bem.en"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/20-simple-nonfirst-bem/20-simple-nonfirst-bem.en"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/30-simple-images-bem/30-simple-images-bem.en"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/40-perscreen-bem/40-perscreen-bem.en"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/50-perscreen-nonfirst-bem/50-perscreen-nonfirst-bem.en"
                                        },
                                        {
                                            "url": "touch-pad.examples/b-slider/60-simple-two-bem/60-simple-two-bem.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-bem",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "i-bem",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-bem",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-ecma",
                    "data": {
                        "ru": {
                            "name": "i-ecma",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок i-ecma позволяет использовать некоторые методы (<code>forEach</code>, <code>map</code>, ...) из <strong>ECMAScript 5</strong> для браузеров, не имеющих их нативной поддержки.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-ecma",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "i-geolocation",
                    "data": {
                        "ru": {
                            "name": "i-geolocation",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Обёртка над <strong>Geolocation API</strong> для получения информации о текущем местоположении пользователя.</p>\n<p>Если всё хорошо, статический метод <code>get()</code> вернёт в колбэк объект со следующими данными:</p>\n<ul>\n<li><code>latitude</code> - широта, градусы;</li>\n<li><code>longitude</code> - долгота, градусы;</li>\n<li><code>altitude</code> -  высота над уровнем моря, м;</li>\n<li><code>altitudeAccuracy</code> - точность определения высоты, м;</li>\n<li><code>speed</code> - скорость движения, м/с;</li>\n<li><code>heading</code> - направление движения, в градусах относительно географического севера;</li>\n<li><code>accuracy</code> - точность, м;</li>\n<li><code>timestamp</code> - время, <strong>DOMTimeStamp</strong>;</li>\n</ul>\n<p>Если всё плохо, статический метод <code>get()</code> вернёт в колбэк объект с кодом ошибки:</p>\n<ul>\n<li>1 - браузер не поддерживает <strong>Geolocation API</strong>;</li>\n<li>2 - пользователь отклонил запрос на получение текущего местоположения;</li>\n<li>3 - невозможно получить данные / нет ответа от спутников;</li>\n<li>4 - таймаут;</li>\n<li>5 - что-то ещё пошло не так / неизвестная ошибка;</li>\n</ul>\n<p>Параметры:</p>\n<ul>\n<li><code>enableHighAccuracy</code> - если есть и активирован полноценный GPS, то полученные данные будут более точные (по умолчанию <code>true</code>);</li>\n<li><code>timeout</code> - таймаут геозапроса, в секундах (по умолчанию 15);</li>\n<li><code>cacheTime</code> - время кэширования геозапроса, в течение которого полученные данные считаются актуальными, в минутах (по умолчанию 15);</li>\n</ul>\n<p>Пример использования:</p>\n<pre><code class=\"lang-js\">    ...\n    BEM.blocks[&#39;i-geolocation&#39;].get(params, function(data) {\n        if (data.error) {\n            ...\n        } else {\n            ...\n        }\n    });\n    ...\n</code></pre>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-geolocation",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "i-jquery",
                    "data": {
                        "ru": {
                            "name": "i-jquery",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-jquery",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                }
            ]
        },
        {
            "name": "touch-phone.docs",
            "blocks": [
                {
                    "name": "b-slider",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "b-slider",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "touch-phone.examples/b-slider/10-simple-bem/10-simple-bem.ru"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/20-simple-nonfirst-bem/20-simple-nonfirst-bem.ru"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/30-simple-images-bem/30-simple-images-bem.ru"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/40-perscreen-bem/40-perscreen-bem.ru"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/50-perscreen-nonfirst-bem/50-perscreen-nonfirst-bem.ru"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/60-simple-two-bem/60-simple-two-bem.ru"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок i-ecma позволяет использовать некоторые методы (<code>forEach</code>, <code>map</code>, ...) из <strong>ECMAScript 5</strong> для браузеров, не имеющих их нативной поддержки.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <strong>b-slider</strong> реализует функциональность слайдера.</p>\n<p><strong>Возможности:</strong></p>\n<ul>\n<li>реалтаймовый слайд &quot;за пальцем&quot; на iOS, Android 4+ и Bada</li>\n<li>слайд с помощью управляющих стрелочек на Android &lt;4 и WP7</li>\n<li>слайд более чем на один шаг при длинном жесте</li>\n<li>отпружинивающий предел, который нужно преодолеть для совершения шага</li>\n<li>понятия скорости и ускорения, с подогнанными значениями для <code>landscape</code>-режима</li>\n<li>&quot;тугость&quot; слайда за боковыми пределами</li>\n<li>определение слайд/скролл в начале жеста и дальнейшее разделение</li>\n<li>поэкранный слайд</li>\n<li>отложенная инициализация до момента загрузки картинок в <code>b-icon</code> внутри слайда, только если не:<ul>\n<li>картинка уже в кэше</li>\n<li>у блока <code>b-icon</code> есть атрибут <code>width</code></li>\n</ul>\n</li>\n<li>возможность полностью отложенной инициализации до момента появления модификатора <code>_init_yes</code></li>\n<li>автоматическая коррекция текущего смещения при любых поворотах с любого момента, предотвращение &quot;дырок&quot;</li>\n<li>задание непервого начального элемента в обычном и поэкранном слайдах</li>\n<li>события на основные действия с пробрасыванием текущих параметров (например, для <code>b-slider-arrows</code>)</li>\n</ul>\n<p>JS-параметры:</p>\n<ul>\n<li><code>step</code> - шаг, по умолчанию 100px</li>\n<li><code>threshold</code> - предел, который нужно преодолеть для совершения шага, по умолчанию 50px</li>\n</ul>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "b-slider",
                            "examples": [
                                {
                                    "content": [
                                        {
                                            "url": "touch-phone.examples/b-slider/10-simple-bem/10-simple-bem.en"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/20-simple-nonfirst-bem/20-simple-nonfirst-bem.en"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/30-simple-images-bem/30-simple-images-bem.en"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/40-perscreen-bem/40-perscreen-bem.en"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/50-perscreen-nonfirst-bem/50-perscreen-nonfirst-bem.en"
                                        },
                                        {
                                            "url": "touch-phone.examples/b-slider/60-simple-two-bem/60-simple-two-bem.en"
                                        }
                                    ]
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-bem",
                    "jsdoc": "",
                    "data": {
                        "ru": {
                            "name": "i-bem",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n\n<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#data.params\">формате параметров в data-bem</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"bem.params\"></a></p>\n<h5 id=\"-data-bem\">Формат параметров блока в data-bem</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-bem",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    }
                },
                {
                    "name": "i-ecma",
                    "data": {
                        "ru": {
                            "name": "i-ecma",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Блок i-ecma позволяет использовать некоторые методы (<code>forEach</code>, <code>map</code>, ...) из <strong>ECMAScript 5</strong> для браузеров, не имеющих их нативной поддержки.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-ecma",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "i-geolocation",
                    "data": {
                        "ru": {
                            "name": "i-geolocation",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Обёртка над <strong>Geolocation API</strong> для получения информации о текущем местоположении пользователя.</p>\n<p>Если всё хорошо, статический метод <code>get()</code> вернёт в колбэк объект со следующими данными:</p>\n<ul>\n<li><code>latitude</code> - широта, градусы;</li>\n<li><code>longitude</code> - долгота, градусы;</li>\n<li><code>altitude</code> -  высота над уровнем моря, м;</li>\n<li><code>altitudeAccuracy</code> - точность определения высоты, м;</li>\n<li><code>speed</code> - скорость движения, м/с;</li>\n<li><code>heading</code> - направление движения, в градусах относительно географического севера;</li>\n<li><code>accuracy</code> - точность, м;</li>\n<li><code>timestamp</code> - время, <strong>DOMTimeStamp</strong>;</li>\n</ul>\n<p>Если всё плохо, статический метод <code>get()</code> вернёт в колбэк объект с кодом ошибки:</p>\n<ul>\n<li>1 - браузер не поддерживает <strong>Geolocation API</strong>;</li>\n<li>2 - пользователь отклонил запрос на получение текущего местоположения;</li>\n<li>3 - невозможно получить данные / нет ответа от спутников;</li>\n<li>4 - таймаут;</li>\n<li>5 - что-то ещё пошло не так / неизвестная ошибка;</li>\n</ul>\n<p>Параметры:</p>\n<ul>\n<li><code>enableHighAccuracy</code> - если есть и активирован полноценный GPS, то полученные данные будут более точные (по умолчанию <code>true</code>);</li>\n<li><code>timeout</code> - таймаут геозапроса, в секундах (по умолчанию 15);</li>\n<li><code>cacheTime</code> - время кэширования геозапроса, в течение которого полученные данные считаются актуальными, в минутах (по умолчанию 15);</li>\n</ul>\n<p>Пример использования:</p>\n<pre><code class=\"lang-js\">    ...\n    BEM.blocks[&#39;i-geolocation&#39;].get(params, function(data) {\n        if (data.error) {\n            ...\n        } else {\n            ...\n        }\n    });\n    ...\n</code></pre>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-geolocation",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                },
                {
                    "name": "i-jquery",
                    "data": {
                        "ru": {
                            "name": "i-jquery",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": "<h2 id=\"-\">Описание</h2>\n<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока <strong>i-jquery</strong>.</p>\n"
                                }
                            ]
                        },
                        "en": {
                            "name": "i-jquery",
                            "examples": [
                                {
                                    "content": []
                                }
                            ],
                            "description": [
                                {
                                    "content": ""
                                }
                            ]
                        }
                    },
                    "jsdoc": ""
                }
            ]
        }
    ]
}