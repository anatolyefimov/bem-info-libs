<h2 id="Описание">Описание</h2>
<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.
Блок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>
<h3 id="js-реализация-блока-i-bem">js-реализация блока i-bem</h3>
<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>
<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>
<h5 id="Что-описано-на-этой-странице-">Что описано на этой странице?</h5>
<ul>
<li>Какие бывают блоки<ul>
<li><a href="#dom.blocks">Блоки с DOM-представлением</a></li>
<li><a href="#abstract.blocks">Блоки без DOM-представления</a></li>
</ul>
</li>
<li>Принципы и особенности подхода<ul>
<li><a href="#decl">Декларативный принцип</a></li>
<li><a href="#block.getting">Доступ к другим блокам</a></li>
<li><a href="#mods">Работа с модификаторами</a></li>
<li><a href="#customization">Кастомизация блоков</a></li>
</ul>
</li>
<li><a href="#creation">Создание собственного блока bem-js</a></li>
<li>Подробнее о понятиях<ul>
<li><a href="#init">Инициализация</a></li>
<li><a href="#liveinit">Инициализация по требованию (live-инициализация)</a></li>
<li><a href="#finding">Методы доступа к блокам и элементам</a></li>
<li><a href="#events">Работа с событиями</a></li>
</ul>
</li>
</ul>
<p><a name="dom.blocks"></a></p>
<h5 id="Блоки-с-DOM-представлением">Блоки с DOM-представлением</h5>
<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>
<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>data-bem</code>:</p>
<pre><code class="lang-html">    &lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{ &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;
...
&lt;/div&gt;
</code></pre>
<p>Ниже подробно рассказано о <a href="#data.params">формате параметров в data-bem</a>.</p>
<p><a name="abstract.blocks"></a></p>
<h5 id="Блоки-без-DOM-представления">Блоки без DOM-представления</h5>
<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.
Такие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>
<p>О том, как создавать такие блоки, написано под заголовком <a href="#dom.decl">Декларация блока</a>.</p>
<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>
<p>Технология <code>bem-js</code> использует предметную область <a href="http://ru.bem.info/method/">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>
<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>
<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>
<p><a name="decl"></a></p>
<h3 id="Декларативный-принцип">Декларативный принцип</h3>
<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>
<h4 id="Декларация-блока">Декларация блока</h4>
<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-link&#39;, {
//...
</code></pre>
<pre><code class="lang-js">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {
//...
</code></pre>
<p><a href="#dom.decl">Подробнее о декларации блока</a></p>
<p><a name="mods.reaction"></a></p>
<h4 id="Реакция-на-изменение-модификаторов">Реакция на изменение модификаторов</h4>
<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>
<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>
<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>
<pre><code class="lang-js">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {

    onSetMod : {

        &#39;disabled&#39; : function(modName, modVal) {

            this._getSwitcher().setMod(modName, modVal);
            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();
        }
    },...
</code></pre>
<p>Подробно <a href="#mods.callbacks">о декларации обработки модификаторов</a> рассказано в пункте про создание собственного блока.</p>
<p><a name="block.getting"></a></p>
<h3 id="Доступ-к-другим-блокам">Доступ к другим блокам</h3>
<p>Может возникнуть необходимость управлять другим блоком.
Для любых манипуляций с блоком необходимо получить доступ к <code>js</code>-объекту этого блока и вызывать его методы.</p>
<p><a name="blocks.finding"></a></p>
<h4 id="Доступ-к-bem-js-блоку-из-другого-bem-js-блока-">Доступ к bem-js-блоку из другого bem-js-блока.</h4>
<p>В случае <a href="#creation">реализации собственного кастомного блока на технологии <strong>bem-js</strong></a>, блоку соответствует <code>js</code>-объект. Он наследует общие для всех блоков методы, позволяющие работать с <code>DOM</code> документа в терминах <code>BEM</code>. Среди этих методов есть методы поиска других блоков относительно текущего (<code>findBlock</code>*-методы).
Они возвращают <code>js</code>-объект искомого блока, что позволяет затем напрямую вызывать его методы.</p>
<p><strong>Не используйте <code>jQuery</code>-селекторы для поиска блоков и элементов.</strong></p>
<p>В этом примере вызывается метод <code>val()</code> у блока <code>b-form-checkbox</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-checkbox-example&#39;, {
    onSetMod: {
        &#39;js&#39;: function() {
            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});
            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());
        }
    }
}
);
</code></pre>
<h4 id="Доступ-к-bem-js-блоку-не-из-bem-js-блока">Доступ к bem-js-блоку не из bem-js-блока</h4>
<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>
<pre><code class="lang-js">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);
</code></pre>
<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href="#creation">создании собственного bem-js-компонента</a> написано ниже.</p>
<p><a name="mods"></a></p>
<h3 id="Работа-с-модификаторами-блока">Работа с модификаторами блока</h3>
<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>
<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>
<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>
<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href="/blocks/i-bem/i-bem.jsdoc.md">референсе по BEM</a>.</p>
<p><a name="customization"></a></p>
<h3 id="Изменение-поведения-существующих-блоков">Изменение поведения существующих блоков</h3>
<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>
<h4 id="Переопределение-поведения">Переопределение поведения</h4>
<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-dropdowna&#39;, {

    onSetMod : {

        &#39;js&#39; : function() {

            this._getSwitcher().on(&#39;click&#39;, this._on, this);

        }
    },
    _on : function() {
        this.getPopup().show(this.elem(&#39;switcher&#39;));
    }
});
</code></pre>
<h4 id="Расширение-поведения">Расширение поведения</h4>
<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>
<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>
<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>
<pre><code class="lang-js">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {
    _onClick : function() {
         this
            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link
            .setMod(&#39;status&#39;, &#39;clicked&#39;);
    }
});
</code></pre>
<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>
<pre><code class="lang-css">.b-link_status_clicked
{
    color: red;
}
</code></pre>
<h4 id="Кастомизация-с-использованием-модификаторов">Кастомизация с использованием модификаторов</h4>
<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>
<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>
<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {
    _onClick : function() {
         this
            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link
            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);
    }
});
</code></pre>
<p><a name="creation"></a></p>
<h3 id="Создание-js-компонента-для-собственного-блока-или-собственной-модификации">Создание js-компонента для собственного блока или собственной модификации</h3>
<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>
<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>
<p><a name="dom.decl"></a></p>
<h4 id="Декларация-блока">Декларация блока</h4>
<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>
<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>
<p>Хелпер декларации блока принимает 3 параметра:</p>
<ol>
<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.</li>
<li>Методы и свойства экземпляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href="#mods.callbacks">функции обработки модификаторов</a>, так и <a href="#methods">кастомные методы блока</a>.</li>
<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href="#static.methods">Подробнее</a></li>
</ol>
<p>Например:</p>
<pre><code class="lang-js">BEM.DOM.decl(
    &#39;b-link&#39;, // имя блока
    {
        // методы и свойства экземпляра блока
    },
    {
        // статические методы и свойства блока
    });
</code></pre>
<p>и</p>
<pre><code class="lang-js">BEM.decl(&#39;i-request&#39;, {
    {
        // методы и свойства экземпляра блока
    },
    {
        // статические методы и свойства блока
});
</code></pre>
<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>
<pre><code class="lang-js">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {

    get : function() {
        this.__base(); // вызов одноименного метода из i-request
        doSomething();
    }

});
</code></pre>
<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>
<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>
<pre><code class="lang-js">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {

    show : function() {
        doSomething();
    }

});
</code></pre>
<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>
<p><a name="mods.callbacks"></a></p>
<h4 id="Реакция-на-изменение-модификаторов">Реакция на изменение модификаторов</h4>
<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>
<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>
<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>
<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>
<pre><code class="lang-js">{
    &#39;модификатор1&#39; : {

        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;

        ...

        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;

        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений

    },

    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений

    ...

    &#39;модификаторN&#39; : {

        &#39;значение1-модификатораN&#39; : function() { ... },

        ...

        &#39;значениеN-модификатораN&#39; : function() { ... }

    }

}
</code></pre>
<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>
<pre><code class="lang-js">{

    &#39;элемент1&#39; : {

        &#39;модификатор1&#39; : {

            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;

            ...

            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;

            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;

        }

    },

    ...

    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;

}
</code></pre>
<p>Параметры <code>callback</code>-функций:</p>
<ul>
<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>
<li><code>{String} modName</code> — имя модификатора</li>
<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>
<li><code>{String} curModVal</code> — текущее значение модификатора</li>
</ul>
<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>
<ul>
<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>
<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>
<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>
</ul>
<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>
<p>Например:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-menu&#39;, {

    onElemSetMod : {

        &#39;trigger&#39; : {

            &#39;state&#39; : function(elem, modName, modVal) {

                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение
                this
                    .toggleMod(
                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),
                        &#39;visibility&#39;,
                        &#39;visible&#39;,
                        modVal == &#39;opened&#39;)
                    .trigger(&#39;trigger&#39;, {
                        domElem : elem,
                        state : modVal
                    });

            }

        }

    },

    onTriggerClick : function(e) { // при клике на триггер

        e.preventDefault();
        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;

    }

}, {

    live : function() {

        this
            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;
                this.onTriggerClick(e);
            });

    }

});
</code></pre>
<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>
<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.
Если существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>
<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-square2&#39;, {

    onSetMod : {

        &#39;js&#39; : function() {

            var square = this;

            this.bindTo(&#39;click&#39;, function(){
                square.setMod(&#39;size&#39;, &#39;big&#39;);
            });

        },
        &#39;size&#39; : function() {
            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200

            this.afterCurrentEvent(function(){
                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400
            });
        }
    }

});
</code></pre>
<h5 id="Начало-работы-с-блоком--модификатор-`js`-">Начало работы с блоком (модификатор <code>js</code>)</h5>
<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-input&#39;, {

    onSetMod : {

        &#39;js&#39; : {

            &#39;inited&#39; : function() {

                this
                    .bindTo(this.elem(&#39;input&#39;), {
                        &#39;focus&#39; : this.onFocus,
                        &#39;blur&#39;  : this.onBlur
                    })

            }

        }

    }

});
</code></pre>
<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>
<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>
<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-input&#39;, {

    onSetMod : {

    &#39;js&#39; : function() { // конструктор b-form-input
        ...
        }

    }
});
</code></pre>
<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>
<p><a name="methods"></a></p>
<h4 id="Методы-блока">Методы блока</h4>
<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>
<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {
    ...
    toggle : function() {
        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);
    }
    ...
});
</code></pre>
<h5 id="Переопределение-и-доопределение-методов-блока">Переопределение и доопределение методов блока</h5>
<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href="#customization">Изменение поведения существующих блоков</a>.</p>
<p><a name="static.methods"></a></p>
<h4 id="Статические-методы-блока">Статические методы блока</h4>
<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>
<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>
<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href="#liveinit">инициализацию по требованию <code>liveinit</code></a>.</p>
<p><a name="init"></a></p>
<h3 id="Инициализация">Инициализация</h3>
<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>
<h4 id="Инициализация-блоков-с-DOM-представлением">Инициализация блоков с DOM-представлением</h4>
<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>data-bem</code>, и создаётся <code>js-объект</code> такого блока.</p>
<p><a name="bem.params"></a></p>
<h5 id="Формат-параметров-блока-в-data-bem">Формат параметров блока в data-bem</h5>
<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>data-bem</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>
<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>
<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{
    &#39;b-my-block&#39; : {}
}&quot;&gt;
..
&lt;/div&gt;
</code></pre>
<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block i-bem&quot; data-bem=&quot;{
    &#39;b-my-block&#39; : {
        &#39;points&#39; : [
            [1.67, 2.5],
            [-30, 2.07],
            [290, -0.39]
        ],
        &#39;title&#39; : &#39;Какое-то название&#39;,
    }
}&quot;&gt;
..
&lt;/div&gt;
</code></pre>
<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; data-bem=&quot;{
    &#39;b-my-block&#39; : {
        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title
    },
    &#39;b-my-second-block&#39; : {
        // У этого блока нет никаких опциональных параметров
    }
}&quot;&gt;
..
&lt;/div&gt;
</code></pre>
<h5 id="DOM-представление-инициализированного-блока">DOM-представление инициализированного блока</h5>
<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>
<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>
<p><code>DOM</code>-представление блока после инициализации:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; data-bem=&quot;{
    &#39;b-my-block&#39; : {
        &#39;name&#39; : &#39;b-my-block&#39;
    }
}&quot;&gt;
..
&lt;/div&gt;
</code></pre>
<p><code>DOM</code>-представление двух блоков после инициализации:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{
    &#39;b-my-block&#39; : {
        &#39;name&#39; : &#39;b-my-block&#39;,
    },
    &#39;b-my-second-block&#39; : {
        &#39;name&#39; : &#39;b-my-second-block&#39;
    }
}&quot;&gt;
</code></pre>
<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>
<pre><code class="lang-html">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; data-bem=&quot;{
    &#39;b-my-block&#39; : {
        &#39;name&#39; : &#39;b-my-block&#39;,
    },
    &#39;b-my-second-block&#39; : {
        &#39;name&#39; : &#39;b-my-second-block&#39;
    }
}&quot;&gt;
</code></pre>
<h4 id="Инициализация-блоков-без-DOM-представления">Инициализация блоков без DOM-представления</h4>
<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>
<p><a name="liveinit"></a></p>
<h3 id="Инициализация-по-требованию--liveInit-">Инициализация по требованию (liveInit)</h3>
<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.
Инициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.
Рассмотрим на примере блока <code>b-link</code>:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-link&#39;, {

    _onClick : function(e) {

        e.preventDefault();
        this.trigger(&#39;click&#39;);

    }

}, {

    live : function() {

        this.liveBindTo(&#39;click&#39;, function(e) {
            this._onClick(e);
        });

    }

});
</code></pre>
<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>
<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>
<p>Существует несколько хелперов для <code>live</code>-событий:</p>
<ul>
<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>
<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>
</ul>
<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.
Различие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>
<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>
<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>
<p><a name="finding"></a></p>
<h3 id="Методы-доступа-к-блокам-и-элементам">Методы доступа к блокам и элементам</h3>
<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>
<h4 id="Методы-поиска-блоков">Методы поиска блоков</h4>
<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>
<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-my-block&#39;, {
    onSetMod : {
        &#39;js&#39; : function() {
            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);
            checkbox.toggle();
        }
    }
});
</code></pre>
<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>
<ul>
<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>
<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>
<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>
</ul>
<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href="/blocks/b-smart-help/b-smart-help.md">b-smart-help</a>, <a href="blocks/b-screenshot/b-screenshot.md">b-screenshot</a> и <a href="blocks/b-dropdowna/b-dropdowna.md">b-dropdowna</a>.</p>
<h4 id="Методы-доступа-к-элементам">Методы доступа к элементам</h4>
<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>
<p>Например:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-form-input&#39;, {

    doSomething : function() {

        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint

    }

});
</code></pre>
<p>Можно искать элементы внутри блока с учетом модификатора:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-menu&#39;, {

    doSomething : function() {

        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current

    }

});
</code></pre>
<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>
<p><a name="events"></a></p>
<h3 id="Работа-с-событиями">Работа с событиями</h3>
<h4 id="События-на-блоках">События на блоках</h4>
<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>
<ul>
<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>
<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>
<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>
<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>
</ul>
<h4 id="live-события-на-блоках">live-события на блоках</h4>
<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>
<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>
<pre><code class="lang-js">BEM.DOM.decl(&#39;b-link-example&#39;, {

    onSetMod: {
        &#39;js&#39;: function() {
            var link = this.findBlockInside(&#39;b-link&#39;);
            BEM.blocks[&#39;b-link&#39;]
                .liveCtxBind(link.domElem,
                            &#39;click&#39;,
                            function(){
                                link.domElem.text(&#39;Кликнутая ссылка&#39;);
                            },
                            this);
        }
    }
},
{
    live: function() {
        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);
    }
}
);
</code></pre>
<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>
<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>
<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href="#blocks.finding">поиск блока относительно текущего</a> и <a href="#liveinit">live-инициалиация</a>.</p>
