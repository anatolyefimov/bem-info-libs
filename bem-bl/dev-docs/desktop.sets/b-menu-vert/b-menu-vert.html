<!doctype html><html class="page__root"><head><meta charset="utf-8"/><title></title><link rel="stylesheet" href="../undefined/_undefined.css"/><script src="//yandex.st/jquery/1.8.2/jquery.min.js"></script><script src="../undefined/_undefined.js"></script></head><body class="page"><div class="catalogue"><div class="block"><div class="header"><a class="link link_pos_right" href="../index/index.html">← каталог</a><span class="header__block-name">Блок b-menu-vert</span></div><div class="block__title"></div><div class="block__description static-text"><p>﻿Блок, создает разметку для вертикального меню. Построен на основе блока-хелпера ##i-menu##.</p>
<p>==== Простое вертикальное меню
В простейшем случае в ##BEMJSON## достаточно объявить блок и перечислить его элементы ##item## в свойстве ##content##:</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      content: &#39;Index&#39;
    },
    {
      elem: &#39;item&#39;,
      content: &#39;Contacts&#39;
    },
    ...
  ]
}
%%</p>
<p>В получившемся ##HTML## появляются не только узлы для блока и явно заданных элементов ##item##, но и
разметка для элементов ##layout## и ##layout-unit##, которые отвечают за геометрическую отрисовку блока.</p>
<p>В качестве контента элементов ##item## в простых случаях используются ссылки:</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      content: {
        block: &#39;b-link&#39;,
        url: &#39;<a href="http://yandex.com">http://yandex.com</a>&#39;,
        content: &#39;Index&#39;
      }
    },
    ...
  ]
}
%%</p>
<p>У одного из элементов ##item## может быть модификатор ##{ state: &#39;current&#39; }##,
отмечающий выделенный пункт меню. Модификатор используется как для визуального выделения
пункта при помощи ##CSS##-правил для этого модификатора, так и для описания функционального
поведения.</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      elemMods: { state: &#39;current&#39; },
      content: {
        block: &#39;b-link&#39;,
        url: &#39;<a href="http://yandex.com">http://yandex.com</a>&#39;,
        content: &#39;Index&#39;
      }
    },
    {
      elem: &#39;item&#39;,
      content: { ... }
  ]
}
%%</p>
<p>Для отображения заголовка меню (элемент ##title##), в ##BEMJSON## необходимо указать свойство ##title##:</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  title: {
    elem: &#39;title&#39;,
    content: &#39;Menu title&#39;
  },
  content: [
    {
      elem: &#39;item&#39;,
      elemMods: { state: &#39;current&#39; },
      content: {
        block: &#39;b-link&#39;,
        url: &#39;<a href="http://yandex.com">http://yandex.com</a>&#39;,
        content: &#39;Index&#39;
      }
    },
    {
      elem: &#39;item&#39;,
      content: { ... }
  ]
}
%%</p>
<p>Предусмотрена возможность создания пустого элемента списка для визуального
разделения одних пунктов от других. За это отвечает элемент ##separator##.
Для этого на уровне переопределения проекта нужно задать ##CSS##-правила для него.
Чаще всего ##separator## представляют в виде горизонтальной черты.</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      content: { ... }
    },
    {
      elem: &#39;separator&#39;
    },
    {
      elem: &#39;item&#39;,
      content: { ... }
    }
  ]
}
%%</p>
<p>==== Вертикальное js-меню с псевдоссылками</p>
<p>В ##BEMJSON## доопределяем обычные ссылки до псевдо-ссылок, используя модификатор ##{ pseudo: &#39;yes&#39; }##:</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      elemMods: { &#39;state&#39;: &#39;current&#39; },
      content: {
        block: &#39;b-link&#39;,
        mods: { &#39;pseudo&#39;: &#39;yes&#39; },
        content: &#39;First point&#39;
      }
    },
    ...
  ]
}
%%</p>
<p>Кроме внешнего вида, ##js##-меню отличается и клиентской функциональностью: оно
способно по клику левой кнопкой мыши переключать соответствующий пункт меню
в состояние ##{ state: &#39;current&#39; }## и генерировать на ##js##-объекте, соответствующем блоку,
событие о факте переключения пункта меню.</p>
<p>Для использования этой функциональности необходимо определить ((#__item-selector элементы ##item-selector##)). Эти элементы специально не совпадают
с элементами ##item##, потому что чаще всего сам пункт меню больше по размеру, чем его активная область.</p>
<p>Элемент ##item-selector## можно использовать как сам по себе, так и примешивая его
к другим элементам или блокам. В данном случае можно сделать ##mix## с псевдоссылками:</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      elemMods: { &#39;state&#39;: &#39;current&#39; },
      content: {
        block: &#39;b-link&#39;,
        mods: { &#39;pseudo&#39;: &#39;yes&#39; },
        mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;item-selector&#39; }],
        url: &#39;/&#39;,
        content: &#39;First point&#39;
      }
    },
    ...
  ]
}
%%</p>
<p>==== Вертикальное js-меню со сложным контентом</p>
<p>Пункты меню могут содержать не один, а несколько блоков.</p>
<p>Поскольку реакция на клик необходима для всего содержания пункта меню, элемент ##item-selector##
используется в таком случае в явном виде, являясь контейнером для содержания пункта меню.
В этом случае он представлен в ##DOM##-дереве узлом ##span##:</p>
<p>%%hl js
{
  elem: &#39;item&#39;,
  content: {
    elem: &#39;item-selector&#39;,
    content: [
      {
        block: &#39;b-link&#39;,
        mods: { &#39;pseudo&#39;: &#39;yes&#39;, &#39;inner&#39;: &#39;yes&#39; },
        mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;item-selector&#39; }],
        url: &#39;/&#39;,
        content: [
          {
            block: &#39;b-icon&#39;,
            url: &#39;/&#39;,
            alt: &#39;Yandex favicon&#39;
          },
          {
            elem: &#39;inner&#39;,
            content: &#39;Second point&#39;
          }
        ]
      },
      &#39; One more element here&#39;
    ]
  }
}
%%</p>
<p>==== Раскрывающееся вертикальное js-меню</p>
<p>Переключение активного пункта меню — не единственная реализованная
динамическая функциональность. Пункты меню также могут содержать элементы</p>
<h2 id="trigger-">trigger##, клик по которым открывает или скрывает дочерний контент. С помощью</h2>
<p>таких элементов можно реализовать скрывающиеся вложенные меню.</p>
<p>Так же, как и элемент ##item-selector##, элемент ##trigger## может использоваться
не явно, а через ##mix##.</p>
<p>%%hl js
{
  block: &#39;b-menu-vert&#39;,
  content: [
    {
      elem: &#39;item&#39;,
      elemMods: { state: &#39;current&#39; },
      content: &#39;Videos&#39;
    },
    {
      elem: &#39;item&#39;,
      content: {
        block: &#39;b-link&#39;,
        mods: { pseudo: &#39;yes&#39;, inner: &#39;yes&#39; },
        mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;trigger&#39; }],
        content: [
          {
            block: &#39;b-icon&#39;,
            mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;trigger-icon&#39; }],
            alt: &#39;trigger&#39;
          },
          {
            elem: &#39;inner&#39;,
            content: &#39;Images&#39;
          }
        ]
      },
      &#39;item-content&#39;: {
        elem: &#39;item-content&#39;,
        content: {
          block: &#39;b-menu-vert&#39;,
          mods: { &#39;type&#39;: &#39;submenu&#39; },
          content: [
            {
              elem: &#39;item&#39;,
              content: &#39;Any size&#39;
            },
            {
              elem: &#39;item&#39;,
              content: &#39;Large&#39;
            },
            {
              elem: &#39;item&#39;,
              content: &#39;Medium&#39;
            }
          ]
        }
      }
    },
    ...
  ]
}
%%</p>
<p>Кроме элемента ##item-selector## здесь используется свойство ##item-content##, описывающее
элемент ##item-content## с содержанием, которое показывается или скрывается в зависимости
от кликов по элементу ##item-selector##.</p>
<p>Элемент ##trigger-icon## используется только для обозначения иконки. Не является обязательным элементом.</p>
<p>По умолчанию элемент ##trigger## не содержит модификатора ##state##, а элемент ##item-content##
не содержит модификатора ##visibility##. В этом состоянии содержание элемента ##item-content## не видно.\
При клике на элементе ##trigger## левой кнопкой мыши он приобретает модификатор</p>
<h2 id="-state-opened-item-content-">{ state: &#39;opened&#39; }##. Элемент ##item-content## в это же время приобретает</h2>
<p>модификатор ##{ visibility: &#39;visible&#39; }## и становится виден на странице.</p>
<p>Если нужно сразу показать вложенное меню раскрытым, эти модификаторы
следует явно задать в ##BEMJSON##-описании блока:</p>
<p>%%hl js
{
  block: &#39;b-link&#39;,
  mods: { pseudo: &#39;yes&#39;, inner: &#39;yes&#39; },
  mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;trigger&#39;, elemMods: { state: &#39;opened&#39; } }],
  content: { ... }
}
%%</p>
<p>%%hl js
&#39;item-content&#39;: {
  elem: &#39;item-content&#39;,
  elemMods: { visibility: &#39;visible&#39; },
  content: [ ... ]
%%</p>
<p>==== Вложенные меню</p>
<h2 id="bemjson-">BEMJSON## позволяет вкладывать одни блоки в другие. Содержанием пункта меню может быть</h2>
<p>другое меню, и тогда естественным образом образуется вложенность.\
Такое использование меню создаст в ##DOM##-дереве два блока (и два узла ##ul##), которые
будут вести себя соответственно.</p>
<p>Если есть необходимость визуально представить меню как вложенное, но функционально —
как один блок (например, со сквозным поведением активного пункта меню), нужно
воспользоваться элементом ##submenu##.</p>
<p>Элемент ##submenu## должен содержаться в элементе ##item-content## и включать в
себя описание элементов ##item## для вложеннего меню.</p>
<p>Элемент вертикального меню, может содержать любой контент, чаще всего это ссылки или псевдо-ссылки.\
Имеет состояния: ##[ current, disabled ]##</p>
<p>﻿Не используется без элемента ##item-selector##. По умолчанию невидим.
﻿Добавление этого модификатора делает видимым элемент ##item-content##.</p>
<p>﻿Этот элемент появляется в меню, когда требуется реакция на клик по
пункту меню.\
Реакция на клик может понадобиться, если при выборе пункта меню нужно
что-то сделать на клиенте. Например, загрузить контент по ##AJAX##.</p>
<p>Реакция есть только на клик левой кнопкой мыши. В результате клика соответствующий
пункт меню (элемент ##item##) приобретает модификатор ##{ state: &#39;current&#39; }##, то
есть пункт меню становится «выделенным» (текущим). Предыдущий выделенный пункт меню в то же время
теряет модификатор ##state##.\
В базовой ##CSS##-реализации блока не предоставляется код для визуального
выделения текущего пункта меню. Такой код можно реализовать на собственном уровне
переопределения.</p>
<p>Элемент может быть представлен в ##DOM## отдельным узлом (##span##) или быть
смиксованным с другим блоком, чаще всего с псевдо-ссылкой.</p>
<p>Используется в случае, когда необходимо представить вложенное меню
частью списка «меню-родителя».</p>
<p>Опциональный элемент. В ##HTML## представлен тегом ##h3##, выводится перед списком (##ul##).
Может содержать внутри себя опциональный элемент ##trigger-icon##, который используется для отображения иконок.</p>
</div></div></div></body></html>