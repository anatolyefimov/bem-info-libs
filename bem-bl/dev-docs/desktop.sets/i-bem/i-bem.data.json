{"name":"i-bem","description":[{"content":"<p>Блок ##i-bem## — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях ##BEMHTML## и ##JS##. Обе эти реализации\nявляются ядром библиотеки блоков в соответствующих технологиях.</p>\n<p>=== js-реализация блока i-bem</p>\n<p>Реализация блока ##i-bem## в ##JS## обеспечивает хелперы для представления\nблока в виде ##JS## объекта с определёнными методами и свойствами. Это нужно, чтобы\nписать клиентский ##JS## в терминах ##BEM##. То есть ##JS## оперирует более высоким уровнем\nабстрации, чем ##DOM## представление.</p>\n<p>Для того, чтобы js-представление блока использовало ядро ##i-bem##, оно должно\nбыть написано с соблюдением специальных правил.</p>\n<p>===== Что описано на этой странице?</p>\n<ul>\n<li>Какие бывают блоки<ul>\n<li>((#dom.blocks Блоки с DOM-представлением))</li>\n<li>((#abstract.blocks Блоки без DOM-представления))</li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li>((#decl Декларативный принцип))</li>\n<li>((#block.getting Доступ к другим блокам))</li>\n<li>((#mods Работа с модификаторами))</li>\n<li>((#customization Кастомизация блоков))</li>\n</ul>\n</li>\n<li>((#creation Создание собственного bem-js блока))</li>\n<li>Подробнее о понятиях<ul>\n<li>((#init Инициализация))</li>\n<li>((#liveinit Инициализация по требованию (live-инициализация~)))</li>\n<li>((#finding Методы доступа к блокам и элементам))</li>\n<li>((#events Работа с событиями))</li>\n</ul>\n</li>\n</ul>\n<p>%%hl xml\n<a name=\"dom.blocks\"></a>\n%%\n===== Блоки с DOM-представлением\nБлокам, реализованным на ##bem-js##, могут соответствовать ноды в ##HTML##. В этом случае говорится о\nтом, что блоки имеют ##DOM## представление.\\\nВ ##HTML## блоки на ##bem-js## отличаются дополнительным ##CSS## классом ##i-bem##\nи специальным форматом записи параметров блока в ##onclick##:</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block i-bem\" onclick=\"return { 'b-my-block' : { name : 'b-my-block'}}\">\n...\n</div>\n%%</p>\n<p>Ниже подробно рассказано о ((#onclick.params формате параметров в onclick)).</p>\n<p>%%hl xml\n<a name=\"abstract.blocks\"></a>\n%%\n===== Блоки без DOM-представления\nТехнология ##bem-js## позволяет также создавать блоки, не имеющие ##DOM## представления.\nТакие блоки тем не менее существуют в ##JS## в виде объектов, манипулировать ими\nможно так же, как и блоками с ##DOM## представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком\n((#dom.decl Декларация блока)).</p>\n<p>Блоки, реализованные на ##bem-js##,  после инициализации представлены в ##js## объектами,\nимеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний\nвид или поведение блока.\\\nТехнология ##bem-js## использует предметную область ((<a href=\"http://wiki.yandex-team.ru/lento4ka/bem\">http://wiki.yandex-team.ru/lento4ka/bem</a> концепции ##BEM##)).\nВсе сущности являются\nблоками или их элементами, управление их состояниями реализуется при помощи модификаторов.\\\nПредставление блока в ##js## не обязано иметь взаимное соответствие с одной ##DOM##-нодой.\nМожно разместить несколько\nблоков на одной ##DOM##-ноде (это называется ##mix##), а также реализовать один блок на нескольких ##DOM##-нодах.\\\nДалее блок, использующий технологию ##bem-js##,\nбудет называться ##блок, реализованный на bem-js##, или ##bem-js-блок##. Примером такого\nблока в библиотеке может служить ##b-link##.</p>\n<p>%%hl xml\n<a name=\"decl\"></a>\n%%\n=== Декларативный принцип</p>\n<p>Важной особенностью технологии ##bem-js## является декларативный принцип. Подобно\nработе декларативных языков программирования, ##js##-код содержит не последовательный\nалгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<p>==== Декларация блока\nДекларативность проявляется в объявлении того, к каким блокам или их модификациям\nприменим код компонента:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-link&#39;, {\n...\n%%</p>\n<p>%%hl js\nBEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n...\n%%</p>\n<p>((#dom.decl Подробнее о декларации блока))</p>\n<p>%%hl xml\n<a name=\"mods.reaction\"></a>\n%%\n==== Реакция на изменение модификаторов\nСогласно концепции, состояния блока или его элементов определяются модификаторами.\nПоэтому, чтобы динамически изменять состояния блоков и элементов, в ##bem-js## есть\nспециальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора.\nЭта запись тоже декларативна.\\\nНапример, блок ##b-dropdowna## при установке модификатора ##disabled## прячет показанный попап:\n%%hl js\nBEM.DOM.decl(&#39;b-dropdowna&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;disabled&#39; : function(modName, modVal) {\n\n        this._getSwitcher().setMod(modName, modVal);\n        modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n\n    }\n\n},\n</code></pre><p>...\n%%</p>\n<p>Подробно ((#mods.callbacks о декларации обработки модификаторов)) рассказано в пункте про создание собственного блока.</p>\n<p>%%hl xml\n<a name=\"block.getting\"></a>\n%%\n=== Доступ к другим блокам</p>\n<p>Может возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к ##js##-объекту этого блока и вызывать его методы.</p>\n<p>%%hl xml\n<a name=\"blocks.finding\"></a>\n%%\n==== Доступ к bem-js-блоку из другого bem-js-блока.</p>\n<p>В случае ((#creation реализации собственного кастомного блока на технологии ##bem-js##)),\nблоку соответствует ##js##-объект. Он наследует общие для всех блоков методы, позволяющие работать с ##DOM## документа в\nтерминах ##BEM##. Среди этих методов есть методы поиска других блоков относительно текущего (##findBlock<em>##-методы).\nОни возвращают ##js##-объект искомого блока, что позволяет затем напрямую вызывать его методы.\\\n<em>*Не используйте ##jQuery##-селекторы для поиска блоков и элементов.</em></em></p>\n<p>В этом примере вызывается метод ##val()## у блока ##b-form-checkbox##:\n%%hl js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {</p>\n<pre><code>onSetMod: {\n    &#39;js&#39;: function() {\n        var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n        this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n    }\n}\n</code></pre><p>}\n);\n%%</p>\n<p>==== Доступ к bem-js-блоку не из bem-js-блока</p>\n<p>В случае работы не из ##bem-js-блока##, методы ##findBlock<em>## недоступны. ##js##-объект блока можно\nполучить, используя метод ##.bem()## ##jQuery## коллекции:\n%%hl js\n$(уникальный селектор).bem(&#39;b-link&#39;);\n%%\nЭтот способ <em>*не рекомендован</em></em>. Лучшим вариантом работы с блоками, реализованными на ##i-bem##,\nявляется создание собственного компонента на ##i-bem##. Подробнее о ((#creation создании собственного\nbem-js-компонента)) написано ниже.</p>\n<p>%%hl xml\n<a name=\"mods\"></a>\n%%\n=== Работа с модификаторами блока</p>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку\nможно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще).\nУ модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора.\nНапример, для того, чтобы сделать чекбокс выделенным в блоке ##b-form-checkbox##, ему\nнужно установить модификатор ##checked## в значение ##yes##.\\\nНа странице документации каждого блока есть список его элементов и модификаторов.\nИз этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя ##CSS## класс на соответствующей ##DOM##-ноде. Для\nкорректной работы ##js## все манипуляции с модификаторами должны производиться при помощи\nметода-хелпера ##setMod()##. Также существуют методы ##hasMod()##, ##getMod##/##getMods()##, ##toggleMod()##\nи ##delMod()##. Сигнатуры этих методов доступны в ((/blocks/i-bem/i-bem.jsdoc.wiki референсе по BEM)).</p>\n<p>%%hl xml\n<a name=\"customization\"></a>\n%%\n=== Изменение поведения существующих блоков</p>\n<p>Используя ##bem-js##, можно переопределять и доопределять\nметоды блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации\nблоков на ##CSS## или ##BEMHTML##.</p>\n<p>==== Переопределение поведения\nНапример, на сервисе существует необходимость модифицировать все блоки ##b-dropdowna## так, чтобы\nони не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения\nсервиса нужно сделать файл ##blocks/b-dropdowna/b-dropdowna.js##, кастомизирующий поведение блока\nиз библиотеки:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-dropdowna&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;js&#39; : function() {\n\n        this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n    }\n},\n_on : function() {\n    this.getPopup().show(this.elem(&#39;switcher&#39;));\n}\n</code></pre><p>});\n%%</p>\n<p>==== Расширение поведения\nВ предыдущем примере код кастомизации полностью переопределяет поведение\nблока. Технология ##bem-js## позволяет также реализовывать «доопределение»\nблока. Для этого в методах кастомизирующего кода можно вызывать ##this._~_base.apply()##,\nпередавая в качестве аргументов ##this## и ##arguments##. Вызов такого метода аналогичен\nиспользованию ##<xsl:apply-imports/>##.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков ##b-link##\nна проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла ##blocks/b-link/_pseudo/b-link_pseudo_yes.js##\n%%hl js\nBEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n%%</p>\n<p>Содержание файла ##blocks/b-link/_status/b-link_status_clicked.css##</p>\n<p>%%hl xml\n.b-link_status_clicked\n{\n    color: red;\n}\n%%</p>\n<p>==== Кастомизация с использованием модификаторов</p>\n<p>Предыдущие примеры кастомизации изменяют поведение //всех// определенных блоков на странице.\nНо очень часто возникает задача кастомизации конкретного блока без влияния на\nповедение всех таких блоков. Согласно концепции ##BEM##,\nесли блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно\nреализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдоссылку, приобретающую красный цвет после первого\nклика, сделаем модификацию ##reaction_odd##. Псевдоссылка с таким модификатором\nприобретает красный цвет после каждого\nнечётного клика, а после каждого чётного возвращается к исходному цвету .</p>\n<p>Содержание файла ##blocks/b-link/_reaction/b-link_reaction_odd.js##:\n%%hl js\nBEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n%%</p>\n<p>%%hl xml\n<a name=\"creation\"></a>\n%%</p>\n<p>=== Создание js-компонента для собственного блока или собственной модификации</p>\n<p>Рекомендованным способом работы с ##bem-js-блоками## является создание собственных ##bem-js-блоков##\n(чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные</p>\n<h2 id=\"bem-js-\">bem-js-блоки## могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.\\</h2>\n<h2 id=\"js-\">js-код## блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением</h2>\n<h2 id=\"-js-js-\">.js##. Если ##js-реализация## относится не к блоку, а лишь к одной из его модификаций, можно</h2>\n<p>разместить код в ##js-файле##, соответствующем данному модификатору.</p>\n<p>%%hl xml\n<a name=\"dom.decl\"></a>\n%%\n==== Декларация блока</p>\n<p>Создание ##js-компонента## блока сводится к его декларации с помощью специальных хелперов.\nСуществуют два хелпера для декларации блоков: один для блоков, которые имеют ##DOM##-представление,\nвторой — для блоков, не имеющих ##DOM## представления (например ##i-request##, ##i-update-session##).</p>\n<p>В первом случае блоки декларируются с помощью ##BEM.DOM.decl##, во втором — с помощью ##BEM.decl##.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр\\\nПервым параметром может быть либо строка с именем\nблока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому\nтипу блоков применять компонент.</li>\n<li>Методы и свойства экземляра блока\\\nМетоды и свойства, предметной областью которых является конкретный инстанс блока\nна странице. Это как ((#mods.callbacks функции обработки модификаторов)),\nтак и ((#methods кастомные методы блока)).</li>\n<li>Статические методы и свойства\\\nМетоды и свойства, не относящиеся к конкретному инстансу блока. ((#static.methods Подробнее))</li>\n</ol>\n<p>Например:\n%%hl js\nBEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n%%</p>\n<p>и</p>\n<p>%%hl js\nBEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n%%</p>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:\n%%hl js\nBEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {</p>\n<pre><code>get : function() {\n    this.__base(); // вызов одноименного метода из i-request\n    doSomething();\n}\n</code></pre><p>});\n%%\nТут указано, что блок ##b-dataprovider## наследуется от блока ##i-request## и переопределяет его метод ##get##.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку\nприменить компонент, но и уточнён модификатор и/или его значение:\n%%hl js\nBEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {</p>\n<pre><code>show : function() {\n    doSomething();\n}\n</code></pre><p>});\n%%\nВсе методы, описанные в такой декларации, будут вызываться для таких блоков ##b-popup##,\nкоторые в данный момент имеют модификатор ##type##, установленный в ##inplace##.</p>\n<p>%%hl xml\n<a name=\"mods.callbacks\"></a>\n%%\n==== Реакция на изменение модификаторов</p>\n<p>Согласно концепции ##BEM## состояния блоков и его элементов\nопределяются модификаторами. Блок может сам назначать себе или своему элементу модификатор,\nили получать это назначение из другого блока.\\\nВо время того, как блок или элемент получил определённый модификатор, может возникнуть\nнеобходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных\nсвойства: ##onSetMod## и ##onElemSetMod##, где описываются ##callback##-функции,\nвызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание ##callback##-функций для ##onSetMod## представляет собой хеш вида:\n%%hl js\n{\n    &#39;модификатор1&#39; : {</p>\n<pre><code>    &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n    ...\n\n    &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n    &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n},\n\n&#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n...\n\n&#39;модификаторN&#39; : {\n\n    &#39;значение1-модификатораN&#39; : function() { ... },\n\n    ...\n\n    &#39;значениеN-модификатораN&#39; : function() { ... }\n\n}\n</code></pre><p>}\n%%</p>\n<p>Описание ##callback##-функций для ##onElemSetMod## аналогично, за исключением того, что на верхнем уровне указывается имя элемента:\n%%hl js\n{</p>\n<pre><code>&#39;элемент1&#39; : {\n\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n    }\n\n},\n\n...\n\n&#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n</code></pre><p>}\n%%</p>\n<p>Параметры ##callback##-функций:</p>\n<ul>\n<li><h2 id=\"-jquery-elem-\">{jQuery} [elem]## — элемент блока (если установка модификатора была для элемента)</h2>\n</li>\n<li><h2 id=\"-string-modname-\">{String} modName## — имя модификатора</h2>\n</li>\n<li><h2 id=\"-string-modval-\">{String} modVal## — устанавливаемое значение модификатора</h2>\n</li>\n<li><h2 id=\"-string-curmodval-\">{String} curModVal## — текущее значение модификатора</h2>\n</li>\n</ul>\n<p>Порядок вызовов ##callback##-функций при установке модификатора ##modVal## в значение ##modName##:</p>\n<ul>\n<li>вызывается ##callback##-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается ##callback##-функция на установку модификатора ##modVal## в любое значение (если она существует)</li>\n<li>вызывается ##callback##-функция на установку модификатора ##modVal## в значение ##modName## (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет ##false##, то установки модификатора не произойдет.</p>\n<p>Например:\n%%hl js\nBEM.DOM.decl(&#39;b-menu&#39;, {</p>\n<pre><code>onElemSetMod : {\n\n    &#39;trigger&#39; : {\n\n        &#39;state&#39; : function(elem, modName, modVal) {\n\n            // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n            this\n                .toggleMod(\n                    this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                    &#39;visibility&#39;,\n                    &#39;visible&#39;,\n                    modVal == &#39;opened&#39;)\n                .trigger(&#39;trigger&#39;, {\n                    domElem : elem,\n                    state : modVal\n                });\n\n        }\n\n    }\n\n},\n\nonTriggerClick : function(e) { // при клике на триггер\n\n    e.preventDefault();\n    this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n}\n</code></pre><p>}, {</p>\n<pre><code>live : function() {\n\n    this\n        .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n            this.onTriggerClick(e);\n        });\n\n}\n</code></pre><p>});\n%%</p>\n<h2 id=\"-togglemod-ontriggerclick-callback-onelemsetmod-\">В данном примере при вызове ##toggleMod## внутри ##onTriggerClick## будет вызвана соответствущая ей ##callback##-функция из ##onElemSetMod##.</h2>\n<h2 id=\"callback-\">Callback## функции, реагирующие на изменение модификатора, выполняются до установки модификатора.</h2>\n<p>Если существует необходимость выполнить часть кода после установки модификатора,\nнужно воспользоваться методом ##.afterCurrentEvent()##.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки\nмодификатора:\n%%hl js\nBEM.DOM.decl(&#39;b-square2&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;js&#39; : function() {\n\n        var square = this;\n\n        this.bindTo(&#39;click&#39;, function(){\n            square.setMod(&#39;size&#39;, &#39;big&#39;);\n        });\n\n    },\n    &#39;size&#39; : function() {\n        this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n        this.afterCurrentEvent(function(){\n            this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n        });\n    }\n}\n</code></pre><p>});\n%%</p>\n<p>===== Начало работы с блоком (модификатор ##js##)</p>\n<p>Блок начинает свою работу с действий, описанных в ##callback##-функции на установку его модификатора ##js## в значение ##inited##:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-form-input&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;js&#39; : {\n\n        &#39;inited&#39; : function() {\n\n            this\n                .bindTo(this.elem(&#39;input&#39;), {\n                    &#39;focus&#39; : this.onFocus,\n                    &#39;blur&#39;  : this.onBlur\n                })\n\n        }\n\n    }\n\n}\n</code></pre><p>});\n%%</p>\n<p>Этот модификатор присваивается блоку в момент инициализации.\nПоскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик\nи является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим</p>\n<h2 id=\"dom-dom-\">DOM## представление, так и блокам без него. Так что, у блоков без ##DOM## представления</h2>\n<p>первый исполняемый метод также задаётся как ##callback## модификатора ##js_inited##.</p>\n<p>В коде блоков можно встретить ##callback## функцию не на значение ##inited## модификатора</p>\n<h2 id=\"js-js-\">js##, а на установку модификатора ##js## в любое значение:</h2>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-form-input&#39;, {</p>\n<pre><code>onSetMod : {\n\n&#39;js&#39; : function() { // конструктор b-form-input\n    ...\n    }\n\n}\n</code></pre><p>});\n%%</p>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок\nне имеет модификатора ##js##, а в момент инциализации приобретает значение ##inited##.\nДругие значения модификатора сейчас не предусмотрены.</p>\n<p>%%hl xml\n<a name=\"methods\"></a>\n%%\n==== Методы блока</p>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы.\nОпределённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод ##.toggle()## блока ((/blocks/b-form-checkbox/b-form/checkbox.wiki b-form-checkbox)):</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n%%</p>\n<p>===== Переопределение и доопределение методов блока</p>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён.\nОб этом написано выше в пункте ((#customization Изменение поведения существующих блоков)).</p>\n<p>%%hl xml\n<a name=\"static.methods\"></a>\n%%\n==== Статические методы блока\nТретий параметр, передаваемый в функцию декларации блока, -- это хеш статических\nметодов блока.</p>\n<p>Примером блока, использующего статические методы, может служить\n((/blocks/b-flash/b-flash.wiki)).</p>\n<p>Для каждого блока может быть определен статический метод ##live##, позвляющий реализовать\n((#liveinit инициализацию по требованию (liveinit~))).</p>\n<p>%%hl xml\n<a name=\"init\"></a>\n%%\n=== Инициализация</p>\n<p>Для того, чтобы у блока появился ##js-объект##, описанный в декларации, происходит процесс инициализации\nблока.\nИнициализация блоков производится функцией ##BEM.DOM.init()## на фрагменте ##DOM## дерева.\nЕсли элемент ##i-bem_~_dom## задекларирован с модификатором ##init_auto## (подключается файл</p>\n<h2 id=\"i-bem_-_dom_init_auto-js-\">i-bem_~_dom_init_auto.js##), то инициализация блоков происходит на всём документе по событию</h2>\n<p>domReady. Также функцию ##BEM.DOM.init## можно вызвать самостоятельно. Например, это делается\nдля инициализации блоков после динамического изменения страницы, если появились новые блоки с js-представлением.</p>\n<p>==== Инициализация блоков с DOM-представлением\nДля инициализации блоков, представленных в ##DOM##, на фрагменте дерева ищутся все блоки,\nпомеченные классом ##i-bem##, у них считываются параметры из атрибута ##onclick##, и\nсоздаётся ##js-объект## такого блока.</p>\n<p>%%hl xml\n<a name=\"onclick.params\"></a>\n%%\n===== Формат параметров блока в onclick\nПараметры для блока записываются в виде возвращаемого атрибутом ##onclick## хеша.\nЭтот хеш должен содержать элементы с названиями, соответствующими названиям блоков,\nк которым они относятся. Значением каждого элемента должен быть вложенный хеш c\nпараметрами.\\\nТакая запись позволяет задавать параметры для нескольких блоков в том случае, если\nони представлены в ##HTML## одной и той же ##DOM-нодой##.</p>\n<p>Вот как выглядит ##DOM-нода## произвольного блока, реализованного на ##bem-js##:</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block i-bem\" onclick=\"return {\n    'b-my-block' : {}\n}\">\n..\n</div>\n%%</p>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и\nэлемент ##name##. Формат параметра может быть любым: строка, число, массив, хеш, функция.\nКоличество параметров также не ограничено.</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'points' : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        'title' : 'Какое-то название',\n    }\n}\">\n..\n</div>\n%%</p>\n<p>Для нескольких блоков на одной ##DOM-ноде## ##HTML## представление будет аналогично следующему:</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block b-my-second-block i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'title' : 'Какое-то название', // Этот блок имеет опцинальный параметр title\n    },\n    'b-my-second-block' : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}\">\n..\n</div>\n%%</p>\n<p>===== DOM-представление инициализированного блока\nПосле инициализации ##DOM## представление блока изменяется: у блока появляется дополнительный\nмодификатор ##js_inited##.\\\nЕсли ##DOM-ноде## соответствуют несколько блоков, то появление модификатора у одного из них\nсвидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p>DOM-представление блока после инициализации:\n%%hl xml</p>\n<p><div class=\"b-my-block b-my-block_js_inited i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'name' : 'b-my-block'\n    }\n}\">\n..\n</div>\n%%</p>\n<h2 id=\"dom-\">DOM## представление двух блоков после инициализации:</h2>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'name' : 'b-my-block',\n    },\n    'b-my-second-block' : {\n        'name' : 'b-my-second-block'\n    }\n}\">\n%%</p>\n<h2 id=\"dom-\">DOM## представление двух блоков, но инициализован только один из них:</h2>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block b-my-second-block b-my-second-block_js_inited i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'name' : 'b-my-block',\n    },\n    'b-my-second-block' : {\n        'name' : 'b-my-second-block'\n    }\n}\">\n%%</p>\n<p>==== Инициализация блоков без DOM-представления</p>\n<p>В том случае, если у блока нет ##DOM## представления, в процессе инициализации просто возникает</p>\n<h2 id=\"js-\">js-объект##, соответствующий этому блоку. Дальнейшее зависит от кода блока.</h2>\n<p>%%hl xml\n<a name=\"liveinit\"></a>\n%%\n=== Инициализация по требованию (liveInit)\nМногим блокам (например, ##b-link##, ##b-dropdown##, ##b-smart-help##) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока ##b-link##:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-link&#39;, {</p>\n<pre><code>_onClick : function(e) {\n\n    e.preventDefault();\n    this.trigger(&#39;click&#39;);\n\n}\n</code></pre><p>}, {</p>\n<pre><code>live : function() {\n\n    this.liveBindTo(&#39;click&#39;, function(e) {\n        this._onClick(e);\n    });\n\n}\n</code></pre><p>});\n%%</p>\n<p>В статических свойствах блока предусмотрено специальное свойство ##live## (##Function##|##Boolean##), отвечающее за инициализацию по требованию и за\nподписку на ##live## события на ##DOM## элементах внутри такого блока.</p>\n<p>Если ##live## определено как ##Function##, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для ##live## событий:</p>\n<pre><code>* ##liveInitOnEvent## — хелпер для инициализации блока по событию на блоке или его внутреннем элементе\n* ##liveBindTo## — подписка на события на блоке или его внутреннем элементе\n</code></pre><p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что ##callback## функция в ##liveInitOnEvent## вызывается только один раз после инициализации блока,\nа в ##liveBindTo## она будет вызываться при каждом событии.\nКонтекстом такой ##callback## функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок ##b-link## будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же ##live## определено как ##Boolean## и установлено в ##true##,\nто такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска ##findBlockInside##/##findBlockOutside##.</p>\n<p><a name=\"finding\"></a>\n=== Методы доступа к блокам и элементам</p>\n<p>Работая с блоками, реализованными на ##bem-js##, необходимо использовать\nвстроенные методы для поиска блоков и их элементов. Эти методы доступны\nв каждом блоке и умеют возвращать другой блок или ##jQuery## коллекцию (в случае\nпоиска элементов).</p>\n<p>==== Методы поиска блоков</p>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов</p>\n<h2 id=\"findblock-\">findBlock*##.</h2>\n<p>Реализуем блок ##b-my-block##, который находит первый из блоков ##b-form-checkbox##\nвнутри себя и вызывает у него метод ##toggle()## для переключения чекбокса.\n%%hl js\nBEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n%%</p>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><h2 id=\"findblockinside-findblocksinside-dom-\">findBlockInside/findBlocksInside## — поиск блока/блоков внутри ##DOM## элементов текущего блока или его элементов</h2>\n</li>\n<li><h2 id=\"findblockon-findblockson-dom-\">findBlockOn/findBlocksOn## — поиск блока/блоков на ##DOM## элементах текущего блока или его элементов</h2>\n</li>\n<li><h2 id=\"findblockoutside-findblocksoutside-dom-\">findBlockOutside/findBlocksOutside## — поиск блока/блоков снаружи ##DOM## элементов текущего блока или его элементов</h2>\n</li>\n</ul>\n<p>Список методов поиска блоков и их сигнатуры можно посмотреть в\n((/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki референсе по BEM.DOM)).</p>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть:\n((/blocks/b-smart-help/b-smart-help.wiki b-smart-help)),\n((blocks/b-screenshot/b-screenshot.wiki b-screenshot)) и\n((blocks/b-dropdowna/b-dropdowna.wiki b-dropdowna)).</p>\n<p>==== Методы доступа к элементам\nДля поиска элементов внутри блока используется метод ##elem##. Результат этого метода кэшируется.</p>\n<p>Например:\n%%hl js\nBEM.DOM.decl(&#39;b-form-input&#39;, {</p>\n<pre><code>doSomething : function() {\n\n    this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n}\n</code></pre><p>});\n%%</p>\n<p>Можно искать элементы внутри блока с учетом модификатора:\n%%hl js\nBEM.DOM.decl(&#39;b-menu&#39;, {</p>\n<pre><code>doSomething : function() {\n\n    this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n}\n</code></pre><p>});\n%%</p>\n<p>Некэширующий метод поиска элементов называется ##findElem()##.</p>\n<p>Полный список методов для поиска элементов и их сигнатуры можно найти в\n((/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki референсе по BEM.DOM)).</p>\n<p>%%hl xml\n<a name=\"events\"></a>\n%%\n=== Работа с событиями</p>\n<p>==== События на блоках</p>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не ##DOM##) событий:</p>\n<ul>\n<li><h2 id=\"on-e-data-fn-ctx-e\">on(e, [data], fn, [ctx])## — подписка на событие ##e</h2>\n</li>\n<li><h2 id=\"onfirst-e-data-fn-ctx-e\">onFirst(e, [data], fn, [ctx])## — подписка только на первое событие ##e</h2>\n</li>\n<li><h2 id=\"un-e-fn-ctx-e-\">un([e], [fn], [ctx])## — отписка от конкретного события ##e## или всех событий</h2>\n</li>\n<li><h2 id=\"trigger-e-data-e\">trigger(e, [data])## — нотификация о событии  ##e</h2>\n</li>\n</ul>\n<p>==== live-события на блоках</p>\n<p>В ##bem-js## есть события, реализованные по паттерну\nделегированных событий, они называются ##live## события.</p>\n<p>Следующий пример демонстрирует работу с live-событием ##click## для блоков ##b-link##,\nсодержащихся в определённой ##DOM-ноде##. В данном случае контейнер и блок совпадают:\n%%hl js\nBEM.DOM.decl(&#39;b-link-example&#39;, {</p>\n<pre><code>onSetMod: {\n    &#39;js&#39;: function() {\n        var link = this.findBlockInside(&#39;b-link&#39;);\n        BEM.blocks[&#39;b-link&#39;]\n            .liveCtxBind(link.domElem,\n                        &#39;click&#39;,\n                        function(){\n                            link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                        },\n                        this);\n    }\n}\n</code></pre><p>},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n%%</p>\n<p>Метод ##.liveCtxBind()## реализует возможность реакции на bem-события блоков,\nвложенных в какой-либо ##DOM## элемент. <strong>Это не DOM-события</strong>\\\nИспользование ##live## событий позволяет избежать лишнего поиска блоков в ##DOM## дереве.\nКроме того, при такой привязке к событию реакция на событие блока из контейнера будет\nпроисходить даже в том случае, если на момент привязки блока в контейнере не было, а он \nпоявился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к ##live## событию блока, здесь также продемонстрированы ((#blocks.finding поиск блока относительно текущего))\nи ((#liveinit live-инициалиация)).\\</p>\n"}],"examples":[{"url":"i-bem.examples/15-i-bem_click/_15-i-bem_click"},{"url":"i-bem.examples/17-i-bem_square/_17-i-bem_square"},{"url":"i-bem.examples/20-i-bem_liveinit-multiple/_20-i-bem_liveinit-multiple"},{"url":"i-bem.examples/40-i-bem_extend/_40-i-bem_extend"},{"url":"i-bem.examples/60-i-bem_pseudo-link/_60-i-bem_pseudo-link"}]}