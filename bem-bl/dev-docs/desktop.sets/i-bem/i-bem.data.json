{"name":"i-bem","description":[{"content":"<h2 id=\"-\">Описание</h2>\n<p>Блок <code>i-bem</code> — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях <code>BEMHTML</code> и <code>JS</code>. Обе эти реализации являются ядром библиотеки блоков в соответствующих технологиях.</p>\n<h3 id=\"js-i-bem\">js-реализация блока i-bem</h3>\n<p>Реализация блока <code>i-bem</code> в <code>JS</code> обеспечивает хелперы для представления блока в виде <code>JS</code>-объекта с определёнными методами и свойствами. Это нужно, чтобы писать клиентский <code>JS</code> в терминах <code>BEM</code>. То есть <code>JS</code> оперирует более высоким уровнем абстракции, чем <code>DOM</code>-представление.</p>\n<p>Для того, чтобы <code>JS</code>-представление блока использовало ядро <code>i-bem</code>, оно должно быть написано с соблюдением специальных правил.</p>\n<h5 id=\"-\">Что описано на этой странице?</h5>\n<ul>\n<li>Какие бывают блоки<ul>\n<li><a href=\"#dom.blocks\">Блоки с DOM-представлением</a></li>\n<li><a href=\"#abstract.blocks\">Блоки без DOM-представления</a></li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li><a href=\"#decl\">Декларативный принцип</a></li>\n<li><a href=\"#block.getting\">Доступ к другим блокам</a></li>\n<li><a href=\"#mods\">Работа с модификаторами</a></li>\n<li><a href=\"#customization\">Кастомизация блоков</a></li>\n</ul>\n</li>\n<li><a href=\"#creation\">Создание собственного блока bem-js</a></li>\n<li>Подробнее о понятиях<ul>\n<li><a href=\"#init\">Инициализация</a></li>\n<li><a href=\"#liveinit\">Инициализация по требованию (live-инициализация)</a></li>\n<li><a href=\"#finding\">Методы доступа к блокам и элементам</a></li>\n<li><a href=\"#events\">Работа с событиями</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"dom.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки с DOM-представлением</h5>\n<p>Блокам, реализованным на <code>bem-js</code>, могут соответствовать ноды в <code>HTML</code>. В этом случае говорится о том, что блоки имеют <code>DOM</code>-представление.</p>\n<p>В <code>HTML</code>-блоки на <code>bem-js</code> отличаются дополнительным <code>CSS</code>-классом <code>i-bem</code> и специальным форматом записи параметров блока в <code>onclick</code>:</p>\n<pre><code class=\"lang-html\">    &lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return { &#39;b-my-block&#39; : { name : &#39;b-my-block&#39;}}&quot;&gt;\n...\n&lt;/div&gt;\n</code></pre>\n<p>Ниже подробно рассказано о <a href=\"#onclick.params\">формате параметров в onclick</a>.</p>\n<p><a name=\"abstract.blocks\"></a></p>\n<h5 id=\"-dom-\">Блоки без DOM-представления</h5>\n<p>Технология <code>bem-js</code> позволяет также создавать блоки, не имеющие <code>DOM</code>-представления.\nТакие блоки тем не менее существуют в <code>JS</code> в виде объектов, манипулировать ими можно так же, как и блоками с <code>DOM</code>-представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком <a href=\"#dom.decl\">Декларация блока</a>.</p>\n<p>Блоки, реализованные на <code>bem-js</code>, после инициализации представлены в <code>js</code>-объектами, имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний вид или поведение блока.</p>\n<p>Технология <code>bem-js</code> использует предметную область <a href=\"http://ru.bem.info/method/\">концепции <strong>BEM</strong></a>. Все сущности являются блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.</p>\n<p>Представление блока в <code>js</code> не обязано иметь взаимное соответствие с одной <code>DOM</code>-нодой. Можно разместить несколько блоков на одной <code>DOM</code>-ноде (это называется <code>mix</code>), а также реализовать один блок на нескольких <code>DOM</code>-нодах.</p>\n<p>Далее блок, использующий технологию <code>bem-js</code>, будет называться <code>блок, реализованный на bem-js</code>, или <code>bem-js-блок</code>. Примером такого блока в библиотеке может служить <code>b-link</code>.</p>\n<p><a name=\"decl\"></a></p>\n<h3 id=\"-\">Декларативный принцип</h3>\n<p>Важной особенностью технологии <code>bem-js</code> является декларативный принцип. Подобно работе декларативных языков программирования, <code>js</code>-код содержит не последовательный алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Декларативность проявляется в объявлении того, к каким блокам или их модификациям применим код компонента:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n//...\n</code></pre>\n<pre><code class=\"lang-js\">BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n//...\n</code></pre>\n<p><a href=\"#dom.decl\">Подробнее о декларации блока</a></p>\n<p><a name=\"mods.reaction\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции, состояния блока или его элементов определяются модификаторами. Поэтому, чтобы динамически изменять состояния блоков и элементов, в <code>bem-js</code> есть специальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора. Эта запись тоже декларативна.</p>\n<p>Например, блок <code>b-dropdowna</code> при установке модификатора <code>disabled</code> прячет показанный попап:</p>\n<pre><code class=\"lang-js\">    BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;disabled&#39; : function(modName, modVal) {\n\n            this._getSwitcher().setMod(modName, modVal);\n            modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n        }\n    },...\n\nПодробно [о декларации обработки модификаторов](#mods.callbacks) рассказано в пункте про создание собственного блока.\n\n&lt;a name=&quot;block.getting&quot;&gt;&lt;/a&gt;\n### Доступ к другим блокам\n\nМожет возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к `js`-объекту этого блока и вызывать его методы.\n\n&lt;a name=&quot;blocks.finding&quot;&gt;&lt;/a&gt;\n#### Доступ к bem-js-блоку из другого bem-js-блока.\n\nВ случае [реализации собственного кастомного блока на технологии **bem-js**](#creation), блоку соответствует `js`-объект. Он наследует общие для всех блоков методы, позволяющие работать с `DOM` документа в терминах `BEM`. Среди этих методов есть методы поиска других блоков относительно текущего (`findBlock`*-методы).\nОни возвращают `js`-объект искомого блока, что позволяет затем напрямую вызывать его методы.\n\n**Не используйте `jQuery`-селекторы для поиска блоков и элементов.**\n\nВ этом примере вызывается метод `val()` у блока `b-form-checkbox`:\n\n```js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n            this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n        }\n    }\n}\n);\n</code></pre>\n<h4 id=\"-bem-js-bem-js-\">Доступ к bem-js-блоку не из bem-js-блока</h4>\n<p>В случае работы не из <code>bem-js-блока</code>, методы <code>findBlock</code>* недоступны. <code>js</code>-объект блока можно получить, используя метод <code>.bem()</code> <code>jQuery</code>-коллекции:</p>\n<pre><code class=\"lang-js\">$(&#39;уникальный селектор&#39;).bem(&#39;b-link&#39;);\n</code></pre>\n<p>Этот способ <strong>не рекомендован</strong>. Лучшим вариантом работы с блоками, реализованными на <code>i-bem</code>, является создание собственного компонента на <code>i-bem</code>. Подробнее о <a href=\"#creation\">создании собственного bem-js-компонента</a> написано ниже.</p>\n<p><a name=\"mods\"></a></p>\n<h3 id=\"-\">Работа с модификаторами блока</h3>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще). У модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора. Например, для того, чтобы сделать чекбокс выделенным в блоке <code>b-form-checkbox</code>, ему нужно установить модификатор <code>checked</code> в значение <code>yes</code>.</p>\n<p>На странице документации каждого блока есть список его элементов и модификаторов. Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя <code>CSS</code>-класс на соответствующей <code>DOM</code>-ноде. Для корректной работы <code>js</code> все манипуляции с модификаторами должны производиться при помощи метода-хелпера <code>setMod()</code>. Также существуют методы <code>hasMod()</code>, <code>getMod/getMods()</code>, <code>toggleMod()</code> и <code>delMod()</code>. Сигнатуры этих методов доступны в <a href=\"/blocks/i-bem/i-bem.jsdoc.md\">референсе по BEM</a>.</p>\n<p><a name=\"customization\"></a></p>\n<h3 id=\"-\">Изменение поведения существующих блоков</h3>\n<p>Используя <code>bem-js</code>, можно переопределять и доопределять методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации блоков с помощью <code>CSS</code> или <code>BEMHTML</code>.</p>\n<h4 id=\"-\">Переопределение поведения</h4>\n<p>Например, на сервисе существует необходимость модифицировать все блоки <code>b-dropdowna</code> так, чтобы они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения сервиса нужно сделать файл <code>blocks/b-dropdowna/b-dropdowna.js</code>, кастомизирующий поведение блока из библиотеки:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-dropdowna&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n        }\n    },\n    _on : function() {\n        this.getPopup().show(this.elem(&#39;switcher&#39;));\n    }\n});\n</code></pre>\n<h4 id=\"-\">Расширение поведения</h4>\n<p>В предыдущем примере код кастомизации полностью переопределяет поведение блока. Технология <code>bem-js</code> позволяет также реализовывать «доопределение» блока. Для этого в методах кастомизирующего кода можно вызывать <code>this._~_base.apply()</code>, передавая в качестве аргументов <code>this</code> и <code>arguments</code>. Вызов такого метода аналогичен использованию <code>&lt;xsl:apply-imports/&gt;</code>.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков <code>b-link</code> в проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла <code>blocks/b-link/_pseudo/b-link_pseudo_yes.js</code></p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p>Содержание файла <code>blocks/b-link/_status/b-link_status_clicked.css</code></p>\n<pre><code class=\"lang-css\">.b-link_status_clicked\n{\n    color: red;\n}\n</code></pre>\n<h4 id=\"-\">Кастомизация с использованием модификаторов</h4>\n<p>Предыдущие примеры кастомизации изменяют поведение <em>всех</em> определенных блоков на странице. Но очень часто возникает задача кастомизации конкретного блока без влияния на поведение всех таких блоков. Согласно концепции <code>BEM</code>, если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно реализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдо-ссылку, приобретающую красный цвет после первого клика, сделаем модификацию <code>reaction_odd</code>. Псевдоссылка с таким модификатором приобретает красный цвет после каждого нечётного клика, а после каждого чётного возвращается к исходному цвету.</p>\n<p>Содержание файла <code>blocks/b-link/_reaction/b-link_reaction_odd.js</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n</code></pre>\n<p><a name=\"creation\"></a></p>\n<h3 id=\"-js-\">Создание js-компонента для собственного блока или собственной модификации</h3>\n<p>Рекомендованным способом работы с <code>bem-js-блоками</code> является создание собственных <code>bem-js-блоков</code> (чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные <code>bem-js-блоки</code> могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.</p>\n<p><code>js-код</code> блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением <code>.js</code>. Если <code>js-реализация</code> относится не к блоку, а лишь к одной из его модификаций, можно разместить код в <code>js-файле</code>, соответствующем данному модификатору.</p>\n<p><a name=\"dom.decl\"></a></p>\n<h4 id=\"-\">Декларация блока</h4>\n<p>Создание <code>js-компонента</code> блока сводится к его декларации с помощью специальных хелперов. Существуют два хелпера для декларации блоков: один для блоков, которые имеют <code>DOM</code>-представление, второй — для блоков, не имеющих <code>DOM</code>-представления (например <code>i-request</code>, <code>i-update-session</code>).</p>\n<p>В первом случае блоки декларируются с помощью <code>BEM.DOM.decl</code>, во втором — с помощью <code>BEM.decl</code>.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр. Первым параметром может быть либо строка с именем блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому типу блоков применять компонент.  </li>\n<li>Методы и свойства экземп<em>**</em>ляра блока. Методы и свойства, предметной областью которых является конкретный инстанс блока на странице. Это как <a href=\"#mods.callbacks\">функции обработки модификаторов</a>, так и <a href=\"#methods\">кастомные методы блока</a>.</li>\n<li>Статические методы и свойства. Методы и свойства, не относящиеся к конкретному инстансу блока. <a href=\"#static.methods\">Подробнее</a></li>\n</ol>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n</code></pre>\n<p>и</p>\n<pre><code class=\"lang-js\">BEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n</code></pre>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {\n\n    get : function() {\n        this.__base(); // вызов одноименного метода из i-request\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Тут указано, что блок <code>b-dataprovider</code> наследуется от блока <code>i-request</code> и переопределяет его метод <code>get</code>.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку применить компонент, но и уточнён модификатор и/или его значение:</p>\n<pre><code class=\"lang-js\">BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {\n\n    show : function() {\n        doSomething();\n    }\n\n});\n</code></pre>\n<p>Все методы, описанные в такой декларации, будут вызываться для таких блоков <code>b-popup</code>, которые в данный момент имеют модификатор <code>type</code>, установленный в <code>inplace</code>.</p>\n<p><a name=\"mods.callbacks\"></a></p>\n<h4 id=\"-\">Реакция на изменение модификаторов</h4>\n<p>Согласно концепции <code>BEM</code>-состояния блоков и его элементов определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор, или получать это назначение из другого блока.</p>\n<p>Во время того, как блок или элемент получил определённый модификатор, может возникнуть необходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных свойства: <code>onSetMod</code> и <code>onElemSetMod</code>, где описываются <code>callback</code>-функции, вызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание <code>callback</code>-функций для <code>onSetMod</code> представляет собой хеш вида:</p>\n<pre><code class=\"lang-js\">{\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n    },\n\n    &#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n    ...\n\n    &#39;модификаторN&#39; : {\n\n        &#39;значение1-модификатораN&#39; : function() { ... },\n\n        ...\n\n        &#39;значениеN-модификатораN&#39; : function() { ... }\n\n    }\n\n}\n</code></pre>\n<p>Описание <code>callback</code>-функций для <code>onElemSetMod</code> аналогично, за исключением того, что на верхнем уровне указывается имя элемента:</p>\n<pre><code class=\"lang-js\">{\n\n    &#39;элемент1&#39; : {\n\n        &#39;модификатор1&#39; : {\n\n            &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n            ...\n\n            &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n            &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n        }\n\n    },\n\n    ...\n\n    &#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n\n}\n</code></pre>\n<p>Параметры <code>callback</code>-функций:</p>\n<ul>\n<li><code>{jQuery} [elem]</code> — элемент блока (если установка модификатора была для элемента)</li>\n<li><code>{String} modName</code> — имя модификатора</li>\n<li><code>{String} modVal</code> — устанавливаемое значение модификатора</li>\n<li><code>{String} curModVal</code> — текущее значение модификатора</li>\n</ul>\n<p>Порядок вызовов <code>callback</code>-функций при установке модификатора <code>modVal</code> в значение <code>modName</code>:</p>\n<ul>\n<li>вызывается <code>callback</code>-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в любое значение (если она существует)</li>\n<li>вызывается <code>callback</code>-функция на установку модификатора <code>modVal</code> в значение <code>modName</code> (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет <code>false</code>, то установки модификатора не произойдет.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    onElemSetMod : {\n\n        &#39;trigger&#39; : {\n\n            &#39;state&#39; : function(elem, modName, modVal) {\n\n                // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n                this\n                    .toggleMod(\n                        this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                        &#39;visibility&#39;,\n                        &#39;visible&#39;,\n                        modVal == &#39;opened&#39;)\n                    .trigger(&#39;trigger&#39;, {\n                        domElem : elem,\n                        state : modVal\n                    });\n\n            }\n\n        }\n\n    },\n\n    onTriggerClick : function(e) { // при клике на триггер\n\n        e.preventDefault();\n        this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n    }\n\n}, {\n\n    live : function() {\n\n        this\n            .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n                this.onTriggerClick(e);\n            });\n\n    }\n\n});\n</code></pre>\n<p>В данном примере при вызове <code>toggleMod</code> внутри <code>onTriggerClick</code> будет вызвана соответствующая ей <code>callback</code>-функция из <code>onElemSetMod</code>.</p>\n<p><code>Callback</code>-функции, реагирующие на изменение модификатора, выполняются до установки модификатора.\nЕсли существует необходимость выполнить часть кода после установки модификатора, нужно воспользоваться методом <code>.afterCurrentEvent()</code>.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-square2&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : function() {\n\n            var square = this;\n\n            this.bindTo(&#39;click&#39;, function(){\n                square.setMod(&#39;size&#39;, &#39;big&#39;);\n            });\n\n        },\n        &#39;size&#39; : function() {\n            this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n            this.afterCurrentEvent(function(){\n                this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n            });\n        }\n    }\n\n});\n</code></pre>\n<h5 id=\"-js-\">Начало работы с блоком (модификатор <code>js</code>)</h5>\n<p>Блок начинает свою работу с действий, описанных в <code>callback</code>-функции на установку его модификатора <code>js</code> в значение <code>inited</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n        &#39;js&#39; : {\n\n            &#39;inited&#39; : function() {\n\n                this\n                    .bindTo(this.elem(&#39;input&#39;), {\n                        &#39;focus&#39; : this.onFocus,\n                        &#39;blur&#39;  : this.onBlur\n                    })\n\n            }\n\n        }\n\n    }\n\n});\n</code></pre>\n<p>Этот модификатор присваивается блоку в момент инициализации. Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик и является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим <code>DOM</code>-представление, так и блокам без него. Так что, у блоков без <code>DOM</code>-представления первый исполняемый метод также задаётся как <code>callback</code> модификатора <code>js_inited</code>.</p>\n<p>В коде блоков можно встретить <code>callback</code>-функцию не на значение <code>inited</code> модификатора <code>js</code>, а на установку модификатора <code>js</code> в любое значение:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    onSetMod : {\n\n    &#39;js&#39; : function() { // конструктор b-form-input\n        ...\n        }\n\n    }\n});\n</code></pre>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок не имеет модификатора <code>js</code>, а в момент инициализации приобретает значение <code>inited</code>. Другие значения модификатора сейчас не предусмотрены.</p>\n<p><a name=\"methods\"></a></p>\n<h4 id=\"-\">Методы блока</h4>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы. Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод <code>.toggle()</code> блока <code>b-form-checkbox</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n</code></pre>\n<h5 id=\"-\">Переопределение и доопределение методов блока</h5>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён. Об этом написано выше в пункте <a href=\"#customization\">Изменение поведения существующих блоков</a>.</p>\n<p><a name=\"static.methods\"></a></p>\n<h4 id=\"-\">Статические методы блока</h4>\n<p>Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических методов блока.</p>\n<p>Примером блока, использующего статические методы, может служить (/blocks/b-flash/b-flash.md).</p>\n<p>Для каждого блока может быть определен статический метод <code>live</code>, позволяющий реализовать <a href=\"#liveinit\">инициализацию по требованию <code>liveinit</code></a>.</p>\n<p><a name=\"init\"></a></p>\n<h3 id=\"-\">Инициализация</h3>\n<p>Для того, чтобы у блока появился <code>js-объект</code>, описанный в декларации, происходит процесс инициализации блока. Инициализация блоков производится функцией <code>BEM.DOM.init()</code> на фрагменте <code>DOM</code>-дерева. Если элемент <code>i-bem_~_dom</code> задекларирован с модификатором <code>init_auto</code> (подключается файл <code>i-bem_~_dom_init_auto.js</code>), то инициализация блоков происходит на всём документе по событию <code>domReady</code>. Также функцию <code>BEM.DOM.init</code> можно вызвать самостоятельно. Например, это делается для инициализации блоков после динамического изменения страницы, если появились новые блоки с <code>js</code>-представлением.</p>\n<h4 id=\"-dom-\">Инициализация блоков с DOM-представлением</h4>\n<p>Для инициализации блоков, представленных в <code>DOM</code>, на фрагменте дерева ищутся все блоки,  помеченные классом <code>i-bem</code>, у них считываются параметры из атрибута <code>onclick</code>, и создаётся <code>js-объект</code> такого блока.</p>\n<p><a name=\"onclick.params\"></a></p>\n<h5 id=\"-onclick\">Формат параметров блока в onclick</h5>\n<p>Параметры для блока записываются в виде возвращаемого атрибутом <code>onclick</code> хеша. Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков, к которым они относятся. Значением каждого элемента должен быть вложенный хеш c параметрами.</p>\n<p>Такая запись позволяет задавать параметры для нескольких блоков в том случае, если они представлены в <code>HTML</code> одной и той же <code>DOM-нодой</code>.</p>\n<p>Вот как выглядит <code>DOM-нода</code> произвольного блока, реализованного на <code>bem-js</code>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {}\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и элемент <code>name</code>. Формат параметра может быть любым: строка, число, массив, хеш, функция. Количество параметров также не ограничено.</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;points&#39; : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        &#39;title&#39; : &#39;Какое-то название&#39;,\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p>Для нескольких блоков на одной <code>DOM-ноде</code> <code>HTML</code> представление будет аналогично следующему:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;title&#39; : &#39;Какое-то название&#39;, // Этот блок имеет опциональный параметр title\n    },\n    &#39;b-my-second-block&#39; : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<h5 id=\"dom-\">DOM-представление инициализированного блока</h5>\n<p>После инициализации <code>DOM</code>-представление блока изменяется: у блока появляется дополнительный модификатор <code>js_inited</code>.</p>\n<p>Если <code>DOM-ноде</code> соответствуют несколько блоков, то появление модификатора у одного из них свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p><code>DOM</code>-представление блока после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-block_js_inited i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;\n    }\n}&quot;&gt;\n..\n&lt;/div&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков после инициализации:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<p><code>DOM</code>-представление двух блоков, но инициализован только один из них:</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;b-my-block b-my-second-block b-my-second-block_js_inited i-bem&quot; onclick=&quot;return {\n    &#39;b-my-block&#39; : {\n        &#39;name&#39; : &#39;b-my-block&#39;,\n    },\n    &#39;b-my-second-block&#39; : {\n        &#39;name&#39; : &#39;b-my-second-block&#39;\n    }\n}&quot;&gt;\n</code></pre>\n<h4 id=\"-dom-\">Инициализация блоков без DOM-представления</h4>\n<p>В том случае, если у блока нет <code>DOM</code>-представления, в процессе инициализации просто возникает <code>js-объект</code>, соответствующий этому блоку. Дальнейшее зависит от кода блока.</p>\n<p><a name=\"liveinit\"></a></p>\n<h3 id=\"-liveinit-\">Инициализация по требованию (liveInit)</h3>\n<p>Многим блокам (например, <code>b-link</code>, <code>b-dropdown</code>, <code>b-smart-help</code>) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока <code>b-link</code>:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link&#39;, {\n\n    _onClick : function(e) {\n\n        e.preventDefault();\n        this.trigger(&#39;click&#39;);\n\n    }\n\n}, {\n\n    live : function() {\n\n        this.liveBindTo(&#39;click&#39;, function(e) {\n            this._onClick(e);\n        });\n\n    }\n\n});\n</code></pre>\n<p>В статических свойствах блока предусмотрено специальное свойство <code>live</code> (<code>Function</code>|<code>Boolean</code>), отвечающее за инициализацию по требованию и за подписку на <code>live</code> события на <code>DOM</code>-элементах внутри такого блока.</p>\n<p>Если <code>live</code> определено как <code>Function</code>, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для <code>live</code>-событий:</p>\n<ul>\n<li><code>liveInitOnEvent</code> — хелпер для инициализации блока по событию на блоке или его внутреннем элементе</li>\n<li><code>liveBindTo</code> — подписка на события на блоке или его внутреннем элементе</li>\n</ul>\n<p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что <code>callback</code>-функция в <code>liveInitOnEvent</code> вызывается только один раз после инициализации блока, а в <code>liveBindTo</code> она будет вызываться при каждом событии. Контекстом такой <code>callback</code>-функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок <code>b-link</code> будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же <code>live</code> определено как <code>Boolean</code> и установлено в <code>true</code>, то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска <code>findBlockInside</code>/<code>findBlockOutside</code>.</p>\n<p><a name=\"finding\"></a></p>\n<h3 id=\"-\">Методы доступа к блокам и элементам</h3>\n<p>Работая с блоками, реализованными на <code>bem-js</code>, необходимо использовать встроенные методы для поиска блоков и их элементов. Эти методы доступны в каждом блоке и умеют возвращать другой блок или <code>jQuery</code>-коллекцию (в случае поиска элементов).</p>\n<h4 id=\"-\">Методы поиска блоков</h4>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов <code>findBlock*</code>.</p>\n<p>Реализуем блок <code>b-my-block</code>, который находит первый из блоков <code>b-form-checkbox</code> внутри себя и вызывает у него метод <code>toggle()</code> для переключения чекбокса.</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n</code></pre>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><code>findBlockInside/findBlocksInside</code> — поиск блока/блоков внутри <code>DOM</code>-элементов текущего блока или его элементов;</li>\n<li><code>findBlockOn/findBlocksOn</code> — поиск блока/блоков на <code>DOM</code>-элементах текущего блока или его элементов;</li>\n<li><code>findBlockOutside/findBlocksOutside</code> — поиск блока/блоков снаружи <code>DOM</code>-элементов текущего блока или его элементов.</li>\n</ul>\n<p>Список методов поиска блоков и их сигнатуры можно посмотреть в <a href=\"/blocks/i-bem/dom/i-bem__dom.jsdoc.md\">референсе по BEM.DOM</a>.</p>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть: <a href=\"/blocks/b-smart-help/b-smart-help.md\">b-smart-help</a>, <a href=\"blocks/b-screenshot/b-screenshot.md\">b-screenshot</a> и <a href=\"blocks/b-dropdowna/b-dropdowna.md\">b-dropdowna</a>.</p>\n<h4 id=\"-\">Методы доступа к элементам</h4>\n<p>Для поиска элементов внутри блока используется метод <code>elem</code>. Результат этого метода кэшируется.</p>\n<p>Например:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-form-input&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n    }\n\n});\n</code></pre>\n<p>Можно искать элементы внутри блока с учетом модификатора:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-menu&#39;, {\n\n    doSomething : function() {\n\n        this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n    }\n\n});\n</code></pre>\n<p>Некэширующий метод поиска элементов называется <code>findElem()</code>.</p>\n<p>Полный список методов для поиска элементов и их сигнатуры можно найти в\n<a href=\"/blocks/i-bem/dom/i-bem__dom.jsdoc.md\">референсе по BEM.DOM</a>.</p>\n<p><a name=\"events\"></a></p>\n<h3 id=\"-\">Работа с событиями</h3>\n<h4 id=\"-\">События на блоках</h4>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не <code>DOM</code>) событий:</p>\n<ul>\n<li><code>on(e, [data], fn, [ctx])</code> — подписка на событие <code>e</code></li>\n<li><code>onFirst(e, [data], fn, [ctx])</code> — подписка только на первое событие <code>e</code></li>\n<li><code>un([e], [fn], [ctx])</code> — отписка от конкретного события <code>e</code> или всех событий</li>\n<li><code>trigger(e, [data])</code> — нотификация о событии  <code>e</code></li>\n</ul>\n<h4 id=\"live-\">live-события на блоках</h4>\n<p>В <code>bem-js</code> есть события, реализованные по паттерну делегированных событий, они называются <code>live</code>-события.</p>\n<p>Следующий пример демонстрирует работу с <code>live</code>-событием <code>click</code> для блоков <code>b-link</code>, содержащихся в определённой <code>DOM-ноде</code>. В данном случае контейнер и блок совпадают:</p>\n<pre><code class=\"lang-js\">BEM.DOM.decl(&#39;b-link-example&#39;, {\n\n    onSetMod: {\n        &#39;js&#39;: function() {\n            var link = this.findBlockInside(&#39;b-link&#39;);\n            BEM.blocks[&#39;b-link&#39;]\n                .liveCtxBind(link.domElem,\n                            &#39;click&#39;,\n                            function(){\n                                link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                            },\n                            this);\n        }\n    }\n},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n</code></pre>\n<p>Метод <code>.liveCtxBind()</code> реализует возможность реакции на bem-события блоков, вложенных в какой-либо <code>DOM</code>-элемент. <strong>Это не DOM-события</strong></p>\n<p>Использование <code>live</code>-событий позволяет избежать лишнего поиска блоков в <code>DOM</code>-дереве. Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет происходить даже в том случае, если на момент привязки блока в контейнере не было, а он появился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к <code>live</code>-событию блока, здесь также продемонстрированы <a href=\"#blocks.finding\">поиск блока относительно текущего</a> и <a href=\"#liveinit\">live-инициалиация</a>.</p>\n"}],"examples":[{"url":"i-bem.examples/15-i-bem-click/_15-i-bem-click"},{"url":"i-bem.examples/17-i-bem-square/_17-i-bem-square"},{"url":"i-bem.examples/20-i-bem-liveinit-multiple/_20-i-bem-liveinit-multiple"},{"url":"i-bem.examples/40-i-bem-extend/_40-i-bem-extend"},{"url":"i-bem.examples/60-i-bem-pseudo-link/_60-i-bem-pseudo-link"}]}