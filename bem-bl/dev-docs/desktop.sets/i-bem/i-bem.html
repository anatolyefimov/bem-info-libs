<!doctype html><html class="page__root"><head><meta charset="utf-8"/><title></title><link rel="stylesheet" href="../undefined/_undefined.css"/><script src="//yandex.st/jquery/1.8.2/jquery.min.js"></script><script src="../undefined/_undefined.js"></script></head><body class="page"><div class="catalogue"><div class="block"><div class="header"><a class="link link_pos_right" href="../index/index.html">← каталог</a><span class="header__block-name">Блок i-bem</span></div><div class="block__title"></div><div class="block__description static-text"><p>Блок ##i-bem## — это блок-хелпер, позволяющий создавать другие блоки.
Блок реализован в технологиях ##BEMHTML## и ##JS##. Обе эти реализации
являются ядром библиотеки блоков в соответствующих технологиях.</p>
<p>=== js-реализация блока i-bem</p>
<p>Реализация блока ##i-bem## в ##JS## обеспечивает хелперы для представления
блока в виде ##JS## объекта с определёнными методами и свойствами. Это нужно, чтобы
писать клиентский ##JS## в терминах ##BEM##. То есть ##JS## оперирует более высоким уровнем
абстрации, чем ##DOM## представление.</p>
<p>Для того, чтобы js-представление блока использовало ядро ##i-bem##, оно должно
быть написано с соблюдением специальных правил.</p>
<p>===== Что описано на этой странице?</p>
<ul>
<li>Какие бывают блоки<ul>
<li>((#dom.blocks Блоки с DOM-представлением))</li>
<li>((#abstract.blocks Блоки без DOM-представления))</li>
</ul>
</li>
<li>Принципы и особенности подхода<ul>
<li>((#decl Декларативный принцип))</li>
<li>((#block.getting Доступ к другим блокам))</li>
<li>((#mods Работа с модификаторами))</li>
<li>((#customization Кастомизация блоков))</li>
</ul>
</li>
<li>((#creation Создание собственного bem-js блока))</li>
<li>Подробнее о понятиях<ul>
<li>((#init Инициализация))</li>
<li>((#liveinit Инициализация по требованию (live-инициализация~)))</li>
<li>((#finding Методы доступа к блокам и элементам))</li>
<li>((#events Работа с событиями))</li>
</ul>
</li>
</ul>
<p>%%hl xml
<a name="dom.blocks"></a>
%%
===== Блоки с DOM-представлением
Блокам, реализованным на ##bem-js##, могут соответствовать ноды в ##HTML##. В этом случае говорится о
том, что блоки имеют ##DOM## представление.\
В ##HTML## блоки на ##bem-js## отличаются дополнительным ##CSS## классом ##i-bem##
и специальным форматом записи параметров блока в ##onclick##:</p>
<p>%%hl xml</p>
<p><div class="b-my-block i-bem" onclick="return { 'b-my-block' : { name : 'b-my-block'}}">
...
</div>
%%</p>
<p>Ниже подробно рассказано о ((#onclick.params формате параметров в onclick)).</p>
<p>%%hl xml
<a name="abstract.blocks"></a>
%%
===== Блоки без DOM-представления
Технология ##bem-js## позволяет также создавать блоки, не имеющие ##DOM## представления.
Такие блоки тем не менее существуют в ##JS## в виде объектов, манипулировать ими
можно так же, как и блоками с ##DOM## представлением.</p>
<p>О том, как создавать такие блоки, написано под заголовком
((#dom.decl Декларация блока)).</p>
<p>Блоки, реализованные на ##bem-js##,  после инициализации представлены в ##js## объектами,
имеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний
вид или поведение блока.\
Технология ##bem-js## использует предметную область ((<a href="http://wiki.yandex-team.ru/lento4ka/bem">http://wiki.yandex-team.ru/lento4ka/bem</a> концепции ##BEM##)).
Все сущности являются
блоками или их элементами, управление их состояниями реализуется при помощи модификаторов.\
Представление блока в ##js## не обязано иметь взаимное соответствие с одной ##DOM##-нодой.
Можно разместить несколько
блоков на одной ##DOM##-ноде (это называется ##mix##), а также реализовать один блок на нескольких ##DOM##-нодах.\
Далее блок, использующий технологию ##bem-js##,
будет называться ##блок, реализованный на bem-js##, или ##bem-js-блок##. Примером такого
блока в библиотеке может служить ##b-link##.</p>
<p>%%hl xml
<a name="decl"></a>
%%
=== Декларативный принцип</p>
<p>Важной особенностью технологии ##bem-js## является декларативный принцип. Подобно
работе декларативных языков программирования, ##js##-код содержит не последовательный
алгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>
<p>==== Декларация блока
Декларативность проявляется в объявлении того, к каким блокам или их модификациям
применим код компонента:</p>
<p>%%hl js
BEM.DOM.decl(&#39;b-link&#39;, {
...
%%</p>
<p>%%hl js
BEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {
...
%%</p>
<p>((#dom.decl Подробнее о декларации блока))</p>
<p>%%hl xml
<a name="mods.reaction"></a>
%%
==== Реакция на изменение модификаторов
Согласно концепции, состояния блока или его элементов определяются модификаторами.
Поэтому, чтобы динамически изменять состояния блоков и элементов, в ##bem-js## есть
специальные методы для установки и снятия модификаторов.</p>
<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора.
Эта запись тоже декларативна.\
Например, блок ##b-dropdowna## при установке модификатора ##disabled## прячет показанный попап:
%%hl js
BEM.DOM.decl(&#39;b-dropdowna&#39;, {</p>
<pre><code>onSetMod : {

    &#39;disabled&#39; : function(modName, modVal) {

        this._getSwitcher().setMod(modName, modVal);
        modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();

    }

},
</code></pre><p>...
%%</p>
<p>Подробно ((#mods.callbacks о декларации обработки модификаторов)) рассказано в пункте про создание собственного блока.</p>
<p>%%hl xml
<a name="block.getting"></a>
%%
=== Доступ к другим блокам</p>
<p>Может возникнуть необходимость управлять другим блоком.
Для любых манипуляций с блоком необходимо получить доступ к ##js##-объекту этого блока и вызывать его методы.</p>
<p>%%hl xml
<a name="blocks.finding"></a>
%%
==== Доступ к bem-js-блоку из другого bem-js-блока.</p>
<p>В случае ((#creation реализации собственного кастомного блока на технологии ##bem-js##)),
блоку соответствует ##js##-объект. Он наследует общие для всех блоков методы, позволяющие работать с ##DOM## документа в
терминах ##BEM##. Среди этих методов есть методы поиска других блоков относительно текущего (##findBlock<em>##-методы).
Они возвращают ##js##-объект искомого блока, что позволяет затем напрямую вызывать его методы.\
<em>*Не используйте ##jQuery##-селекторы для поиска блоков и элементов.</em></em></p>
<p>В этом примере вызывается метод ##val()## у блока ##b-form-checkbox##:
%%hl js
BEM.DOM.decl(&#39;b-checkbox-example&#39;, {</p>
<pre><code>onSetMod: {
    &#39;js&#39;: function() {
        var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});
        this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());
    }
}
</code></pre><p>}
);
%%</p>
<p>==== Доступ к bem-js-блоку не из bem-js-блока</p>
<p>В случае работы не из ##bem-js-блока##, методы ##findBlock<em>## недоступны. ##js##-объект блока можно
получить, используя метод ##.bem()## ##jQuery## коллекции:
%%hl js
$(уникальный селектор).bem(&#39;b-link&#39;);
%%
Этот способ <em>*не рекомендован</em></em>. Лучшим вариантом работы с блоками, реализованными на ##i-bem##,
является создание собственного компонента на ##i-bem##. Подробнее о ((#creation создании собственного
bem-js-компонента)) написано ниже.</p>
<p>%%hl xml
<a name="mods"></a>
%%
=== Работа с модификаторами блока</p>
<p>Модификатор задаёт блоку определённое состояние. Каждому блоку
можно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще).
У модификатора есть имя и значение.</p>
<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора.
Например, для того, чтобы сделать чекбокс выделенным в блоке ##b-form-checkbox##, ему
нужно установить модификатор ##checked## в значение ##yes##.\
На странице документации каждого блока есть список его элементов и модификаторов.
Из этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>
<p>Модификаторы нельзя устанавливать, напрямую меняя ##CSS## класс на соответствующей ##DOM##-ноде. Для
корректной работы ##js## все манипуляции с модификаторами должны производиться при помощи
метода-хелпера ##setMod()##. Также существуют методы ##hasMod()##, ##getMod##/##getMods()##, ##toggleMod()##
и ##delMod()##. Сигнатуры этих методов доступны в ((/blocks/i-bem/i-bem.jsdoc.wiki референсе по BEM)).</p>
<p>%%hl xml
<a name="customization"></a>
%%
=== Изменение поведения существующих блоков</p>
<p>Используя ##bem-js##, можно переопределять и доопределять
методы блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации
блоков на ##CSS## или ##BEMHTML##.</p>
<p>==== Переопределение поведения
Например, на сервисе существует необходимость модифицировать все блоки ##b-dropdowna## так, чтобы
они не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения
сервиса нужно сделать файл ##blocks/b-dropdowna/b-dropdowna.js##, кастомизирующий поведение блока
из библиотеки:</p>
<p>%%hl js
BEM.DOM.decl(&#39;b-dropdowna&#39;, {</p>
<pre><code>onSetMod : {

    &#39;js&#39; : function() {

        this._getSwitcher().on(&#39;click&#39;, this._on, this);

    }
},
_on : function() {
    this.getPopup().show(this.elem(&#39;switcher&#39;));
}
</code></pre><p>});
%%</p>
<p>==== Расширение поведения
В предыдущем примере код кастомизации полностью переопределяет поведение
блока. Технология ##bem-js## позволяет также реализовывать «доопределение»
блока. Для этого в методах кастомизирующего кода можно вызывать ##this._~_base.apply()##,
передавая в качестве аргументов ##this## и ##arguments##. Вызов такого метода аналогичен
использованию ##<xsl:apply-imports/>##.</p>
<p>Например, можно доопределить реакцию на клик всех блоков ##b-link##
на проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>
<p>Содержание файла ##blocks/b-link/_pseudo/b-link_pseudo_yes.js##
%%hl js
BEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {
    _onClick : function() {
         this
            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link
            .setMod(&#39;status&#39;, &#39;clicked&#39;);
    }
});
%%</p>
<p>Содержание файла ##blocks/b-link/_status/b-link_status_clicked.css##</p>
<p>%%hl xml
.b-link_status_clicked
{
    color: red;
}
%%</p>
<p>==== Кастомизация с использованием модификаторов</p>
<p>Предыдущие примеры кастомизации изменяют поведение //всех// определенных блоков на странице.
Но очень часто возникает задача кастомизации конкретного блока без влияния на
поведение всех таких блоков. Согласно концепции ##BEM##,
если блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно
реализовывать поведение для блока с таким модификатором.</p>
<p>Возвращаясь к примеру про псевдоссылку, приобретающую красный цвет после первого
клика, сделаем модификацию ##reaction_odd##. Псевдоссылка с таким модификатором
приобретает красный цвет после каждого
нечётного клика, а после каждого чётного возвращается к исходному цвету .</p>
<p>Содержание файла ##blocks/b-link/_reaction/b-link_reaction_odd.js##:
%%hl js
BEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {
    _onClick : function() {
         this
            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link
            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);
    }
});
%%</p>
<p>%%hl xml
<a name="creation"></a>
%%</p>
<p>=== Создание js-компонента для собственного блока или собственной модификации</p>
<p>Рекомендованным способом работы с ##bem-js-блоками## является создание собственных ##bem-js-блоков##
(чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные</p>
<h2 id="bem-js-">bem-js-блоки## могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.\</h2>
<h2 id="js-">js-код## блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением</h2>
<h2 id="-js-js-">.js##. Если ##js-реализация## относится не к блоку, а лишь к одной из его модификаций, можно</h2>
<p>разместить код в ##js-файле##, соответствующем данному модификатору.</p>
<p>%%hl xml
<a name="dom.decl"></a>
%%
==== Декларация блока</p>
<p>Создание ##js-компонента## блока сводится к его декларации с помощью специальных хелперов.
Существуют два хелпера для декларации блоков: один для блоков, которые имеют ##DOM##-представление,
второй — для блоков, не имеющих ##DOM## представления (например ##i-request##, ##i-update-session##).</p>
<p>В первом случае блоки декларируются с помощью ##BEM.DOM.decl##, во втором — с помощью ##BEM.decl##.</p>
<p>Хелпер декларации блока принимает 3 параметра:</p>
<ol>
<li>Матчащий параметр\
Первым параметром может быть либо строка с именем
блока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому
типу блоков применять компонент.</li>
<li>Методы и свойства экземляра блока\
Методы и свойства, предметной областью которых является конкретный инстанс блока
на странице. Это как ((#mods.callbacks функции обработки модификаторов)),
так и ((#methods кастомные методы блока)).</li>
<li>Статические методы и свойства\
Методы и свойства, не относящиеся к конкретному инстансу блока. ((#static.methods Подробнее))</li>
</ol>
<p>Например:
%%hl js
BEM.DOM.decl(
    &#39;b-link&#39;, // имя блока
    {
        // методы и свойства экземпляра блока
    },
    {
        // статические методы и свойства блока
    });
%%</p>
<p>и</p>
<p>%%hl js
BEM.decl(&#39;i-request&#39;, {
    {
        // методы и свойства экземпляра блока
    },
    {
        // статические методы и свойства блока
});
%%</p>
<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:
%%hl js
BEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {</p>
<pre><code>get : function() {
    this.__base(); // вызов одноименного метода из i-request
    doSomething();
}
</code></pre><p>});
%%
Тут указано, что блок ##b-dataprovider## наследуется от блока ##i-request## и переопределяет его метод ##get##.</p>
<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку
применить компонент, но и уточнён модификатор и/или его значение:
%%hl js
BEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {</p>
<pre><code>show : function() {
    doSomething();
}
</code></pre><p>});
%%
Все методы, описанные в такой декларации, будут вызываться для таких блоков ##b-popup##,
которые в данный момент имеют модификатор ##type##, установленный в ##inplace##.</p>
<p>%%hl xml
<a name="mods.callbacks"></a>
%%
==== Реакция на изменение модификаторов</p>
<p>Согласно концепции ##BEM## состояния блоков и его элементов
определяются модификаторами. Блок может сам назначать себе или своему элементу модификатор,
или получать это назначение из другого блока.\
Во время того, как блок или элемент получил определённый модификатор, может возникнуть
необходимость отреагировать на установку (или снятие) модификатора.</p>
<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных
свойства: ##onSetMod## и ##onElemSetMod##, где описываются ##callback##-функции,
вызываемые при установке модификаторов для блока или его элементов.</p>
<p>Описание ##callback##-функций для ##onSetMod## представляет собой хеш вида:
%%hl js
{
    &#39;модификатор1&#39; : {</p>
<pre><code>    &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;

    ...

    &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;

    &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений

},

&#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений

...

&#39;модификаторN&#39; : {

    &#39;значение1-модификатораN&#39; : function() { ... },

    ...

    &#39;значениеN-модификатораN&#39; : function() { ... }

}
</code></pre><p>}
%%</p>
<p>Описание ##callback##-функций для ##onElemSetMod## аналогично, за исключением того, что на верхнем уровне указывается имя элемента:
%%hl js
{</p>
<pre><code>&#39;элемент1&#39; : {

    &#39;модификатор1&#39; : {

        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;

        ...

        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;

        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;

    }

},

...

&#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;
</code></pre><p>}
%%</p>
<p>Параметры ##callback##-функций:</p>
<ul>
<li><h2 id="-jquery-elem-">{jQuery} [elem]## — элемент блока (если установка модификатора была для элемента)</h2>
</li>
<li><h2 id="-string-modname-">{String} modName## — имя модификатора</h2>
</li>
<li><h2 id="-string-modval-">{String} modVal## — устанавливаемое значение модификатора</h2>
</li>
<li><h2 id="-string-curmodval-">{String} curModVal## — текущее значение модификатора</h2>
</li>
</ul>
<p>Порядок вызовов ##callback##-функций при установке модификатора ##modVal## в значение ##modName##:</p>
<ul>
<li>вызывается ##callback##-функция на установку любого модификатора в любое значение (если она существует)</li>
<li>вызывается ##callback##-функция на установку модификатора ##modVal## в любое значение (если она существует)</li>
<li>вызывается ##callback##-функция на установку модификатора ##modVal## в значение ##modName## (если она существует)</li>
</ul>
<p>Если хоть один из вызовов этих функций вернет ##false##, то установки модификатора не произойдет.</p>
<p>Например:
%%hl js
BEM.DOM.decl(&#39;b-menu&#39;, {</p>
<pre><code>onElemSetMod : {

    &#39;trigger&#39; : {

        &#39;state&#39; : function(elem, modName, modVal) {

            // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение
            this
                .toggleMod(
                    this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),
                    &#39;visibility&#39;,
                    &#39;visible&#39;,
                    modVal == &#39;opened&#39;)
                .trigger(&#39;trigger&#39;, {
                    domElem : elem,
                    state : modVal
                });

        }

    }

},

onTriggerClick : function(e) { // при клике на триггер

    e.preventDefault();
    this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;

}
</code></pre><p>}, {</p>
<pre><code>live : function() {

    this
        .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;
            this.onTriggerClick(e);
        });

}
</code></pre><p>});
%%</p>
<h2 id="-togglemod-ontriggerclick-callback-onelemsetmod-">В данном примере при вызове ##toggleMod## внутри ##onTriggerClick## будет вызвана соответствущая ей ##callback##-функция из ##onElemSetMod##.</h2>
<h2 id="callback-">Callback## функции, реагирующие на изменение модификатора, выполняются до установки модификатора.</h2>
<p>Если существует необходимость выполнить часть кода после установки модификатора,
нужно воспользоваться методом ##.afterCurrentEvent()##.</p>
<p>Пример ниже демонстрирует, что квадратик становится больше только после установки
модификатора:
%%hl js
BEM.DOM.decl(&#39;b-square2&#39;, {</p>
<pre><code>onSetMod : {

    &#39;js&#39; : function() {

        var square = this;

        this.bindTo(&#39;click&#39;, function(){
            square.setMod(&#39;size&#39;, &#39;big&#39;);
        });

    },
    &#39;size&#39; : function() {
        this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200

        this.afterCurrentEvent(function(){
            this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400
        });
    }
}
</code></pre><p>});
%%</p>
<p>===== Начало работы с блоком (модификатор ##js##)</p>
<p>Блок начинает свою работу с действий, описанных в ##callback##-функции на установку его модификатора ##js## в значение ##inited##:</p>
<p>%%hl js
BEM.DOM.decl(&#39;b-form-input&#39;, {</p>
<pre><code>onSetMod : {

    &#39;js&#39; : {

        &#39;inited&#39; : function() {

            this
                .bindTo(this.elem(&#39;input&#39;), {
                    &#39;focus&#39; : this.onFocus,
                    &#39;blur&#39;  : this.onBlur
                })

        }

    }

}
</code></pre><p>});
%%</p>
<p>Этот модификатор присваивается блоку в момент инициализации.
Поскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик
и является первой выполняющейся функцией блока.</p>
<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим</p>
<h2 id="dom-dom-">DOM## представление, так и блокам без него. Так что, у блоков без ##DOM## представления</h2>
<p>первый исполняемый метод также задаётся как ##callback## модификатора ##js_inited##.</p>
<p>В коде блоков можно встретить ##callback## функцию не на значение ##inited## модификатора</p>
<h2 id="js-js-">js##, а на установку модификатора ##js## в любое значение:</h2>
<p>%%hl js
BEM.DOM.decl(&#39;b-form-input&#39;, {</p>
<pre><code>onSetMod : {

&#39;js&#39; : function() { // конструктор b-form-input
    ...
    }

}
</code></pre><p>});
%%</p>
<p>Это краткая декларация, возможная из-за того, что до инициализации блок
не имеет модификатора ##js##, а в момент инциализации приобретает значение ##inited##.
Другие значения модификатора сейчас не предусмотрены.</p>
<p>%%hl xml
<a name="methods"></a>
%%
==== Методы блока</p>
<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы.
Определённые в блоке методы могут быть вызваны им самим или другими блоками.</p>
<p>Например, так выглядит метод ##.toggle()## блока ((/blocks/b-form-checkbox/b-form/checkbox.wiki b-form-checkbox)):</p>
<p>%%hl js
BEM.DOM.decl(&#39;b-form-checkbox&#39;, {
    ...
    toggle : function() {
        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);
    }
    ...
});
%%</p>
<p>===== Переопределение и доопределение методов блока</p>
<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён.
Об этом написано выше в пункте ((#customization Изменение поведения существующих блоков)).</p>
<p>%%hl xml
<a name="static.methods"></a>
%%
==== Статические методы блока
Третий параметр, передаваемый в функцию декларации блока, -- это хеш статических
методов блока.</p>
<p>Примером блока, использующего статические методы, может служить
((/blocks/b-flash/b-flash.wiki)).</p>
<p>Для каждого блока может быть определен статический метод ##live##, позвляющий реализовать
((#liveinit инициализацию по требованию (liveinit~))).</p>
<p>%%hl xml
<a name="init"></a>
%%
=== Инициализация</p>
<p>Для того, чтобы у блока появился ##js-объект##, описанный в декларации, происходит процесс инициализации
блока.
Инициализация блоков производится функцией ##BEM.DOM.init()## на фрагменте ##DOM## дерева.
Если элемент ##i-bem_~_dom## задекларирован с модификатором ##init_auto## (подключается файл</p>
<h2 id="i-bem_-_dom_init_auto-js-">i-bem_~_dom_init_auto.js##), то инициализация блоков происходит на всём документе по событию</h2>
<p>domReady. Также функцию ##BEM.DOM.init## можно вызвать самостоятельно. Например, это делается
для инициализации блоков после динамического изменения страницы, если появились новые блоки с js-представлением.</p>
<p>==== Инициализация блоков с DOM-представлением
Для инициализации блоков, представленных в ##DOM##, на фрагменте дерева ищутся все блоки,
помеченные классом ##i-bem##, у них считываются параметры из атрибута ##onclick##, и
создаётся ##js-объект## такого блока.</p>
<p>%%hl xml
<a name="onclick.params"></a>
%%
===== Формат параметров блока в onclick
Параметры для блока записываются в виде возвращаемого атрибутом ##onclick## хеша.
Этот хеш должен содержать элементы с названиями, соответствующими названиям блоков,
к которым они относятся. Значением каждого элемента должен быть вложенный хеш c
параметрами.\
Такая запись позволяет задавать параметры для нескольких блоков в том случае, если
они представлены в ##HTML## одной и той же ##DOM-нодой##.</p>
<p>Вот как выглядит ##DOM-нода## произвольного блока, реализованного на ##bem-js##:</p>
<p>%%hl xml</p>
<p><div class="b-my-block i-bem" onclick="return {
    'b-my-block' : {}
}">
..
</div>
%%</p>
<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и
элемент ##name##. Формат параметра может быть любым: строка, число, массив, хеш, функция.
Количество параметров также не ограничено.</p>
<p>%%hl xml</p>
<p><div class="b-my-block i-bem" onclick="return {
    'b-my-block' : {
        'points' : [
            [1.67, 2.5],
            [-30, 2.07],
            [290, -0.39]
        ],
        'title' : 'Какое-то название',
    }
}">
..
</div>
%%</p>
<p>Для нескольких блоков на одной ##DOM-ноде## ##HTML## представление будет аналогично следующему:</p>
<p>%%hl xml</p>
<p><div class="b-my-block b-my-second-block i-bem" onclick="return {
    'b-my-block' : {
        'title' : 'Какое-то название', // Этот блок имеет опцинальный параметр title
    },
    'b-my-second-block' : {
        // У этого блока нет никаких опциональных параметров
    }
}">
..
</div>
%%</p>
<p>===== DOM-представление инициализированного блока
После инициализации ##DOM## представление блока изменяется: у блока появляется дополнительный
модификатор ##js_inited##.\
Если ##DOM-ноде## соответствуют несколько блоков, то появление модификатора у одного из них
свидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>
<p>DOM-представление блока после инициализации:
%%hl xml</p>
<p><div class="b-my-block b-my-block_js_inited i-bem" onclick="return {
    'b-my-block' : {
        'name' : 'b-my-block'
    }
}">
..
</div>
%%</p>
<h2 id="dom-">DOM## представление двух блоков после инициализации:</h2>
<p>%%hl xml</p>
<p><div class="b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem" onclick="return {
    'b-my-block' : {
        'name' : 'b-my-block',
    },
    'b-my-second-block' : {
        'name' : 'b-my-second-block'
    }
}">
%%</p>
<h2 id="dom-">DOM## представление двух блоков, но инициализован только один из них:</h2>
<p>%%hl xml</p>
<p><div class="b-my-block b-my-second-block b-my-second-block_js_inited i-bem" onclick="return {
    'b-my-block' : {
        'name' : 'b-my-block',
    },
    'b-my-second-block' : {
        'name' : 'b-my-second-block'
    }
}">
%%</p>
<p>==== Инициализация блоков без DOM-представления</p>
<p>В том случае, если у блока нет ##DOM## представления, в процессе инициализации просто возникает</p>
<h2 id="js-">js-объект##, соответствующий этому блоку. Дальнейшее зависит от кода блока.</h2>
<p>%%hl xml
<a name="liveinit"></a>
%%
=== Инициализация по требованию (liveInit)
Многим блокам (например, ##b-link##, ##b-dropdown##, ##b-smart-help##) нет необходимости делать сразу же полную инициализацию.
Инициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.
Рассмотрим на примере блока ##b-link##:</p>
<p>%%hl js
BEM.DOM.decl(&#39;b-link&#39;, {</p>
<pre><code>_onClick : function(e) {

    e.preventDefault();
    this.trigger(&#39;click&#39;);

}
</code></pre><p>}, {</p>
<pre><code>live : function() {

    this.liveBindTo(&#39;click&#39;, function(e) {
        this._onClick(e);
    });

}
</code></pre><p>});
%%</p>
<p>В статических свойствах блока предусмотрено специальное свойство ##live## (##Function##|##Boolean##), отвечающее за инициализацию по требованию и за
подписку на ##live## события на ##DOM## элементах внутри такого блока.</p>
<p>Если ##live## определено как ##Function##, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>
<p>Существует несколько хелперов для ##live## событий:</p>
<pre><code>* ##liveInitOnEvent## — хелпер для инициализации блока по событию на блоке или его внутреннем элементе
* ##liveBindTo## — подписка на события на блоке или его внутреннем элементе
</code></pre><p>Оба этих хелпера инициализируют блок при возникновении первого такого события.
Различие же заключается в том, что ##callback## функция в ##liveInitOnEvent## вызывается только один раз после инициализации блока,
а в ##liveBindTo## она будет вызываться при каждом событии.
Контекстом такой ##callback## функции является тот блок, в котором произошло событие.</p>
<p>В вышеприведенном примере блок ##b-link## будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>
<p>Если же ##live## определено как ##Boolean## и установлено в ##true##,
то такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска ##findBlockInside##/##findBlockOutside##.</p>
<p><a name="finding"></a>
=== Методы доступа к блокам и элементам</p>
<p>Работая с блоками, реализованными на ##bem-js##, необходимо использовать
встроенные методы для поиска блоков и их элементов. Эти методы доступны
в каждом блоке и умеют возвращать другой блок или ##jQuery## коллекцию (в случае
поиска элементов).</p>
<p>==== Методы поиска блоков</p>
<p>Поиск блоков осуществляется относительно текущего блока при помощи методов</p>
<h2 id="findblock-">findBlock*##.</h2>
<p>Реализуем блок ##b-my-block##, который находит первый из блоков ##b-form-checkbox##
внутри себя и вызывает у него метод ##toggle()## для переключения чекбокса.
%%hl js
BEM.DOM.decl(&#39;b-my-block&#39;, {
    onSetMod : {
        &#39;js&#39; : function() {
            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);
            checkbox.toggle();
        }
    }
});
%%</p>
<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>
<ul>
<li><h2 id="findblockinside-findblocksinside-dom-">findBlockInside/findBlocksInside## — поиск блока/блоков внутри ##DOM## элементов текущего блока или его элементов</h2>
</li>
<li><h2 id="findblockon-findblockson-dom-">findBlockOn/findBlocksOn## — поиск блока/блоков на ##DOM## элементах текущего блока или его элементов</h2>
</li>
<li><h2 id="findblockoutside-findblocksoutside-dom-">findBlockOutside/findBlocksOutside## — поиск блока/блоков снаружи ##DOM## элементов текущего блока или его элементов</h2>
</li>
</ul>
<p>Список методов поиска блоков и их сигнатуры можно посмотреть в
((/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki референсе по BEM.DOM)).</p>
<p>Примерами блоков, использующих методы поиска других блоков, могут быть:
((/blocks/b-smart-help/b-smart-help.wiki b-smart-help)),
((blocks/b-screenshot/b-screenshot.wiki b-screenshot)) и
((blocks/b-dropdowna/b-dropdowna.wiki b-dropdowna)).</p>
<p>==== Методы доступа к элементам
Для поиска элементов внутри блока используется метод ##elem##. Результат этого метода кэшируется.</p>
<p>Например:
%%hl js
BEM.DOM.decl(&#39;b-form-input&#39;, {</p>
<pre><code>doSomething : function() {

    this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint

}
</code></pre><p>});
%%</p>
<p>Можно искать элементы внутри блока с учетом модификатора:
%%hl js
BEM.DOM.decl(&#39;b-menu&#39;, {</p>
<pre><code>doSomething : function() {

    this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current

}
</code></pre><p>});
%%</p>
<p>Некэширующий метод поиска элементов называется ##findElem()##.</p>
<p>Полный список методов для поиска элементов и их сигнатуры можно найти в
((/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki референсе по BEM.DOM)).</p>
<p>%%hl xml
<a name="events"></a>
%%
=== Работа с событиями</p>
<p>==== События на блоках</p>
<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не ##DOM##) событий:</p>
<ul>
<li><h2 id="on-e-data-fn-ctx-e">on(e, [data], fn, [ctx])## — подписка на событие ##e</h2>
</li>
<li><h2 id="onfirst-e-data-fn-ctx-e">onFirst(e, [data], fn, [ctx])## — подписка только на первое событие ##e</h2>
</li>
<li><h2 id="un-e-fn-ctx-e-">un([e], [fn], [ctx])## — отписка от конкретного события ##e## или всех событий</h2>
</li>
<li><h2 id="trigger-e-data-e">trigger(e, [data])## — нотификация о событии  ##e</h2>
</li>
</ul>
<p>==== live-события на блоках</p>
<p>В ##bem-js## есть события, реализованные по паттерну
делегированных событий, они называются ##live## события.</p>
<p>Следующий пример демонстрирует работу с live-событием ##click## для блоков ##b-link##,
содержащихся в определённой ##DOM-ноде##. В данном случае контейнер и блок совпадают:
%%hl js
BEM.DOM.decl(&#39;b-link-example&#39;, {</p>
<pre><code>onSetMod: {
    &#39;js&#39;: function() {
        var link = this.findBlockInside(&#39;b-link&#39;);
        BEM.blocks[&#39;b-link&#39;]
            .liveCtxBind(link.domElem,
                        &#39;click&#39;,
                        function(){
                            link.domElem.text(&#39;Кликнутая ссылка&#39;);
                        },
                        this);
    }
}
</code></pre><p>},
{
    live: function() {
        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);
    }
}
);
%%</p>
<p>Метод ##.liveCtxBind()## реализует возможность реакции на bem-события блоков,
вложенных в какой-либо ##DOM## элемент. <strong>Это не DOM-события</strong>\
Использование ##live## событий позволяет избежать лишнего поиска блоков в ##DOM## дереве.
Кроме того, при такой привязке к событию реакция на событие блока из контейнера будет
происходить даже в том случае, если на момент привязки блока в контейнере не было, а он 
появился позже в результате динамического изменения документа.</p>
<p>Кроме возможности привязки к ##live## событию блока, здесь также продемонстрированы ((#blocks.finding поиск блока относительно текущего))
и ((#liveinit live-инициалиация)).\</p>
</div></div></div></body></html>