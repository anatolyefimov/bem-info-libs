{
    "repo": "bem-bl",
    "ref": "dev-docs",
    "url": "http://github.yandex-team.ru/bem/bem-bl",
    "changelog": null,
    "migration": null,
    "readme": "<h1 id=\"библиотека-блоков-bem-bl\">Библиотека блоков bem-bl</h1>\n<p><a href=\"http://bem.github.com/bem-bl/index.ru.html\">Описание библиотеки и примеры</a>.</p>\n<!-- Yandex.Metrika counter -->\n<img src=\"https://mc.yandex.ru/watch/12831025\" style=\"position:absolute; left:-9999px;\" alt=\"\" />\n<!-- /Yandex.Metrika counter -->\n",
    "levels": [
        {
            "name": "desktop.sets",
            "blocks": [
                {
                    "name": "b-icon",
                    "jsdoc": null,
                    "data": {
                        "name": "b-icon",
                        "description": [
                            {
                                "content": "<p>﻿Блок ##b-icon## создает контейнер для изображения.</p>\n<p>Aтрибуты ##alt, url, width, height## опциональны.\nТо есть могут быть объявлены или необъявлены во входных данных.</p>\n<h2 id=\"bemjson-\">BEMJSON## блока:</h2>\n<p>%%hl js\n{\n    block: &#39;b-icon&#39;\n}\n%%</p>\n<p>Выводит картинку (##img##) с однопиксельным прозрачным ##.gif## и пустым атрибутом ##alt##.</p>\n<p>Использовать блок можно двумя способами:</p>\n<ul>\n<li>через ##url##</li>\n<li>через модификатор</li>\n</ul>\n<p>==== Использование блока через ##url##</p>\n<p>Задаем в атрибуте ##url## свой путь к изображению, ##BEMJSON##:\n%%hl js\n{\n    block: &#39;b-icon&#39;,\n    url: &#39;my-icon.png&#39;,\n    alt: &#39;My icon&#39;\n}\n%%</p>\n<p>Этот способ рекомендуется для добавления одиночных картинок.</p>\n<p>==== Использование блока через добавление модификатора</p>\n<p>Добавляем блоку модификатор, ##BEMJSON##:\n%%hl js\n{\n    block: &#39;b-icon&#39;,\n    mods: { type: &#39;simple&#39; },\n    alt: &#39;My icon&#39;\n}\n%%</p>\n<p>В ##CSS## задаем размеры изображения и путь к нему:\n%%hl xml\n.b-icon_type_simple\n{\n    width: 16px;\n    height: 16px;</p>\n<pre><code>background: url(icons-sprite.png) no-repeat -50px 0;\n</code></pre><p>}\n%%</p>\n<p>Этот способ рекомендуется при использовании спрайтов.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-icon.examples/10-b-icon_src/_10-b-icon_src"
                            },
                            {
                                "url": "b-icon.examples/20-b-icon_css/_20-b-icon_css"
                            },
                            {
                                "url": "b-icon.examples/30-b-icon_sprite/_30-b-icon_sprite"
                            }
                        ]
                    }
                },
                {
                    "name": "b-layout-table",
                    "jsdoc": null,
                    "data": {
                        "name": "b-layout-table",
                        "description": [
                            {
                                "content": "<p>﻿Блок ##b-layout-table## — таблица со 100% шириной, для создания раскладки.</p>\n<p>Bemhtml шаблон блока выводит таблицу, строки и ячейки со всеми необходимыми атрибутами.</p>\n<p>Ячейки блока могут быть представлены либо елементом ##cell##, либо элементом ##gap##.\nЭлемент ##cell## предназначен для вложения контента, а элемент ##gap## служит распоркой.</p>\n<p>Давайте рассмотрим ##BEMJSON## блока:\n%%hl js\n{\n    block: &#39;b-layout-table&#39;,\n    mods: { layout: &#39;58-40&#39;},\n    content: [\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;gap&#39;,\n                    rowspan: &#39;2&#39;\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    content: {\n                        elem: &#39;inner&#39;,\n                        content: &#39;Left cell&#39;\n                    }\n                },\n                {\n                    elem: &#39;cell&#39;,\n                    elemMods: { position: &#39;r&#39;},\n                    content: &#39;Right cell&#39;\n                }\n            ]\n        },\n        {\n            elem: &#39;row&#39;,\n            content: [\n                {\n                    elem: &#39;cell&#39;,\n                    colspan: &#39;2&#39;,\n                    content: &#39;Second row and one cell&#39;\n                }\n            ]\n        }\n    ]\n}\n%%</p>\n<p>По умолчанию в блоке не задаются ширины ячейкам. Доопределить блок своими стилями можно следующим образом:\nдобавляем модификатор блоку — ##mods: { layout: &#39;58-40&#39; }## и ячейке — ##elemMods: { position: &#39;r&#39; }##.\nЭлементом ##inner## оборачиваем контент ячеек, что позволяет задать нужные нам отступы. Далее, используя каскад, задаем нужные нам ##CSS## свойства.</p>\n<p>Вот такой ##CSS## получится к ##BEMJSON##, приведенному выше:\n%%hl xml\n.b-layout-table_layout_58-40 .b-layout-table__cell_position_r\n{\n    width: 40%;\n}</p>\n<p>.b-layout-table_layout_58-40 .b-layout-table__gap\n{\n    width: 2%;\n    padding-left: 20px;\n}</p>\n<p>.b-layout-table_layout_58-40 .b-layout-table__inner\n{\n    margin-right: 0.8em;\n}\n%%</p>\n<p>Обратите внимание, что нельзя задавать самому блоку никаких дополнительных ##CSS## свойств, это может привести к конфликтам в\nверстке, так как блок может быть использован в реализации других блоков.</p>\n<p>Важно: использовать блок нужно, задавая ему модификатор или миксируя его с другим блоком/элементом.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-layout-table.examples/10-b-layout-table/_10-b-layout-table"
                            },
                            {
                                "url": "b-layout-table.examples/20-b-layout-table_rows/_20-b-layout-table_rows"
                            }
                        ]
                    }
                },
                {
                    "name": "b-link",
                    "jsdoc": null,
                    "data": {
                        "name": "b-link",
                        "description": [
                            {
                                "content": "<p>Блок ##b-link## — является ссылкой. Используется в других блоках.</p>\n<p>В простом случае для отображения блока необходимо задать следующий ##BEMJSON##:</p>\n<p>%%hl js\n{\n   block: &#39;b-link&#39;,\n   url: &#39;<a href=\"http://company.yandex.ru\">http://company.yandex.ru</a>&#39;,\n   title: &#39;Click here to learn more&#39;,\n   target: &#39;_blank&#39;,\n   content: &#39;The best company all over the world&#39;\n}\n%%</p>\n<p>Свойство ##url## преобразуется в атрибут ##href##. Свойства ##title## и ##target## — в соотвествующие атрибуты.</p>\n<p>﻿Делает ссылку или псевдоссылку неактивной.</p>\n<p>﻿Для удобного использования с иконками. Позволяет добавлять в ссылку элемент ##inner##. Содержит только ##CSS##,\nкоторые переносит подчеркивание с самой ссылки на ее внутренний элемент.</p>\n<p>Модификация ссылки, подразумевающая действие без перехода на другую страницу.\nВизуально имеет пунктирное нижнее подчеркивание.</p>\n<p>﻿Опциональный элемент, в который помещается текстовое содержимое ссылки.\nНеобходим, когда ссылка содержит графический контент, например, иконку.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-link.examples/10-b-link_link/_10-b-link_link"
                            },
                            {
                                "url": "b-link.examples/20-b-link_pseudo/_20-b-link_pseudo"
                            },
                            {
                                "url": "b-link.examples/30-b-link_inner/_30-b-link_inner"
                            },
                            {
                                "url": "b-link.examples/40-b-link_dynamic-pseudo/_40-b-link_dynamic-pseudo"
                            }
                        ]
                    }
                },
                {
                    "name": "b-logo",
                    "jsdoc": null,
                    "data": {
                        "name": "b-logo",
                        "description": [
                            {
                                "content": "<p>﻿Блок использует внутри себя абстрактную иконку ##b-icon## и ссылку ##b-link##.\nЭти блоки миксируются в ##BEMHTML## шаблоне с соответствующими элементами блока ##b-logo##.</p>\n<p>Обычно логотип представляет собой ссылку с изображением. ##BEMJSON## для этого варианта:\n%%hl js\n{\n    block: &#39;b-logo&#39;,\n    content: {\n        elem: &#39;link&#39;,\n        url: &#39;/&#39;,\n        title: &#39;logo&#39;,\n        icon: {\n            elem: &#39;icon&#39;,\n            url: &#39;http://...&#39;,\n            alt: &#39;logo&#39;\n        }\n    }\n}\n%%</p>\n<p>В некоторых случах, в ссылке, может находится не только иконка, но и текст,\nтогда ##BEMJSON## блока будет выглядеть следующим образом:\n%%hl js\n{\n    block: &#39;b-logo&#39;,\n    content: {\n        elem: &#39;link&#39;,\n        url: &#39;/&#39;,\n        content: [\n            {\n                elem: &#39;icon&#39;,\n                url: &#39;http://...&#39;,\n            },\n            {\n                elem: &#39;slogan&#39;,\n                content: &#39;Trademark slogan&#39;\n            }\n        ]\n    }\n}\n%%</p>\n<p>Если вам не нужна ссылка, то можно обойтись и просто изображением, ##BEMJSON## будет еще проще:\n%%hl js\n{\n    block: &#39;b-logo&#39;,\n    content: {\n        elem: &#39;icon&#39;,\n        url: &#39;/&#39;,\n        alt: &#39;logo&#39;\n    }\n}\n%%</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-logo.examples/10-b-logo/_10-b-logo"
                            },
                            {
                                "url": "b-logo.examples/20-b-logo_link/_20-b-logo_link"
                            },
                            {
                                "url": "b-logo.examples/30-b-logo_slogan/_30-b-logo_slogan"
                            }
                        ]
                    }
                },
                {
                    "name": "b-menu-horiz",
                    "jsdoc": null,
                    "data": {
                        "name": "b-menu-horiz",
                        "description": [
                            {
                                "content": "<p>﻿Блок ##b-menu-horiz## создаёт ##HTML## разметку для горизонтального меню. Кроме того,\nу блока есть ##JavaScript## функциональность, позволяющая создавать скрипты с реакцией на\nвыбор пункта меню.</p>\n<p>Сложность ##HTML## разметки меню зависит от модификатора, с которым используется блок.</p>\n<p>Реализован модификатор блока ##layout## с тремя возможными значениями:</p>\n<ul>\n<li><h2 id=\"horiz\">horiz</h2>\n</li>\n<li><h2 id=\"complex\">complex</h2>\n</li>\n<li><h2 id=\"normal\">normal</h2>\n</li>\n</ul>\n<p><strong>Важно:</strong> Без модификатоора  ##layout## блок использоваться не может.</p>\n<p>﻿Использование блока с модификатором ##{ layout: &#39;complex&#39; }## принципиально ничем не отличается.\nДля блока в такой модификации создаётся разметка на основе таблицы. Такое решение может\nпотребоваться при некоторых дизайнах.</p>\n<p>﻿Входные данные для блока с любым из этих модификаторов похожи: нужно описать блок, модификатор</p>\n<h2 id=\"layout-content-\">layout##, в качестве свойства ##content## блока перечислить пункты меню, которые выражаются</h2>\n<p>элементами ##item##:\n%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Home&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Office&#39;\n    },\n    ...\n  ]\n}\n%%</p>\n<p>Содержанием элементов меню может быть что угодно: ссылки на страницы, псевдоссылки,\nиконки и вообще любые блоки. В примере выше каждый пункт меню — это просто строка текста.</p>\n<p>Такое же меню со ссылками будет выглядеть следующим образом:\n%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/office&#39;, content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>Кроме того, у одного из пунктов меню может быть указан модификатор ##{ state: &#39;current&#39; }##,\nэтот модификатор помечает текущий пункт меню.</p>\n<p>На своём уровне переопределения можно реализовать для такого модификатора ##CSS## правила, по\nкоторым текущий пункт меню будет визуально отличаться от остальных.</p>\n<p>У меню также может быть необязательное свойство ##title##, содержащее описание элемента</p>\n<h2 id=\"title-\">title## — заголовка меню.</h2>\n<p>Для меню с заголовком ##BEMJSON## будет такой:\n%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/office&#39;, content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>==== Горизонтальное меню с клиентской функциональностью</p>\n<p>Не всегда меню на сайте подразумевает ссылки, уводящие пользователя на другую\nстраницу. Меню может использоваться и для клиентского ##JavaScript## приложения.\nВ этом случае содержанием пунктов меню обычно бывают псевдоссылки:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        url: &#39;/&#39;,\n        content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        url: &#39;/office&#39;,\n        content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>Приведённый выше ##BEMJSON## блока обеспечит нужный внешний вид.\\\nКроме этого нужно, чтобы у меню были области, реагирующие на клик. В данном случае\nони совпадают с псевдоссылками, поэтому можно применить смешивание блоков (##mix##):</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;normal&#39; },\n  title: {\n    elem: &#39;title&#39;, content: &#39;Navigation:&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-horiz&#39;, elem : &#39;item-selector&#39; }],\n        url: &#39;/&#39;,\n        content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-horiz&#39;, elem : &#39;item-selector&#39; }],\n        url: &#39;/office&#39;,\n        content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<h2 id=\"javascript-\">JavaScript## код блока реализован так, что активный пункт меню переключается</h2>\n<p>при клике левой кнопкой мыши на соответствующем элементе ##item-selector##.</p>\n<p>При явном использовании этот элемент представлен в ##DOM## в виде span, в который можно положить\nблоки, составляющие пункт меню. Если же содержание пункта меню состоит всего из\nодного блока (как в примере с псевдоссылками), для экономии разметки разумно\nприменять ##mix##.</p>\n<p>Кроме того, что соответствующий элемент ##item## в результате клика приобретает\nмодификатор ##{ state: &#39;current&#39; }##, на ##BEM## объекте блока возникает событие ##current##,\nсопровождающееся данными о текущем и предыдущем активных пунктах.\nВ своём ##JavaScript## приложении можно реагировать на это событие.</p>\n<p>В ##HTML## по умолчанию блок представлен как имеющий ##JavaScript## реализацию (он смешан с блоком ##i-bem## и\nимеет соответствующие параметры в атрибуте ##onclick##). Но если в блоке\nотсутствуют элементы ##item-selector##, ##BEM## объект блока не создаётся.</p>\n<p>==== Меню без подмешивания блока i-bem</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  js: false,\n  mods: { layout: &#39;normal&#39; },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/&#39;, content: &#39;Home&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;, url: &#39;/office&#39;, content: &#39;Office&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>Примешивание блока ##i-bem## можно устранить, указав в свойстве ##js## блока значение ##false##.</p>\n<p>﻿В некоторых случаях для вывода меню не нужны даже ##DOM## узлы списка, а достаточно просто\nперечислить ссылки, разделив их пробелом, запятой или каким-либо специальным символом.</p>\n<p>Для вывода такого меню подходит реализация с модификатором ##{ layout: &#39;normal&#39; }##:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-horiz&#39;,\n  mods: { layout: &#39;simple&#39; },\n  separator: &#39; | &#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: &#39;Home&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n      block: &#39;b-link&#39;,\n      url: &#39;/&#39;,\n      content: &#39;Products&#39;\n    },\n    ...\n  ]\n}\n%%</p>\n<h2 id=\"bemjson-separator-\">BEMJSON## меню отличается наличием свойства ##separator## — того самого специального</h2>\n<p>символа, который разделяет пункты меню.\\\nАктивный пункт меню в данном примере представлен в виде простого текста в теге ##span##.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-menu-horiz.examples/05-b-menu-horiz_simple/_05-b-menu-horiz_simple"
                            },
                            {
                                "url": "b-menu-horiz.examples/10-b-menu-horiz_normal/_10-b-menu-horiz_normal"
                            },
                            {
                                "url": "b-menu-horiz.examples/20-b-menu-horiz_complex/_20-b-menu-horiz_complex"
                            },
                            {
                                "url": "b-menu-horiz.examples/30-b-menu-horiz_normal-js/_30-b-menu-horiz_normal-js"
                            }
                        ]
                    }
                },
                {
                    "name": "b-menu-vert",
                    "jsdoc": null,
                    "data": {
                        "name": "b-menu-vert",
                        "description": [
                            {
                                "content": "<p>﻿Блок, создает разметку для вертикального меню. Построен на основе блока-хелпера ##i-menu##.</p>\n<p>==== Простое вертикальное меню\nВ простейшем случае в ##BEMJSON## достаточно объявить блок и перечислить его элементы ##item## в свойстве ##content##:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Index&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: &#39;Contacts&#39;\n    },\n    ...\n  ]\n}\n%%</p>\n<p>В получившемся ##HTML## появляются не только узлы для блока и явно заданных элементов ##item##, но и\nразметка для элементов ##layout## и ##layout-unit##, которые отвечают за геометрическую отрисовку блока.</p>\n<p>В качестве контента элементов ##item## в простых случаях используются ссылки:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;,\n        url: &#39;<a href=\"http://yandex.com\">http://yandex.com</a>&#39;,\n        content: &#39;Index&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>У одного из элементов ##item## может быть модификатор ##{ state: &#39;current&#39; }##,\nотмечающий выделенный пункт меню. Модификатор используется как для визуального выделения\nпункта при помощи ##CSS##-правил для этого модификатора, так и для описания функционального\nповедения.</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        url: &#39;<a href=\"http://yandex.com\">http://yandex.com</a>&#39;,\n        content: &#39;Index&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: { ... }\n  ]\n}\n%%</p>\n<p>Для отображения заголовка меню (элемент ##title##), в ##BEMJSON## необходимо указать свойство ##title##:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  title: {\n    elem: &#39;title&#39;,\n    content: &#39;Menu title&#39;\n  },\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        url: &#39;<a href=\"http://yandex.com\">http://yandex.com</a>&#39;,\n        content: &#39;Index&#39;\n      }\n    },\n    {\n      elem: &#39;item&#39;,\n      content: { ... }\n  ]\n}\n%%</p>\n<p>Предусмотрена возможность создания пустого элемента списка для визуального\nразделения одних пунктов от других. За это отвечает элемент ##separator##.\nДля этого на уровне переопределения проекта нужно задать ##CSS##-правила для него.\nЧаще всего ##separator## представляют в виде горизонтальной черты.</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      content: { ... }\n    },\n    {\n      elem: &#39;separator&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: { ... }\n    }\n  ]\n}\n%%</p>\n<p>==== Вертикальное js-меню с псевдоссылками</p>\n<p>В ##BEMJSON## доопределяем обычные ссылки до псевдо-ссылок, используя модификатор ##{ pseudo: &#39;yes&#39; }##:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { &#39;state&#39;: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { &#39;pseudo&#39;: &#39;yes&#39; },\n        content: &#39;First point&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>Кроме внешнего вида, ##js##-меню отличается и клиентской функциональностью: оно\nспособно по клику левой кнопкой мыши переключать соответствующий пункт меню\nв состояние ##{ state: &#39;current&#39; }## и генерировать на ##js##-объекте, соответствующем блоку,\nсобытие о факте переключения пункта меню.</p>\n<p>Для использования этой функциональности необходимо определить ((#__item-selector элементы ##item-selector##)). Эти элементы специально не совпадают\nс элементами ##item##, потому что чаще всего сам пункт меню больше по размеру, чем его активная область.</p>\n<p>Элемент ##item-selector## можно использовать как сам по себе, так и примешивая его\nк другим элементам или блокам. В данном случае можно сделать ##mix## с псевдоссылками:</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { &#39;state&#39;: &#39;current&#39; },\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { &#39;pseudo&#39;: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;item-selector&#39; }],\n        url: &#39;/&#39;,\n        content: &#39;First point&#39;\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>==== Вертикальное js-меню со сложным контентом</p>\n<p>Пункты меню могут содержать не один, а несколько блоков.</p>\n<p>Поскольку реакция на клик необходима для всего содержания пункта меню, элемент ##item-selector##\nиспользуется в таком случае в явном виде, являясь контейнером для содержания пункта меню.\nВ этом случае он представлен в ##DOM##-дереве узлом ##span##:</p>\n<p>%%hl js\n{\n  elem: &#39;item&#39;,\n  content: {\n    elem: &#39;item-selector&#39;,\n    content: [\n      {\n        block: &#39;b-link&#39;,\n        mods: { &#39;pseudo&#39;: &#39;yes&#39;, &#39;inner&#39;: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;item-selector&#39; }],\n        url: &#39;/&#39;,\n        content: [\n          {\n            block: &#39;b-icon&#39;,\n            url: &#39;/&#39;,\n            alt: &#39;Yandex favicon&#39;\n          },\n          {\n            elem: &#39;inner&#39;,\n            content: &#39;Second point&#39;\n          }\n        ]\n      },\n      &#39; One more element here&#39;\n    ]\n  }\n}\n%%</p>\n<p>==== Раскрывающееся вертикальное js-меню</p>\n<p>Переключение активного пункта меню — не единственная реализованная\nдинамическая функциональность. Пункты меню также могут содержать элементы</p>\n<h2 id=\"trigger-\">trigger##, клик по которым открывает или скрывает дочерний контент. С помощью</h2>\n<p>таких элементов можно реализовать скрывающиеся вложенные меню.</p>\n<p>Так же, как и элемент ##item-selector##, элемент ##trigger## может использоваться\nне явно, а через ##mix##.</p>\n<p>%%hl js\n{\n  block: &#39;b-menu-vert&#39;,\n  content: [\n    {\n      elem: &#39;item&#39;,\n      elemMods: { state: &#39;current&#39; },\n      content: &#39;Videos&#39;\n    },\n    {\n      elem: &#39;item&#39;,\n      content: {\n        block: &#39;b-link&#39;,\n        mods: { pseudo: &#39;yes&#39;, inner: &#39;yes&#39; },\n        mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;trigger&#39; }],\n        content: [\n          {\n            block: &#39;b-icon&#39;,\n            mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;trigger-icon&#39; }],\n            alt: &#39;trigger&#39;\n          },\n          {\n            elem: &#39;inner&#39;,\n            content: &#39;Images&#39;\n          }\n        ]\n      },\n      &#39;item-content&#39;: {\n        elem: &#39;item-content&#39;,\n        content: {\n          block: &#39;b-menu-vert&#39;,\n          mods: { &#39;type&#39;: &#39;submenu&#39; },\n          content: [\n            {\n              elem: &#39;item&#39;,\n              content: &#39;Any size&#39;\n            },\n            {\n              elem: &#39;item&#39;,\n              content: &#39;Large&#39;\n            },\n            {\n              elem: &#39;item&#39;,\n              content: &#39;Medium&#39;\n            }\n          ]\n        }\n      }\n    },\n    ...\n  ]\n}\n%%</p>\n<p>Кроме элемента ##item-selector## здесь используется свойство ##item-content##, описывающее\nэлемент ##item-content## с содержанием, которое показывается или скрывается в зависимости\nот кликов по элементу ##item-selector##.</p>\n<p>Элемент ##trigger-icon## используется только для обозначения иконки. Не является обязательным элементом.</p>\n<p>По умолчанию элемент ##trigger## не содержит модификатора ##state##, а элемент ##item-content##\nне содержит модификатора ##visibility##. В этом состоянии содержание элемента ##item-content## не видно.\\\nПри клике на элементе ##trigger## левой кнопкой мыши он приобретает модификатор</p>\n<h2 id=\"-state-opened-item-content-\">{ state: &#39;opened&#39; }##. Элемент ##item-content## в это же время приобретает</h2>\n<p>модификатор ##{ visibility: &#39;visible&#39; }## и становится виден на странице.</p>\n<p>Если нужно сразу показать вложенное меню раскрытым, эти модификаторы\nследует явно задать в ##BEMJSON##-описании блока:</p>\n<p>%%hl js\n{\n  block: &#39;b-link&#39;,\n  mods: { pseudo: &#39;yes&#39;, inner: &#39;yes&#39; },\n  mix: [{ block: &#39;b-menu-vert&#39;, elem: &#39;trigger&#39;, elemMods: { state: &#39;opened&#39; } }],\n  content: { ... }\n}\n%%</p>\n<p>%%hl js\n&#39;item-content&#39;: {\n  elem: &#39;item-content&#39;,\n  elemMods: { visibility: &#39;visible&#39; },\n  content: [ ... ]\n%%</p>\n<p>==== Вложенные меню</p>\n<h2 id=\"bemjson-\">BEMJSON## позволяет вкладывать одни блоки в другие. Содержанием пункта меню может быть</h2>\n<p>другое меню, и тогда естественным образом образуется вложенность.\\\nТакое использование меню создаст в ##DOM##-дереве два блока (и два узла ##ul##), которые\nбудут вести себя соответственно.</p>\n<p>Если есть необходимость визуально представить меню как вложенное, но функционально —\nкак один блок (например, со сквозным поведением активного пункта меню), нужно\nвоспользоваться элементом ##submenu##.</p>\n<p>Элемент ##submenu## должен содержаться в элементе ##item-content## и включать в\nсебя описание элементов ##item## для вложеннего меню.</p>\n<p>Элемент вертикального меню, может содержать любой контент, чаще всего это ссылки или псевдо-ссылки.\\\nИмеет состояния: ##[ current, disabled ]##</p>\n<p>﻿Не используется без элемента ##item-selector##. По умолчанию невидим.\n﻿Добавление этого модификатора делает видимым элемент ##item-content##.</p>\n<p>﻿Этот элемент появляется в меню, когда требуется реакция на клик по\nпункту меню.\\\nРеакция на клик может понадобиться, если при выборе пункта меню нужно\nчто-то сделать на клиенте. Например, загрузить контент по ##AJAX##.</p>\n<p>Реакция есть только на клик левой кнопкой мыши. В результате клика соответствующий\nпункт меню (элемент ##item##) приобретает модификатор ##{ state: &#39;current&#39; }##, то\nесть пункт меню становится «выделенным» (текущим). Предыдущий выделенный пункт меню в то же время\nтеряет модификатор ##state##.\\\nВ базовой ##CSS##-реализации блока не предоставляется код для визуального\nвыделения текущего пункта меню. Такой код можно реализовать на собственном уровне\nпереопределения.</p>\n<p>Элемент может быть представлен в ##DOM## отдельным узлом (##span##) или быть\nсмиксованным с другим блоком, чаще всего с псевдо-ссылкой.</p>\n<p>Используется в случае, когда необходимо представить вложенное меню\nчастью списка «меню-родителя».</p>\n<p>Опциональный элемент. В ##HTML## представлен тегом ##h3##, выводится перед списком (##ul##).\nМожет содержать внутри себя опциональный элемент ##trigger-icon##, который используется для отображения иконок.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-menu-vert.examples/10-b-menu-vert_simple/_10-b-menu-vert_simple"
                            },
                            {
                                "url": "b-menu-vert.examples/20-b-menu-vert_js/_20-b-menu-vert_js"
                            },
                            {
                                "url": "b-menu-vert.examples/30-b-menu-vert_js-complex/_30-b-menu-vert_js-complex"
                            },
                            {
                                "url": "b-menu-vert.examples/40-b-menu-vert_trigger/_40-b-menu-vert_trigger"
                            },
                            {
                                "url": "b-menu-vert.examples/50-b-menu-vert_trigger-deep/_50-b-menu-vert_trigger-deep"
                            },
                            {
                                "url": "b-menu-vert.examples/60-b-menu-vert_submenu/_60-b-menu-vert_submenu"
                            },
                            {
                                "url": "b-menu-vert.examples/70-b-menu-vert_submenu-trigger/_70-b-menu-vert_submenu-trigger"
                            }
                        ]
                    }
                },
                {
                    "name": "b-page",
                    "jsdoc": null,
                    "data": {
                        "name": "b-page",
                        "description": [
                            {
                                "content": "<p>﻿Блок ##b-page## создаёт теги верхнего уровня страницы:</p>\n<ul>\n<li><h2 id=\"-html-\"><html></h2>\n</li>\n<li><h2 id=\"-head-\"><head></h2>\n</li>\n<li><h2 id=\"-body-\"><body></h2>\n</li>\n</ul>\n<p>Именно он отвечает за то, какие подключить ##CSS## и ##JS## файлы к странице,\nвыставление ##meta## тегов, заголовка и так далее.</p>\n<p>Декларация блока в ##BEMJSON## начинается объявлением блока и\nуказанием свойства ##title##, которое превращается в тег ##<title>## в ##HTML##.</p>\n<p>%%hl js\n({\nblock: &#39;b-page&#39;,\ntitle: &#39;Page with link&#39;,\n...\n})\n%%</p>\n<p>Указание свойства ##head## дополняет элемент ##head##, соответствующий ##HTML## тегу ##<head>##,\nэлементами для подключения ##CSS## и ##JS## файлов:</p>\n<p>%%hl js\n({\n...\nhead: [\n    { elem: &#39;css&#39;, url: &#39;example.css&#39;, ie: false },\n    { elem: &#39;css&#39;, url: &#39;example.ie.css&#39;, ie: &#39;lt IE 8&#39; },\n    { elem: &#39;js&#39;, url: &#39;example.js&#39; }\n],\n...\n})\n%%</p>\n<p>Элемент ##css## превращается в ##HTML## в тег ##<link>##, подключающий как ##CSS## стиль тот файл,\nчто указан в свойстве ##url## этого элемента. Также у такого элемента может быть свойство ##ie##.\nЕсли это свойство ##false##, то будут использоваться такие ##condittional\ncomments##, которые предотвратят использование этих стилей в ##IE##. При\nстрочном значении этого свойства тег ##<link>## , будет обёрнут в соответствующий ##conditional\ncomment##, и этот стиль будет грузиться и использоваться указанных\nбраузерах.\\\nТакже есть возможность указывать свойство ##content## для содержания тега ##<style>##:</p>\n<p>%%hl js\n({\n...\nhead: [\n    {\n        elem: &#39;css&#39;,\n        content: &#39;.b-blah { color: #f00&#39; }\n    },\n    ...\n],\n...\n})\n%%</p>\n<p>Элемент ##js## действует аналогично, подключая к странице ##JS## файлы при помощи тега</p>\n<h2 id=\"-script-\"><script>##.</h2>\n<p>Свойство ##head## не описывает содержание ##HTML##-тега ##<head>## полностью, а лишь\nдополняет дефолтное, которое блок сам создаёт в своём ##BEMHTML## шаблоне.</p>\n<p>==== Тег <meta> с указанием кодировки</p>\n<h2 id=\"bemhtml-\">BEMHTML##:</h2>\n<p>%%hl js\ncontent: [\n{\n    tag: &#39;meta&#39;,\n    attrs: { &#39;http-equiv&#39;: &#39;content-type&#39;, content: &#39;text/html; charset=utf-8&#39; }\n},\n...\n%%</p>\n<p>==== Тег <meta> для использования ##IE9## (и выше) в максимальном ##compatibility## режиме</p>\n<h2 id=\"bemhtml-\">BEMHTML##:</h2>\n<p>%%hl js\ncontent: [\n...\n{\n    tag: &#39;meta&#39;,\n    attrs: { &#39;http-equiv&#39;: &#39;X-UA-Compatible&#39;, content: &#39;IE=EmulateIE7, IE=edge&#39; }\n},\n...\n%%</p>\n<p>==== Выставление значения тега <title> страницы из свойства</p>\n<p>%%hl js\ncontent: [\n...\n{\n    tag: &#39;title&#39;,\n    content: this.ctx.title\n},\n...\n%%</p>\n<p>==== Выставление фавиконки</p>\n<p>%%hl js\ncontent: [\n...\nthis.ctx.favicon ? {\n    elem: &#39;favicon&#39;,\n    url: this.ctx.favicon\n} : &#39;&#39;,\n...\n%%</p>\n<p>==== Декларация блока i-ua</p>\n<p>%%hl js\ncontent: [\n...\n{\n    block: &#39;i-ua&#39;\n},\n...\n%%</p>\n<p>Аналогично указанию свойства ##head##, может быть задано свойство ##meta##,\nсодержашее один или несколько элементов ##meta##:</p>\n<p>%%hl js\n({\n...\nmeta: {\n    elem: &#39;meta&#39;,\n    attrs: {\n        name: &#39;keywords&#39;,\n        content: &#39;js, css, html&#39;\n    }\n},\n...\n})\n%%</p>\n<p>%%hl js\n({\n...\nmeta: [\n    {\n        elem: &#39;meta&#39;,\n        attrs: {\n            name: &#39;keywords&#39;,\n            content: &#39;js, css, html&#39;\n        }\n    },\n    {\n        elem: &#39;meta&#39;,\n        attrs: {\n            name : &#39;description&#39;,\n            content : &#39;Yet another webdev blog&#39;\n        }\n    }\n]\n...\n})\n%%</p>\n<p>Значением свойства ##content## блока ##b-page## может быть хеш-описание содержимого\n(если речь идёт лишь об одном блоке) или массив блоков, описанных хешами:</p>\n<p>%%hl js\n({\n...\ncontent: {\n    block: &#39;b-link&#39;,\n    mods: { pseudo: &#39;yes&#39;, togcolor: &#39;yes&#39;, color: &#39;green&#39; },\n    url: &#39;#&#39;,\n    target: &#39;_blank&#39;,\n    title: &#39;Кликни меня&#39;,\n    content: &#39;Псевдоссылка, меняющая цвет по клику&#39;\n}\n})\n%%</p>\n<p>На блоки, содержащиеся в ##content##, действуют их ##BEMHTML## шаблоны.</p>\n<p>==== Отмена автоматической инициализации блоков</p>\n<p>%%hl js\nnoDeps: [\n    { block: &#39;i-bem&#39;, elem: &#39;dom&#39;, mods: { init: &#39;auto&#39; } }\n]\n%%</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-page.examples/10-b-page_simple/_10-b-page_simple"
                            },
                            {
                                "url": "b-page.examples/20-b-page_simple/_20-b-page_simple"
                            },
                            {
                                "url": "b-page.examples/30-b-page_with-js/_30-b-page_with-js"
                            },
                            {
                                "url": "b-page.examples/40-b-page_with-level/_40-b-page_with-level"
                            },
                            {
                                "url": "b-page.examples/60page-nodeps_bem/_60page-nodeps_bem"
                            }
                        ]
                    }
                },
                {
                    "name": "b-search",
                    "jsdoc": null,
                    "data": {
                        "name": "b-search",
                        "description": [
                            {
                                "content": "<p>﻿Поисковая форма, содержащая поле ввода и кнопку.</p>\n<p>Сам блок ##b-search##, преобразуется в тег ##<form>##, внутри которого лежит ((#__layout элемент layout)),\nотвечающий за раскладку блока.</p>\n<p>Рассмотрим ##BEMJSON## блока:\n%%hl js\n{\n    block: &#39;b-search&#39;,\n    attrs: { action: &#39;/search.xml&#39; },\n    input: {\n        elem: &#39;input&#39;\n    },\n    button: {\n        elem: &#39;button&#39;\n    },\n    under: {\n        block: &#39;b-link&#39;,\n        url: &#39;/&#39;,\n        content: &#39;Advanced search&#39;\n    }\n}\n%%</p>\n<p>По умолчанию элемент ##input## является поисковой строкой (##type: &#39;text&#39;##).\nЭлемент ##button## — кнопкой ##type: &#39;submit&#39;##.</p>\n<p>Если вам необходимо добавить атрибуты этим элементам или самому блоку,\nдостаточно в ##BEMJSON## описать свойство ##attrs##,\nи перечислить в нем все необходимые атрибуты.</p>\n<h2 id=\"bemjson-\">BEMJSON##:</h2>\n<p>%%hl js\n{\n    block: &#39;b-search&#39;,\n    attrs: { action: &#39;/search.xml&#39;, id: &#39;myForm&#39; }\n    input: {\n        elem: &#39;input&#39;,\n        attrs: { value: &#39;Some text&#39;, id: &#39;myInput&#39; }\n    },\n    button: {\n        elem: &#39;button&#39;,\n        attrs: { value: &#39;My search&#39;, id: &#39;myButton&#39; }\n    }\n}\n%%\n﻿Элемент ##layout## миксируется с блоком ##b-layout-table## в</p>\n<h2 id=\"bemhtml-b-search-\">BEMHTML## шаблоне блока ##b-search##.</h2>\n<p>Свойства ##input##, ##button##, ##under##, представляют собой элементы для раскладки</p>\n<h2 id=\"-layout-input-layout-button-layout-under-cell-\">[ layout-input, layout-button, layout-under ]##, которые миксируются с элементами ##cell## блока</h2>\n<h2 id=\"b-layout-table-html-\">b-layout-table##, преобразуясь в ##HTML## в ячейки таблицы.</h2>\n<p>Свойство ##under## добавляет еще одну строку с ячейкой, в нее можно помещать дополнительную информацию.\nНапример, ссылка «Расширенный поиск» под поисковым полем.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-search.examples/10-b-search/_10-b-search"
                            },
                            {
                                "url": "b-search.examples/20-b-search_under/_20-b-search_under"
                            }
                        ]
                    }
                },
                {
                    "name": "b-text",
                    "jsdoc": null,
                    "data": {
                        "name": "b-text",
                        "description": [
                            {
                                "content": "<p>Блок ##b-text## обеспечивает единообразие оформления.</p>\n<p>Позволяет задавать произвольные элементы, которые продуцируются в одноименные ##HTML##-теги.</p>\n<p>Для содержимого блока определены базовые стили заголовков, списков, начертания текста.\\\nКаждому элементу блока соотвествует в ##CSS## реализации свой класс. Это позволяет избежать\nкаскада при использовании блока, что в свою очередь уменьшает ##reflow time## страницы.</p>\n<p>Позволяет стилизировать текст, редактируемый через всевозможные ##wysiwyg##-редакторы.</p>\n<p>Не рекомендован к использованию, так как его реализация не соответвует ##BEM## подходу.</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "b-text.examples/10-b-text_simple/_10-b-text_simple"
                            }
                        ]
                    }
                },
                {
                    "name": "i-bem",
                    "jsdoc": null,
                    "data": {
                        "name": "i-bem",
                        "description": [
                            {
                                "content": "<p>Блок ##i-bem## — это блок-хелпер, позволяющий создавать другие блоки.\nБлок реализован в технологиях ##BEMHTML## и ##JS##. Обе эти реализации\nявляются ядром библиотеки блоков в соответствующих технологиях.</p>\n<p>=== js-реализация блока i-bem</p>\n<p>Реализация блока ##i-bem## в ##JS## обеспечивает хелперы для представления\nблока в виде ##JS## объекта с определёнными методами и свойствами. Это нужно, чтобы\nписать клиентский ##JS## в терминах ##BEM##. То есть ##JS## оперирует более высоким уровнем\nабстрации, чем ##DOM## представление.</p>\n<p>Для того, чтобы js-представление блока использовало ядро ##i-bem##, оно должно\nбыть написано с соблюдением специальных правил.</p>\n<p>===== Что описано на этой странице?</p>\n<ul>\n<li>Какие бывают блоки<ul>\n<li>((#dom.blocks Блоки с DOM-представлением))</li>\n<li>((#abstract.blocks Блоки без DOM-представления))</li>\n</ul>\n</li>\n<li>Принципы и особенности подхода<ul>\n<li>((#decl Декларативный принцип))</li>\n<li>((#block.getting Доступ к другим блокам))</li>\n<li>((#mods Работа с модификаторами))</li>\n<li>((#customization Кастомизация блоков))</li>\n</ul>\n</li>\n<li>((#creation Создание собственного bem-js блока))</li>\n<li>Подробнее о понятиях<ul>\n<li>((#init Инициализация))</li>\n<li>((#liveinit Инициализация по требованию (live-инициализация~)))</li>\n<li>((#finding Методы доступа к блокам и элементам))</li>\n<li>((#events Работа с событиями))</li>\n</ul>\n</li>\n</ul>\n<p>%%hl xml\n<a name=\"dom.blocks\"></a>\n%%\n===== Блоки с DOM-представлением\nБлокам, реализованным на ##bem-js##, могут соответствовать ноды в ##HTML##. В этом случае говорится о\nтом, что блоки имеют ##DOM## представление.\\\nВ ##HTML## блоки на ##bem-js## отличаются дополнительным ##CSS## классом ##i-bem##\nи специальным форматом записи параметров блока в ##onclick##:</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block i-bem\" onclick=\"return { 'b-my-block' : { name : 'b-my-block'}}\">\n...\n</div>\n%%</p>\n<p>Ниже подробно рассказано о ((#onclick.params формате параметров в onclick)).</p>\n<p>%%hl xml\n<a name=\"abstract.blocks\"></a>\n%%\n===== Блоки без DOM-представления\nТехнология ##bem-js## позволяет также создавать блоки, не имеющие ##DOM## представления.\nТакие блоки тем не менее существуют в ##JS## в виде объектов, манипулировать ими\nможно так же, как и блоками с ##DOM## представлением.</p>\n<p>О том, как создавать такие блоки, написано под заголовком\n((#dom.decl Декларация блока)).</p>\n<p>Блоки, реализованные на ##bem-js##,  после инициализации представлены в ##js## объектами,\nимеющими свои методы. Эти методы необходимо использовать, если нужно повлиять на внешний\nвид или поведение блока.\\\nТехнология ##bem-js## использует предметную область ((<a href=\"http://wiki.yandex-team.ru/lento4ka/bem\">http://wiki.yandex-team.ru/lento4ka/bem</a> концепции ##BEM##)).\nВсе сущности являются\nблоками или их элементами, управление их состояниями реализуется при помощи модификаторов.\\\nПредставление блока в ##js## не обязано иметь взаимное соответствие с одной ##DOM##-нодой.\nМожно разместить несколько\nблоков на одной ##DOM##-ноде (это называется ##mix##), а также реализовать один блок на нескольких ##DOM##-нодах.\\\nДалее блок, использующий технологию ##bem-js##,\nбудет называться ##блок, реализованный на bem-js##, или ##bem-js-блок##. Примером такого\nблока в библиотеке может служить ##b-link##.</p>\n<p>%%hl xml\n<a name=\"decl\"></a>\n%%\n=== Декларативный принцип</p>\n<p>Важной особенностью технологии ##bem-js## является декларативный принцип. Подобно\nработе декларативных языков программирования, ##js##-код содержит не последовательный\nалгоритм работы блока, а набор действий и условий, при которых эти действия необходимо выполнять.</p>\n<p>==== Декларация блока\nДекларативность проявляется в объявлении того, к каким блокам или их модификациям\nприменим код компонента:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-link&#39;, {\n...\n%%</p>\n<p>%%hl js\nBEM.DOM.decl({ name : &#39;b-domik&#39;, modName : &#39;type&#39;, modVal : &#39;popup&#39; }, {\n...\n%%</p>\n<p>((#dom.decl Подробнее о декларации блока))</p>\n<p>%%hl xml\n<a name=\"mods.reaction\"></a>\n%%\n==== Реакция на изменение модификаторов\nСогласно концепции, состояния блока или его элементов определяются модификаторами.\nПоэтому, чтобы динамически изменять состояния блоков и элементов, в ##bem-js## есть\nспециальные методы для установки и снятия модификаторов.</p>\n<p>В коде компонента можно записать, как блок или элемент должен отреагировать на изменение модификатора.\nЭта запись тоже декларативна.\\\nНапример, блок ##b-dropdowna## при установке модификатора ##disabled## прячет показанный попап:\n%%hl js\nBEM.DOM.decl(&#39;b-dropdowna&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;disabled&#39; : function(modName, modVal) {\n\n        this._getSwitcher().setMod(modName, modVal);\n        modVal == &#39;yes&#39; &amp;&amp; this.getPopup().hide();\n\n    }\n\n},\n</code></pre><p>...\n%%</p>\n<p>Подробно ((#mods.callbacks о декларации обработки модификаторов)) рассказано в пункте про создание собственного блока.</p>\n<p>%%hl xml\n<a name=\"block.getting\"></a>\n%%\n=== Доступ к другим блокам</p>\n<p>Может возникнуть необходимость управлять другим блоком.\nДля любых манипуляций с блоком необходимо получить доступ к ##js##-объекту этого блока и вызывать его методы.</p>\n<p>%%hl xml\n<a name=\"blocks.finding\"></a>\n%%\n==== Доступ к bem-js-блоку из другого bem-js-блока.</p>\n<p>В случае ((#creation реализации собственного кастомного блока на технологии ##bem-js##)),\nблоку соответствует ##js##-объект. Он наследует общие для всех блоков методы, позволяющие работать с ##DOM## документа в\nтерминах ##BEM##. Среди этих методов есть методы поиска других блоков относительно текущего (##findBlock<em>##-методы).\nОни возвращают ##js##-объект искомого блока, что позволяет затем напрямую вызывать его методы.\\\n<em>*Не используйте ##jQuery##-селекторы для поиска блоков и элементов.</em></em></p>\n<p>В этом примере вызывается метод ##val()## у блока ##b-form-checkbox##:\n%%hl js\nBEM.DOM.decl(&#39;b-checkbox-example&#39;, {</p>\n<pre><code>onSetMod: {\n    &#39;js&#39;: function() {\n        var checkbox = this.findBlockInside({ blockName : &#39;b-form-checkbox&#39;, modName : &#39;type&#39;, modVal : &#39;my-checkbox&#39;});\n        this.domElem.append(&#39;Значение checkbox: &#39; + checkbox.val());\n    }\n}\n</code></pre><p>}\n);\n%%</p>\n<p>==== Доступ к bem-js-блоку не из bem-js-блока</p>\n<p>В случае работы не из ##bem-js-блока##, методы ##findBlock<em>## недоступны. ##js##-объект блока можно\nполучить, используя метод ##.bem()## ##jQuery## коллекции:\n%%hl js\n$(уникальный селектор).bem(&#39;b-link&#39;);\n%%\nЭтот способ <em>*не рекомендован</em></em>. Лучшим вариантом работы с блоками, реализованными на ##i-bem##,\nявляется создание собственного компонента на ##i-bem##. Подробнее о ((#creation создании собственного\nbem-js-компонента)) написано ниже.</p>\n<p>%%hl xml\n<a name=\"mods\"></a>\n%%\n=== Работа с модификаторами блока</p>\n<p>Модификатор задаёт блоку определённое состояние. Каждому блоку\nможно присвоить один или несколько модификаторов (у блока также может не быть модификаторов вообще).\nУ модификатора есть имя и значение.</p>\n<p>Любой перевод блока в другое состояние должен производиться при помощи установки модификатора.\nНапример, для того, чтобы сделать чекбокс выделенным в блоке ##b-form-checkbox##, ему\nнужно установить модификатор ##checked## в значение ##yes##.\\\nНа странице документации каждого блока есть список его элементов и модификаторов.\nИз этого списка можно однозначно определять, какие состояния блока доступны для использования.</p>\n<p>Модификаторы нельзя устанавливать, напрямую меняя ##CSS## класс на соответствующей ##DOM##-ноде. Для\nкорректной работы ##js## все манипуляции с модификаторами должны производиться при помощи\nметода-хелпера ##setMod()##. Также существуют методы ##hasMod()##, ##getMod##/##getMods()##, ##toggleMod()##\nи ##delMod()##. Сигнатуры этих методов доступны в ((/blocks/i-bem/i-bem.jsdoc.wiki референсе по BEM)).</p>\n<p>%%hl xml\n<a name=\"customization\"></a>\n%%\n=== Изменение поведения существующих блоков</p>\n<p>Используя ##bem-js##, можно переопределять и доопределять\nметоды блока и функций реакции на изменения модификаторов. Это делается аналогично кастомизации\nблоков на ##CSS## или ##BEMHTML##.</p>\n<p>==== Переопределение поведения\nНапример, на сервисе существует необходимость модифицировать все блоки ##b-dropdowna## так, чтобы\nони не закрывались по второму клику на псевдо-ссылку. В этом случае на уровне переопределения\nсервиса нужно сделать файл ##blocks/b-dropdowna/b-dropdowna.js##, кастомизирующий поведение блока\nиз библиотеки:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-dropdowna&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;js&#39; : function() {\n\n        this._getSwitcher().on(&#39;click&#39;, this._on, this);\n\n    }\n},\n_on : function() {\n    this.getPopup().show(this.elem(&#39;switcher&#39;));\n}\n</code></pre><p>});\n%%</p>\n<p>==== Расширение поведения\nВ предыдущем примере код кастомизации полностью переопределяет поведение\nблока. Технология ##bem-js## позволяет также реализовывать «доопределение»\nблока. Для этого в методах кастомизирующего кода можно вызывать ##this._~_base.apply()##,\nпередавая в качестве аргументов ##this## и ##arguments##. Вызов такого метода аналогичен\nиспользованию ##<xsl:apply-imports/>##.</p>\n<p>Например, можно доопределить реакцию на клик всех блоков ##b-link##\nна проекте, так, чтобы после первого клика на псевдо-ссылку она приобретала красный цвет.</p>\n<p>Содержание файла ##blocks/b-link/_pseudo/b-link_pseudo_yes.js##\n%%hl js\nBEM.DOM.decl({&#39;name&#39;: &#39;b-link&#39;, &#39;modName&#39;: &#39;pseudo&#39;, &#39;modVal&#39;: &#39;yes&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .setMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n%%</p>\n<p>Содержание файла ##blocks/b-link/_status/b-link_status_clicked.css##</p>\n<p>%%hl xml\n.b-link_status_clicked\n{\n    color: red;\n}\n%%</p>\n<p>==== Кастомизация с использованием модификаторов</p>\n<p>Предыдущие примеры кастомизации изменяют поведение //всех// определенных блоков на странице.\nНо очень часто возникает задача кастомизации конкретного блока без влияния на\nповедение всех таких блоков. Согласно концепции ##BEM##,\nесли блок чем-то отличается от других похожих, это выражается модификатором. Так что нужно\nреализовывать поведение для блока с таким модификатором.</p>\n<p>Возвращаясь к примеру про псевдоссылку, приобретающую красный цвет после первого\nклика, сделаем модификацию ##reaction_odd##. Псевдоссылка с таким модификатором\nприобретает красный цвет после каждого\nнечётного клика, а после каждого чётного возвращается к исходному цвету .</p>\n<p>Содержание файла ##blocks/b-link/_reaction/b-link_reaction_odd.js##:\n%%hl js\nBEM.DOM.decl({name : &#39;b-link&#39;, modName : &#39;reaction&#39;, &#39;modVal&#39; : &#39;odd&#39;}, {\n    _onClick : function() {\n         this\n            .__base.apply(this, arguments) // выполнить метод _onClick основного b-link\n            .toggleMod(&#39;status&#39;, &#39;clicked&#39;);\n    }\n});\n%%</p>\n<p>%%hl xml\n<a name=\"creation\"></a>\n%%</p>\n<p>=== Создание js-компонента для собственного блока или собственной модификации</p>\n<p>Рекомендованным способом работы с ##bem-js-блоками## является создание собственных ##bem-js-блоков##\n(чаще всего — контейнеров), реагирующих на события других блоков страницы. Собственные</p>\n<h2 id=\"bem-js-\">bem-js-блоки## могут вызывать методы других блоков (если нужно) и реализовывать свой функционал.\\</h2>\n<h2 id=\"js-\">js-код## блока принято размещать в папке блока в файле с именем, соответствующим имени блока, и расширением</h2>\n<h2 id=\"-js-js-\">.js##. Если ##js-реализация## относится не к блоку, а лишь к одной из его модификаций, можно</h2>\n<p>разместить код в ##js-файле##, соответствующем данному модификатору.</p>\n<p>%%hl xml\n<a name=\"dom.decl\"></a>\n%%\n==== Декларация блока</p>\n<p>Создание ##js-компонента## блока сводится к его декларации с помощью специальных хелперов.\nСуществуют два хелпера для декларации блоков: один для блоков, которые имеют ##DOM##-представление,\nвторой — для блоков, не имеющих ##DOM## представления (например ##i-request##, ##i-update-session##).</p>\n<p>В первом случае блоки декларируются с помощью ##BEM.DOM.decl##, во втором — с помощью ##BEM.decl##.</p>\n<p>Хелпер декларации блока принимает 3 параметра:</p>\n<ol>\n<li>Матчащий параметр\\\nПервым параметром может быть либо строка с именем\nблока, либо хеш. Хеш кроме имени блока содержит дополнительную информацию о том, к какому\nтипу блоков применять компонент.</li>\n<li>Методы и свойства экземляра блока\\\nМетоды и свойства, предметной областью которых является конкретный инстанс блока\nна странице. Это как ((#mods.callbacks функции обработки модификаторов)),\nтак и ((#methods кастомные методы блока)).</li>\n<li>Статические методы и свойства\\\nМетоды и свойства, не относящиеся к конкретному инстансу блока. ((#static.methods Подробнее))</li>\n</ol>\n<p>Например:\n%%hl js\nBEM.DOM.decl(\n    &#39;b-link&#39;, // имя блока\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n    });\n%%</p>\n<p>и</p>\n<p>%%hl js\nBEM.decl(&#39;i-request&#39;, {\n    {\n        // методы и свойства экземпляра блока\n    },\n    {\n        // статические методы и свойства блока\n});\n%%</p>\n<p>Вместо имени блока может быть указано более сложное описание, например, информация о предке:\n%%hl js\nBEM.decl({ name : &#39;b-dataprovider&#39;, baseBlock : &#39;i-request&#39; }, {</p>\n<pre><code>get : function() {\n    this.__base(); // вызов одноименного метода из i-request\n    doSomething();\n}\n</code></pre><p>});\n%%\nТут указано, что блок ##b-dataprovider## наследуется от блока ##i-request## и переопределяет его метод ##get##.</p>\n<p>В первом параметре (хеше) декларации может быть указано не только то, к какому блоку\nприменить компонент, но и уточнён модификатор и/или его значение:\n%%hl js\nBEM.decl({ name : &#39;b-popup&#39;, modName : &#39;type&#39;, modVal : &#39;inplace&#39; }, {</p>\n<pre><code>show : function() {\n    doSomething();\n}\n</code></pre><p>});\n%%\nВсе методы, описанные в такой декларации, будут вызываться для таких блоков ##b-popup##,\nкоторые в данный момент имеют модификатор ##type##, установленный в ##inplace##.</p>\n<p>%%hl xml\n<a name=\"mods.callbacks\"></a>\n%%\n==== Реакция на изменение модификаторов</p>\n<p>Согласно концепции ##BEM## состояния блоков и его элементов\nопределяются модификаторами. Блок может сам назначать себе или своему элементу модификатор,\nили получать это назначение из другого блока.\\\nВо время того, как блок или элемент получил определённый модификатор, может возникнуть\nнеобходимость отреагировать на установку (или снятие) модификатора.</p>\n<p>Для этого в декларации в части описании методов и свойств экземпляра блока зарезервировано два специальных\nсвойства: ##onSetMod## и ##onElemSetMod##, где описываются ##callback##-функции,\nвызываемые при установке модификаторов для блока или его элементов.</p>\n<p>Описание ##callback##-функций для ##onSetMod## представляет собой хеш вида:\n%%hl js\n{\n    &#39;модификатор1&#39; : {</p>\n<pre><code>    &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39;\n\n    ...\n\n    &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39;\n\n    &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений\n\n},\n\n&#39;модификатор2&#39; : function() {}, // функция, которая будет вызвана при установке модификатора &#39;модификатор2&#39; в любое из значений\n\n...\n\n&#39;модификаторN&#39; : {\n\n    &#39;значение1-модификатораN&#39; : function() { ... },\n\n    ...\n\n    &#39;значениеN-модификатораN&#39; : function() { ... }\n\n}\n</code></pre><p>}\n%%</p>\n<p>Описание ##callback##-функций для ##onElemSetMod## аналогично, за исключением того, что на верхнем уровне указывается имя элемента:\n%%hl js\n{</p>\n<pre><code>&#39;элемент1&#39; : {\n\n    &#39;модификатор1&#39; : {\n\n        &#39;значение1-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значение1&#39; для элемента &#39;элемент1&#39;\n\n        ...\n\n        &#39;значениеN-модификатора1&#39; : function() { ... }, // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в значение &#39;значениеN&#39; для элемента &#39;элемент1&#39;\n\n        &#39;*&#39; : function() { ... } // функция, которая будет вызвана при установке модификатора &#39;модификатор1&#39; в любое из значений  для элемента &#39;элемент1&#39;\n\n    }\n\n},\n\n...\n\n&#39;элементN&#39; : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента &#39;элементN&#39;\n</code></pre><p>}\n%%</p>\n<p>Параметры ##callback##-функций:</p>\n<ul>\n<li><h2 id=\"-jquery-elem-\">{jQuery} [elem]## — элемент блока (если установка модификатора была для элемента)</h2>\n</li>\n<li><h2 id=\"-string-modname-\">{String} modName## — имя модификатора</h2>\n</li>\n<li><h2 id=\"-string-modval-\">{String} modVal## — устанавливаемое значение модификатора</h2>\n</li>\n<li><h2 id=\"-string-curmodval-\">{String} curModVal## — текущее значение модификатора</h2>\n</li>\n</ul>\n<p>Порядок вызовов ##callback##-функций при установке модификатора ##modVal## в значение ##modName##:</p>\n<ul>\n<li>вызывается ##callback##-функция на установку любого модификатора в любое значение (если она существует)</li>\n<li>вызывается ##callback##-функция на установку модификатора ##modVal## в любое значение (если она существует)</li>\n<li>вызывается ##callback##-функция на установку модификатора ##modVal## в значение ##modName## (если она существует)</li>\n</ul>\n<p>Если хоть один из вызовов этих функций вернет ##false##, то установки модификатора не произойдет.</p>\n<p>Например:\n%%hl js\nBEM.DOM.decl(&#39;b-menu&#39;, {</p>\n<pre><code>onElemSetMod : {\n\n    &#39;trigger&#39; : {\n\n        &#39;state&#39; : function(elem, modName, modVal) {\n\n            // тут описаны действия, которые нужно совершить при установке элементу &#39;trigger&#39; модификатора с именем &#39;state&#39; в любое значение\n            this\n                .toggleMod(\n                    this.findElem(elem.closest(this.buildSelector(&#39;layout-cell&#39;)), &#39;item-content&#39;).eq(0),\n                    &#39;visibility&#39;,\n                    &#39;visible&#39;,\n                    modVal == &#39;opened&#39;)\n                .trigger(&#39;trigger&#39;, {\n                    domElem : elem,\n                    state : modVal\n                });\n\n        }\n\n    }\n\n},\n\nonTriggerClick : function(e) { // при клике на триггер\n\n    e.preventDefault();\n    this.toggleMod(e.data.domElem, &#39;state&#39;, &#39;opened&#39;); // устанавливаем или снимаем значение &#39;opened&#39; у модификатор &#39;state&#39; для элемента &#39;trigger&#39;\n\n}\n</code></pre><p>}, {</p>\n<pre><code>live : function() {\n\n    this\n        .liveBindTo(&#39;trigger&#39;, &#39;click&#39;, function(e) { // слушаем live-клик на элементах &#39;trigger&#39;\n            this.onTriggerClick(e);\n        });\n\n}\n</code></pre><p>});\n%%</p>\n<h2 id=\"-togglemod-ontriggerclick-callback-onelemsetmod-\">В данном примере при вызове ##toggleMod## внутри ##onTriggerClick## будет вызвана соответствущая ей ##callback##-функция из ##onElemSetMod##.</h2>\n<h2 id=\"callback-\">Callback## функции, реагирующие на изменение модификатора, выполняются до установки модификатора.</h2>\n<p>Если существует необходимость выполнить часть кода после установки модификатора,\nнужно воспользоваться методом ##.afterCurrentEvent()##.</p>\n<p>Пример ниже демонстрирует, что квадратик становится больше только после установки\nмодификатора:\n%%hl js\nBEM.DOM.decl(&#39;b-square2&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;js&#39; : function() {\n\n        var square = this;\n\n        this.bindTo(&#39;click&#39;, function(){\n            square.setMod(&#39;size&#39;, &#39;big&#39;);\n        });\n\n    },\n    &#39;size&#39; : function() {\n        this.domElem.append(&#39;размер1: &#39;, this.domElem.width() + &#39;&lt;br/&gt;&#39;); // напишет 200\n\n        this.afterCurrentEvent(function(){\n            this.domElem.append(&#39;размер2: &#39;, this.domElem.width()); // напишет 400\n        });\n    }\n}\n</code></pre><p>});\n%%</p>\n<p>===== Начало работы с блоком (модификатор ##js##)</p>\n<p>Блок начинает свою работу с действий, описанных в ##callback##-функции на установку его модификатора ##js## в значение ##inited##:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-form-input&#39;, {</p>\n<pre><code>onSetMod : {\n\n    &#39;js&#39; : {\n\n        &#39;inited&#39; : function() {\n\n            this\n                .bindTo(this.elem(&#39;input&#39;), {\n                    &#39;focus&#39; : this.onFocus,\n                    &#39;blur&#39;  : this.onBlur\n                })\n\n        }\n\n    }\n\n}\n</code></pre><p>});\n%%</p>\n<p>Этот модификатор присваивается блоку в момент инициализации.\nПоскольку код обработчика модификатора выполняется до установки модификатора, эта функция-обработчик\nи является первой выполняющейся функцией блока.</p>\n<p>Модификаторы могут без ограничения присваиваться как блокам, имеющим</p>\n<h2 id=\"dom-dom-\">DOM## представление, так и блокам без него. Так что, у блоков без ##DOM## представления</h2>\n<p>первый исполняемый метод также задаётся как ##callback## модификатора ##js_inited##.</p>\n<p>В коде блоков можно встретить ##callback## функцию не на значение ##inited## модификатора</p>\n<h2 id=\"js-js-\">js##, а на установку модификатора ##js## в любое значение:</h2>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-form-input&#39;, {</p>\n<pre><code>onSetMod : {\n\n&#39;js&#39; : function() { // конструктор b-form-input\n    ...\n    }\n\n}\n</code></pre><p>});\n%%</p>\n<p>Это краткая декларация, возможная из-за того, что до инициализации блок\nне имеет модификатора ##js##, а в момент инциализации приобретает значение ##inited##.\nДругие значения модификатора сейчас не предусмотрены.</p>\n<p>%%hl xml\n<a name=\"methods\"></a>\n%%\n==== Методы блока</p>\n<p>Кроме реакции на модификаторы, в блоке могут быть определены его собственные методы.\nОпределённые в блоке методы могут быть вызваны им самим или другими блоками.</p>\n<p>Например, так выглядит метод ##.toggle()## блока ((/blocks/b-form-checkbox/b-form/checkbox.wiki b-form-checkbox)):</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-form-checkbox&#39;, {\n    ...\n    toggle : function() {\n        this.toggleMod(&#39;checked&#39;, &#39;yes&#39;, &#39;&#39;);\n    }\n    ...\n});\n%%</p>\n<p>===== Переопределение и доопределение методов блока</p>\n<p>Любой метод блока (в том числе и методы обработки модификаторов) может быть переопределён.\nОб этом написано выше в пункте ((#customization Изменение поведения существующих блоков)).</p>\n<p>%%hl xml\n<a name=\"static.methods\"></a>\n%%\n==== Статические методы блока\nТретий параметр, передаваемый в функцию декларации блока, -- это хеш статических\nметодов блока.</p>\n<p>Примером блока, использующего статические методы, может служить\n((/blocks/b-flash/b-flash.wiki)).</p>\n<p>Для каждого блока может быть определен статический метод ##live##, позвляющий реализовать\n((#liveinit инициализацию по требованию (liveinit~))).</p>\n<p>%%hl xml\n<a name=\"init\"></a>\n%%\n=== Инициализация</p>\n<p>Для того, чтобы у блока появился ##js-объект##, описанный в декларации, происходит процесс инициализации\nблока.\nИнициализация блоков производится функцией ##BEM.DOM.init()## на фрагменте ##DOM## дерева.\nЕсли элемент ##i-bem_~_dom## задекларирован с модификатором ##init_auto## (подключается файл</p>\n<h2 id=\"i-bem_-_dom_init_auto-js-\">i-bem_~_dom_init_auto.js##), то инициализация блоков происходит на всём документе по событию</h2>\n<p>domReady. Также функцию ##BEM.DOM.init## можно вызвать самостоятельно. Например, это делается\nдля инициализации блоков после динамического изменения страницы, если появились новые блоки с js-представлением.</p>\n<p>==== Инициализация блоков с DOM-представлением\nДля инициализации блоков, представленных в ##DOM##, на фрагменте дерева ищутся все блоки,\nпомеченные классом ##i-bem##, у них считываются параметры из атрибута ##onclick##, и\nсоздаётся ##js-объект## такого блока.</p>\n<p>%%hl xml\n<a name=\"onclick.params\"></a>\n%%\n===== Формат параметров блока в onclick\nПараметры для блока записываются в виде возвращаемого атрибутом ##onclick## хеша.\nЭтот хеш должен содержать элементы с названиями, соответствующими названиям блоков,\nк которым они относятся. Значением каждого элемента должен быть вложенный хеш c\nпараметрами.\\\nТакая запись позволяет задавать параметры для нескольких блоков в том случае, если\nони представлены в ##HTML## одной и той же ##DOM-нодой##.</p>\n<p>Вот как выглядит ##DOM-нода## произвольного блока, реализованного на ##bem-js##:</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block i-bem\" onclick=\"return {\n    'b-my-block' : {}\n}\">\n..\n</div>\n%%</p>\n<p>В случае, если блоку необходим параметр, он указывается на том же уровне, что и\nэлемент ##name##. Формат параметра может быть любым: строка, число, массив, хеш, функция.\nКоличество параметров также не ограничено.</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'points' : [\n            [1.67, 2.5],\n            [-30, 2.07],\n            [290, -0.39]\n        ],\n        'title' : 'Какое-то название',\n    }\n}\">\n..\n</div>\n%%</p>\n<p>Для нескольких блоков на одной ##DOM-ноде## ##HTML## представление будет аналогично следующему:</p>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block b-my-second-block i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'title' : 'Какое-то название', // Этот блок имеет опцинальный параметр title\n    },\n    'b-my-second-block' : {\n        // У этого блока нет никаких опциональных параметров\n    }\n}\">\n..\n</div>\n%%</p>\n<p>===== DOM-представление инициализированного блока\nПосле инициализации ##DOM## представление блока изменяется: у блока появляется дополнительный\nмодификатор ##js_inited##.\\\nЕсли ##DOM-ноде## соответствуют несколько блоков, то появление модификатора у одного из них\nсвидетельствует об инициализации только этого блока и не влияет на инициализацию другого (других).</p>\n<p>DOM-представление блока после инициализации:\n%%hl xml</p>\n<p><div class=\"b-my-block b-my-block_js_inited i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'name' : 'b-my-block'\n    }\n}\">\n..\n</div>\n%%</p>\n<h2 id=\"dom-\">DOM## представление двух блоков после инициализации:</h2>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block b-my-second-block b-my-block_js_inited b-my-second-block_js_inited i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'name' : 'b-my-block',\n    },\n    'b-my-second-block' : {\n        'name' : 'b-my-second-block'\n    }\n}\">\n%%</p>\n<h2 id=\"dom-\">DOM## представление двух блоков, но инициализован только один из них:</h2>\n<p>%%hl xml</p>\n<p><div class=\"b-my-block b-my-second-block b-my-second-block_js_inited i-bem\" onclick=\"return {\n    'b-my-block' : {\n        'name' : 'b-my-block',\n    },\n    'b-my-second-block' : {\n        'name' : 'b-my-second-block'\n    }\n}\">\n%%</p>\n<p>==== Инициализация блоков без DOM-представления</p>\n<p>В том случае, если у блока нет ##DOM## представления, в процессе инициализации просто возникает</p>\n<h2 id=\"js-\">js-объект##, соответствующий этому блоку. Дальнейшее зависит от кода блока.</h2>\n<p>%%hl xml\n<a name=\"liveinit\"></a>\n%%\n=== Инициализация по требованию (liveInit)\nМногим блокам (например, ##b-link##, ##b-dropdown##, ##b-smart-help##) нет необходимости делать сразу же полную инициализацию.\nИнициализация может происходить только на ключевые события для этого блока, например, клик по элементу этого блока.\nРассмотрим на примере блока ##b-link##:</p>\n<p>%%hl js\nBEM.DOM.decl(&#39;b-link&#39;, {</p>\n<pre><code>_onClick : function(e) {\n\n    e.preventDefault();\n    this.trigger(&#39;click&#39;);\n\n}\n</code></pre><p>}, {</p>\n<pre><code>live : function() {\n\n    this.liveBindTo(&#39;click&#39;, function(e) {\n        this._onClick(e);\n    });\n\n}\n</code></pre><p>});\n%%</p>\n<p>В статических свойствах блока предусмотрено специальное свойство ##live## (##Function##|##Boolean##), отвечающее за инициализацию по требованию и за\nподписку на ##live## события на ##DOM## элементах внутри такого блока.</p>\n<p>Если ##live## определено как ##Function##, то эта функция будет выполнена один раз — при попытке инициализации первого такого блока.</p>\n<p>Существует несколько хелперов для ##live## событий:</p>\n<pre><code>* ##liveInitOnEvent## — хелпер для инициализации блока по событию на блоке или его внутреннем элементе\n* ##liveBindTo## — подписка на события на блоке или его внутреннем элементе\n</code></pre><p>Оба этих хелпера инициализируют блок при возникновении первого такого события.\nРазличие же заключается в том, что ##callback## функция в ##liveInitOnEvent## вызывается только один раз после инициализации блока,\nа в ##liveBindTo## она будет вызываться при каждом событии.\nКонтекстом такой ##callback## функции является тот блок, в котором произошло событие.</p>\n<p>В вышеприведенном примере блок ##b-link## будет инициализирован при первом клике на себе и будет реагировать на каждый последующий клик.</p>\n<p>Если же ##live## определено как ##Boolean## и установлено в ##true##,\nто такой блок будет инициализирован только при попытке доступа к нему, например, из методов поиска ##findBlockInside##/##findBlockOutside##.</p>\n<p><a name=\"finding\"></a>\n=== Методы доступа к блокам и элементам</p>\n<p>Работая с блоками, реализованными на ##bem-js##, необходимо использовать\nвстроенные методы для поиска блоков и их элементов. Эти методы доступны\nв каждом блоке и умеют возвращать другой блок или ##jQuery## коллекцию (в случае\nпоиска элементов).</p>\n<p>==== Методы поиска блоков</p>\n<p>Поиск блоков осуществляется относительно текущего блока при помощи методов</p>\n<h2 id=\"findblock-\">findBlock*##.</h2>\n<p>Реализуем блок ##b-my-block##, который находит первый из блоков ##b-form-checkbox##\nвнутри себя и вызывает у него метод ##toggle()## для переключения чекбокса.\n%%hl js\nBEM.DOM.decl(&#39;b-my-block&#39;, {\n    onSetMod : {\n        &#39;js&#39; : function() {\n            var checkbox = this.findBlockInside(&#39;b-form-checkbox&#39;);\n            checkbox.toggle();\n        }\n    }\n});\n%%</p>\n<p>Поиск блока или блоков может быть выполнен одним из следующих методов:</p>\n<ul>\n<li><h2 id=\"findblockinside-findblocksinside-dom-\">findBlockInside/findBlocksInside## — поиск блока/блоков внутри ##DOM## элементов текущего блока или его элементов</h2>\n</li>\n<li><h2 id=\"findblockon-findblockson-dom-\">findBlockOn/findBlocksOn## — поиск блока/блоков на ##DOM## элементах текущего блока или его элементов</h2>\n</li>\n<li><h2 id=\"findblockoutside-findblocksoutside-dom-\">findBlockOutside/findBlocksOutside## — поиск блока/блоков снаружи ##DOM## элементов текущего блока или его элементов</h2>\n</li>\n</ul>\n<p>Список методов поиска блоков и их сигнатуры можно посмотреть в\n((/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki референсе по BEM.DOM)).</p>\n<p>Примерами блоков, использующих методы поиска других блоков, могут быть:\n((/blocks/b-smart-help/b-smart-help.wiki b-smart-help)),\n((blocks/b-screenshot/b-screenshot.wiki b-screenshot)) и\n((blocks/b-dropdowna/b-dropdowna.wiki b-dropdowna)).</p>\n<p>==== Методы доступа к элементам\nДля поиска элементов внутри блока используется метод ##elem##. Результат этого метода кэшируется.</p>\n<p>Например:\n%%hl js\nBEM.DOM.decl(&#39;b-form-input&#39;, {</p>\n<pre><code>doSomething : function() {\n\n    this.elem(&#39;hint&#39;); // тут будут найдены элементы b-form-input__hint\n\n}\n</code></pre><p>});\n%%</p>\n<p>Можно искать элементы внутри блока с учетом модификатора:\n%%hl js\nBEM.DOM.decl(&#39;b-menu&#39;, {</p>\n<pre><code>doSomething : function() {\n\n    this.elem(&#39;item&#39;, &#39;state&#39;, &#39;current&#39;); // тут будут найдены элементы b-menu__item_state_current\n\n}\n</code></pre><p>});\n%%</p>\n<p>Некэширующий метод поиска элементов называется ##findElem()##.</p>\n<p>Полный список методов для поиска элементов и их сигнатуры можно найти в\n((/blocks/i-bem/dom/i-bem__dom.jsdoc.wiki референсе по BEM.DOM)).</p>\n<p>%%hl xml\n<a name=\"events\"></a>\n%%\n=== Работа с событиями</p>\n<p>==== События на блоках</p>\n<p>Блоки предоставляют интерфейс для подписки/отписки/нотификации своих собственных (не ##DOM##) событий:</p>\n<ul>\n<li><h2 id=\"on-e-data-fn-ctx-e\">on(e, [data], fn, [ctx])## — подписка на событие ##e</h2>\n</li>\n<li><h2 id=\"onfirst-e-data-fn-ctx-e\">onFirst(e, [data], fn, [ctx])## — подписка только на первое событие ##e</h2>\n</li>\n<li><h2 id=\"un-e-fn-ctx-e-\">un([e], [fn], [ctx])## — отписка от конкретного события ##e## или всех событий</h2>\n</li>\n<li><h2 id=\"trigger-e-data-e\">trigger(e, [data])## — нотификация о событии  ##e</h2>\n</li>\n</ul>\n<p>==== live-события на блоках</p>\n<p>В ##bem-js## есть события, реализованные по паттерну\nделегированных событий, они называются ##live## события.</p>\n<p>Следующий пример демонстрирует работу с live-событием ##click## для блоков ##b-link##,\nсодержащихся в определённой ##DOM-ноде##. В данном случае контейнер и блок совпадают:\n%%hl js\nBEM.DOM.decl(&#39;b-link-example&#39;, {</p>\n<pre><code>onSetMod: {\n    &#39;js&#39;: function() {\n        var link = this.findBlockInside(&#39;b-link&#39;);\n        BEM.blocks[&#39;b-link&#39;]\n            .liveCtxBind(link.domElem,\n                        &#39;click&#39;,\n                        function(){\n                            link.domElem.text(&#39;Кликнутая ссылка&#39;);\n                        },\n                        this);\n    }\n}\n</code></pre><p>},\n{\n    live: function() {\n        this.liveInitOnBlockInsideInit(&#39;b-link&#39;);\n    }\n}\n);\n%%</p>\n<p>Метод ##.liveCtxBind()## реализует возможность реакции на bem-события блоков,\nвложенных в какой-либо ##DOM## элемент. <strong>Это не DOM-события</strong>\\\nИспользование ##live## событий позволяет избежать лишнего поиска блоков в ##DOM## дереве.\nКроме того, при такой привязке к событию реакция на событие блока из контейнера будет\nпроисходить даже в том случае, если на момент привязки блока в контейнере не было, а он \nпоявился позже в результате динамического изменения документа.</p>\n<p>Кроме возможности привязки к ##live## событию блока, здесь также продемонстрированы ((#blocks.finding поиск блока относительно текущего))\nи ((#liveinit live-инициалиация)).\\</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "i-bem.examples/15-i-bem_click/_15-i-bem_click"
                            },
                            {
                                "url": "i-bem.examples/17-i-bem_square/_17-i-bem_square"
                            },
                            {
                                "url": "i-bem.examples/20-i-bem_liveinit-multiple/_20-i-bem_liveinit-multiple"
                            },
                            {
                                "url": "i-bem.examples/40-i-bem_extend/_40-i-bem_extend"
                            },
                            {
                                "url": "i-bem.examples/60-i-bem_pseudo-link/_60-i-bem_pseudo-link"
                            }
                        ]
                    }
                },
                {
                    "name": "i-ecma",
                    "jsdoc": null,
                    "data": {
                        "name": "i-ecma",
                        "description": [
                            {
                                "content": "<p>Блок ##i-ecma## — это блок, позволяющий использовать некоторые методы\n(##forEach##, ##map##, ...) из ##ECMAScript 5## для браузеров, не имеющих их нативной поддержки.</p>\n"
                            }
                        ],
                        "examples": []
                    }
                },
                {
                    "name": "i-geolocation",
                    "jsdoc": null,
                    "data": {
                        "name": "i-geolocation",
                        "description": [
                            {
                                "content": "<p>Обёртка над Geolocation API для получения информации о текущем местоположении пользователя.</p>\n<p>Если всё хорошо, статический метод get() вернёт в колбэк объект со следующими данными:</p>\n<ul>\n<li>latitude - широта, градусы;</li>\n<li>longitude - долгота, градусы;</li>\n<li>altitude -  высота над уровнем моря, м;</li>\n<li>altitudeAccuracy - точность определения высоты, м;</li>\n<li>speed - скорость движения, м/с;</li>\n<li>heading - направление движения, в градусах относительно географического севера;</li>\n<li>accuracy - точность, м;</li>\n<li>timestamp - время, DOMTimeStamp;</li>\n</ul>\n<p>Если всё плохо, статический метод get() вернёт в колбэк объект с кодом ошибки:</p>\n<ul>\n<li>1 - браузер не поддерживает Geolocation API;</li>\n<li>2 - пользователь отклонил запрос на получение текущего местоположения;</li>\n<li>3 - невозможно получить данные / нет ответа от спутников;</li>\n<li>4 - таймаут;</li>\n<li>5 - что-то ещё пошло не так / неизвестная ошибка;</li>\n</ul>\n<p>Параметры:</p>\n<ul>\n<li>enableHighAccuracy - если есть и активирован полноценный GPS, то полученные данные будут более точные (по умолчанию true);</li>\n<li>timeout - таймаут геозапроса, в секундах (по умолчанию 15);</li>\n<li>cacheTime - время кэширования геозапроса, в течение которого полученные данные считаются актуальными, в минутах (по умолчанию 15);</li>\n</ul>\n<p>Пример использования:</p>\n<p>%%hl js\n    ...\n    BEM.blocks[&#39;i-geolocation&#39;].get(params, function(data) {\n        if (data.error) {\n            ...\n        } else {\n            ...\n        }\n    });\n    ...\n%%</p>\n"
                            }
                        ],
                        "examples": []
                    }
                },
                {
                    "name": "i-jquery",
                    "jsdoc": null,
                    "data": {
                        "name": "i-jquery",
                        "description": [
                            {
                                "content": "<p>Используется для поставки на страницу нужных плагинов через зависимости блоков от элементов блока ##i-jquery##.</p>\n<p>Блок ##i-jquery## помогает подключить ##jQuery## на страницу и упорядочивает хранение js-кода плагинов.</p>\n<p>На уровне ##blocks-common## блок ##i-jquery## состоит из нескольких элементов, которые содержат плагины к ##jQuery##.\nДекларация этих элементов обеспечивает подключение этих плагинов в страничный ##JS##.\\</p>\n<p>На уровне ##blocks-desktop## есть дополнительный элемент ##core##.</p>\n<p>Таким образом, для того, чтобы поддерживаемая версия ##jQuery## оказалась на страницах, нужно\nиспользовать такой ##BEMJSON##:</p>\n<p>%%hl js\n({\n    block: &#39;b-page&#39;,\n    title: &#39;Страница про ссылку&#39;,\n    head: [\n        ...\n        { block: &#39;i-jquery&#39;, elem: &#39;core&#39; },\n        ...\n    ],\n%%</p>\n<p>Этот шаблон не продуцирует ##DOM##-представление элемента. Он декларирует использование на странице элемента ##js##,\nблока ##b-page##, подключающего ##js## с ##jQuery##.</p>\n<p>Если мы решим перейти на новую версию библиотеки, просто изменим этот шаблон. И тогда у всех\nпроектов, подключавших ##jQuery## не вручную, а через блок ##i-jquery##, своевременно изменится версия.</p>\n<p>Можно перезаписать этот базовый шаблон ##BEMHTML## шаблоном на своём уровне переопределения\n(для всего проекта или только для некоторых страниц). В этом случае, используя те же самые входные данные,\nможно получать более подходящий проекту результат.</p>\n<p>В директории элемента ##core## в виде кода модификаторов элемента размещены совместимые с библиотекой\nверсии ##jQuery## в минимизированном состоянии. При помощи переопределения ##BEMHTML## шаблона такими файлами\nможно пользоваться для оффлайн-разработки:</p>\n<p>%%hl js\nblock i-jquery, elem core, default: {\n    local(\n        this._mode = &#39;&#39;,\n        this.ctx = {\n            block: &#39;b-page&#39;,\n            elem: &#39;js&#39;,\n            url: &#39;/bem-bl/blocks-desktop/i-jquery/<strong>core/_version/i-jquery</strong>core_version_1.6.2.js&#39;\n        }\n    ) this.apply()\n}\n%%</p>\n"
                            }
                        ],
                        "examples": []
                    }
                },
                {
                    "name": "i-menu",
                    "jsdoc": null,
                    "data": {
                        "name": "i-menu",
                        "description": [
                            {
                                "content": "<p>Блок помощник для построения абстрактного меню.</p>\n<p>Содержит js функциональность, которая используется в блоках ##b-menu-vert## и ##b-menu-horiz##.</p>\n<p>Слушает событие ##leftclick## на элементе ##item-selector## и переводит в ##{ state: &#39;current&#39; }## тот элемент ##item##\nна котором произошло событие.</p>\n<p>Тригерит событие которое можно использовать из других блоков, использующее любое меню.</p>\n"
                            }
                        ],
                        "examples": []
                    }
                },
                {
                    "name": "i-ua",
                    "jsdoc": null,
                    "data": {
                        "name": "i-ua",
                        "description": [
                            {
                                "content": "<p>Блок ##i-ua## — служебный, не имеет визуального представления на странице.</p>\n<p>Этот блок используется всегда, когда используется блок ##b-page##, так как вызывается\nвнутри него. Задавать его самостоятельно на странице не нужно.</p>\n<p>В ##HTML## блок представлен в виде инлайнового скрипта, в результате работы которого,\nу тега ##html## появляются ##CSS## классы, идентифицирующие, включен ли ##JS## и в\nкаком режиме рендеринга находится браузер.</p>\n<p>Эти классы можно использовать, чтобы при помощи ##CSS## задавать блокам разный\nвнешний вид в зависимости от ситуации.</p>\n<p>Если такие классы проекту не нужны, можно переопределить ##BEMHTML## шаблона блока ##i-ua##\nна уровне переопределения проекта:\n%%hl js\nblock i-ua, tag: &#39;&#39;\n%%</p>\n"
                            }
                        ],
                        "examples": [
                            {
                                "url": "i-ua.examples/10-i-ua/_10-i-ua"
                            }
                        ]
                    }
                }
            ]
        }
    ]
}